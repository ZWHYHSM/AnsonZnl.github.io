<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anson&#39;s Blog</title>
  
  <subtitle>种一棵树最好的时间在十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-21T12:38:31.483Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>张宁乐</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我对JavaScript中this的一些理解</title>
    <link href="http://yoursite.com/2019/02/21/%E6%88%91%E5%AF%B9JavaScript%E4%B8%ADthis%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/21/我对JavaScript中this的一些理解/</id>
    <published>2019-02-21T10:34:03.000Z</published>
    <updated>2019-02-21T12:38:31.483Z</updated>
    
    <content type="html"><![CDATA[<p>因为日常工作中经常使用到<code>this</code>，而且在JavaScript中<code>this</code>的指向问题也很容易让人混淆一部分知识。<br>这段时间翻阅了一些书籍也查阅了网上一些资料然后结合自己的经验，为了能让自己更好的理解<code>this</code>，进而总结一篇文章。</p><h2 id="this-是什么"><a href="#this-是什么" class="headerlink" title="this 是什么"></a>this 是什么</h2><p><code>this</code>是 JavaScript 语言的一个关键字。它是函数运行时，在函数体内部自动生成的一个对象，只能在函数体内部使用。<br>实际是在函数被调用时才发生的绑定，也就是说<code>this</code>具体指向什么，取决于你是怎么调用的函数。</p><h2 id="this-指向的四种情况"><a href="#this-指向的四种情况" class="headerlink" title="this 指向的四种情况"></a>this 指向的四种情况</h2><p>这四种情况基本涵盖了JavaScript中常见的<code>this</code>指向问题</p><h3 id="1-全局的函数调用，this指向window"><a href="#1-全局的函数调用，this指向window" class="headerlink" title="1. 全局的函数调用，this指向window"></a>1. 全局的函数调用，this指向window</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">function fn() &#123;</span><br><span class="line">   console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">fn();  // 1</span><br></pre></td></tr></table></figure><p>这种 情况下的<code>this</code>其实就是<code>window</code>对象，这个很好理解。<br>但是还有一种情况，就是匿名函数的<code>this</code>也会指向<code>window</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a= &apos;window&apos;;</span><br><span class="line">var obj=&#123;a: &apos;object&apos;&#125;</span><br><span class="line">obj.fn=function()&#123;</span><br><span class="line">console.log(this.a);//Object</span><br><span class="line">+function()&#123;</span><br><span class="line">console.log(this.a)//window</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">obj.fn()</span><br></pre></td></tr></table></figure></p><p>匿名函数的执行环境具有全局性，因此它的<code>this</code>对象通常指向windows。<br>如果对此有疑惑，可以看知乎上的答案：<a href="https://www.zhihu.com/question/21958425" target="_blank" rel="noopener">知乎 - 匿名函数的this指向为什么是window?</a></p><h3 id="2-作为对象方法的调用，this指向该对象"><a href="#2-作为对象方法的调用，this指向该对象" class="headerlink" title="2. 作为对象方法的调用，this指向该对象"></a>2. 作为对象方法的调用，this指向该对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a =&apos;window&apos;</span><br><span class="line">var obj=&#123;</span><br><span class="line">  a: &apos;object&apos;,</span><br><span class="line">  fn: function()&#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fn(); // object</span><br></pre></td></tr></table></figure><p>当函数作为某个对象的方法调用时，<code>this</code>就指这个函数所在的对象。</p><h3 id="3-作为构造函数调用，this指向实例"><a href="#3-作为构造函数调用，this指向实例" class="headerlink" title="3. 作为构造函数调用，this指向实例"></a>3. 作为构造函数调用，this指向实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">　this.x = 1;</span><br><span class="line">&#125;</span><br><span class="line">var obj = new fn();</span><br><span class="line">console.log(obj.x) // 1</span><br></pre></td></tr></table></figure><p>构造函数中的<code>this</code>，在通过<code>new</code>之后会生成一个新对象，this就指这个新对象。<br>对<code>new</code>有疑问的话，可以看 <a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">冴羽的博客 JavaScript深入之new的模拟实现 </a></p><h3 id="4-使用call-apply-bind调用-this指向第一个参数"><a href="#4-使用call-apply-bind调用-this指向第一个参数" class="headerlink" title="4. 使用call/apply/bind调用, this指向第一个参数"></a>4. 使用call/apply/bind调用, this指向第一个参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var obj1=&#123;</span><br><span class="line">  a: &apos;boj1&apos;</span><br><span class="line">&#125;</span><br><span class="line">var obj2=&#123;</span><br><span class="line">  a: &apos;obj2&apos;</span><br><span class="line">&#125;</span><br><span class="line">var obj3=&#123;</span><br><span class="line">  a: &apos;obj3&apos;</span><br><span class="line">&#125;</span><br><span class="line">function fn()&#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">// apply</span><br><span class="line">fn.apply(obj1);// &apos;obj1&apos;</span><br><span class="line">// call</span><br><span class="line">fn.call(obj2);// &apos;obj2&apos;</span><br><span class="line">// bind</span><br><span class="line">var fnBind= fn.bind(obj3);</span><br><span class="line">fnBind();// &apos;obj3&apos;</span><br></pre></td></tr></table></figure><p><code>call/ apply / bind</code>都有一个共同的特点，就是改变<code>this</code>的指向，使用这种方法可以把别人的方法拿过来用到自己身上。</p><p>第一个参数为 <code>null</code> 的时候，视为指向 <code>window</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a=&apos;window&apos;</span><br><span class="line">var obj=&#123;</span><br><span class="line">  a: &apos;boj&apos;,</span><br><span class="line">  fn: function ()&#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn.call(null);// &apos;window&apos;</span><br></pre></td></tr></table></figure></p><p>在这里如果是<code>obj.fn()</code>调用的<code>fn()</code>方法，<code>this</code>应该指向<code>obj</code>没错。<br>但是因为<code>call(null)</code>的存在，改变了指向，所以<code>this</code>指向了<code>window</code>。</p><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><p>正因为比较难理解，所以<code>this</code>指向也是面试时最容易遇到的问题，比如下面这道我曾遇到的一个面试题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var length = 10;</span><br><span class="line">function fn()&#123;</span><br><span class="line">  console.log(this.length);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  length: 5,</span><br><span class="line">  method: function(fn)&#123;</span><br><span class="line">    fn();//10</span><br><span class="line">    arguments[0]();//2 这里的this指向的arguments，所以获取的是arguments.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.method(fn, 1);</span><br></pre></td></tr></table></figure></p><p>在这道题里，不仅考察了对<code>this</code>熟悉程度，还考察了函数的传参形式、作用域、以及<code>arguments</code>这种特殊的数组的理解。<br>只有真正理解了这些才能正确的判断<code>this</code>究竟指向了谁。<br>所以，只有对<code>JavaScript</code>中的各项知识点深入理解，才会对<code>this</code>的概念越加清晰。</p><p>参考：<br><a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="noopener">阮一峰 - Javascript 的 this 用法</a><br><a href="http://caibaojian.com/deep-in-javascript-this.html" target="_blank" rel="noopener">前端开发博客 - 深入理解JavaScript this</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为日常工作中经常使用到&lt;code&gt;this&lt;/code&gt;，而且在JavaScript中&lt;code&gt;this&lt;/code&gt;的指向问题也很容易让人混淆一部分知识。&lt;br&gt;这段时间翻阅了一些书籍也查阅了网上一些资料然后结合自己的经验，为了能让自己更好的理解&lt;code&gt;this&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>理解JS 原型链</title>
    <link href="http://yoursite.com/2019/01/18/%E7%90%86%E8%A7%A3JS%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2019/01/18/理解JS原型链/</id>
    <published>2019-01-18T14:21:55.000Z</published>
    <updated>2019-01-18T15:08:50.007Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来对于JavaScript 的原型链的概念，始终有些东西有一种模糊感，最近刚好有时间就塌下心认真的把《JavaScript高级程序设计》中相关内容认真读了一遍，也查看了很多网上很多资料，以前很多不明白的地方也渐渐明白了起来。<br>写一篇文章记录一下最近学习的感悟。</p><h3 id="字面量创建对象"><a href="#字面量创建对象" class="headerlink" title="字面量创建对象"></a>字面量创建对象</h3><p>我们通常创建一个对象无非就两种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. var obj= new Object();//new 一个Object的实例</span><br><span class="line">2. var obj= &#123;&#125;;//对象字面量</span><br></pre></td></tr></table></figure></p><p>使用对象字面量 和使用new的方式是一样的。<br>为了简便，一般推荐使用使用字面量：<code>var o= {};</code></p><h3 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h3><p>当我们想要创建自定义的对象时，需要用到构造函数。<br>构造函数和普通函数有两个区别：    </p><pre><code>1. 便于和普通函数区分，函数名首字母大写。    2. 使用 `new` 操作符调用，返回一个实例对象。    </code></pre><p>除此之外和普通函数一摸一样。<br>我们使用构造函数<code>Person</code>来创建两个实例对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.sayName= function ()&#123; alert(this.name) &#125;</span><br><span class="line"> &#125;</span><br><span class="line">var person1 = new Person(&apos;小明&apos;);</span><br><span class="line">var person2 = new Person(&apos;小红&apos;);</span><br><span class="line">console.log(person1);//&#123;name: &quot;小明&quot;, sayName: fun&#125;</span><br><span class="line">console.log(person2);//&#123;name: &quot;小红&quot;, sayName: fun&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子不难理解，虽然这两个实例对象都有<code>sayName</code>方法，而且他们两个的作用也是一样的，但却是两个方法，只是名字和作用一样。    </p><p>画个图表示一下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-e6a1cb2af9592327?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="131547802804_.pic.jpg" title="">                </div>                <div class="image-caption">131547802804_.pic.jpg</div>            </figure></p><p>如果还不明白，我在打个比喻：<br>就像A街上有一间麦当劳，在B街上也开了一间麦当劳，它们都叫麦当劳，作用也是一样的。但是你总不能说他们是一间麦当劳吧？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.sayName === person2.sayName;<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>如果这样的话，我们每构造出来一个对象，都要单独为这个对象创建出一个专属于它自己使用的<code>sayName</code>，这是很占用内存的。  </p><p>那我们能不能让所有的实例对象都共同使用一个<code>sayName</code>方法，来节省内存，提升效率呢？这需要我们先理解原型对象的概念。</p><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>我们先了解原型对象的概念。</p><blockquote><p>每个对象都有原型对象（null除外），我们用<code>__proto__</code>表示，每个函数都有<code>prototype</code>属性，指向实例的原型对象。</p></blockquote><p>对照这句话，按照我们上面的例子，也就是说<code>Person.prototype</code>指向<code>person1</code>的原型对象(<code>__proto__</code>),<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype === person1.__proto__; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>为了便于理解，来看一张图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-f2e5ab0014367d09?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="71547797523_.pic.jpg" title="">                </div>                <div class="image-caption">71547797523_.pic.jpg</div>            </figure><p>恩~他们的关系大概就是这样。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型链简单用一句话概括就是：</p><blockquote><p>原型链就是 对象的<code>__proto__</code>所连接的链状结构</p></blockquote><p>为了方便我们理解原型链，举一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function F()&#123;</span><br><span class="line">    this.a = 1;</span><br><span class="line">    this.b = 2;</span><br><span class="line">&#125;</span><br><span class="line">F.prototype.b = 3;</span><br><span class="line">F.prototype.c = 4;</span><br><span class="line">var o = new F();// &#123;a: 1, b: 2&#125;</span><br><span class="line">//原型链：</span><br><span class="line">//o --&gt; o.__proto__ --&gt; o.__proto__.__proto__ --&gt; null</span><br><span class="line">// 其中的 --&gt; 就表示 __proto__ 也就是原型链</span><br><span class="line">console.log(o.a); // 1</span><br><span class="line">// o上有a这个属性吗？有的，该属性的值为1</span><br><span class="line"></span><br><span class="line">console.log(o.b); // 2</span><br><span class="line">// o上有b这个属性吗？有的，该属性的值为2</span><br><span class="line">// 原型上也有一个&apos;b&apos;属性,但是它不会被访问到.这种情况称为&quot;属性遮蔽 &quot;</span><br><span class="line"></span><br><span class="line">console.log(o.c); // 4</span><br><span class="line">// o上有c这个属性吗？没有，那看看原型上有没有</span><br><span class="line">// o.__proto__上有c这个属性吗？有的，该属性的值为4</span><br><span class="line"></span><br><span class="line">console.log(o.d); // undefined</span><br><span class="line">// o上有d这个属性吗？没有,那看看原型上有没有</span><br><span class="line">// o.__proto__ 上有d这个属性吗？没有，那看看它的原型上有没有</span><br><span class="line">// o.__proto__.__proto__ 为 null，停止搜索</span><br><span class="line">// 没有找到d属性，返回undefined。</span><br></pre></td></tr></table></figure></p><p>我们画张图来表示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-95ee1c64fb5b51e0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="91547800262_.pic_hd.jpg" title="">                </div>                <div class="image-caption">91547800262_.pic_hd.jpg</div>            </figure><p>图中这条红色的线就是原型链。<br>由此可见，<strong>实例对象可访问自己原型对象上的属性和方法</strong>，额..准确来说是:</p><ol><li>当一个对象 查找属性或方法时，自己有，停止查找，返回结果。</li><li>自己没有，顺着<code>__proto__</code>一直向上查找，如找到，停止查找，返回结果。</li><li>如果一直找到了原型链的最顶端(null)，还没有找到，返回<code>undefined</code>。</li></ol><p>我们先回顾一下那个<code>sayName</code>的问题：<br><strong>怎么让所有的实例对象都是用一个<code>sayName</code>方法呢</strong>。<br>现在我们可以使用原型对象来解决这个问题了。<br>我们把<code>sayName</code>方法放到实例的原型对象上面，也就是<code>Person.prototype</code>上面来供所有实例使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line"> &#125;</span><br><span class="line">Person.prototype.sayName=function ()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&apos;小明&apos;);</span><br><span class="line">var person2 = new Person(&apos;小红&apos;);</span><br><span class="line">person1.sayName === person2.sayName;//true</span><br></pre></td></tr></table></figure></p><p>用图表示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-f4d5c032a9b2b20f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="101547801223_.pic.jpg" title="">                </div>                <div class="image-caption">101547801223_.pic.jpg</div>            </figure></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong>constructor</strong><br>说一下我的经历，一开始理解原型链时，一直在<code>prototype</code>、<code>__proto__</code>、<code>constructor</code>在这个三个属性中绕来绕去。</p><p>为了便于理解，我把<code>constructor</code>放在最后了。<br><code>constructor</code>字面意思就很容易理解，构造函数的意思。<br>一句话解释:</p><blockquote><p>每个原型对象都有一个 constructor 属性指向 关联的构造函数。</p></blockquote><p>还是上面那个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Person.prototype.constructor);//Person()&#123; fun &#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的一点是，实例对象上没有<code>constructor</code>属性。<br>但是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(person1.constructor) ;//Person()&#123; fun &#125;</span><br></pre></td></tr></table></figure></p><p>得出这个结果很简单:<br>实例上查找不到<code>constructor</code>属性 –&gt; 顺着<code>__proto__</code>在原型对象上找 –&gt; 找到并返回。</p><p><strong>Object.prototype</strong><br>刚才我们说了创建对象的两种方式：字面量创建对象和使用<code>new</code>操作符创建对象。<br>这两种方式创建出来的对象都会继承<code>Object.prototyoe</code>上的方法。<br>比如，我们使用字面量新创建一个对象<code>o</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;value: 1&#125;;</span><br><span class="line">o.toString();//&quot;[object Object]&quot;</span><br><span class="line">//查找过程： o --&gt; o.__proto__ 找到返回</span><br><span class="line">o.__proto__ === Object.prototype;//true</span><br></pre></td></tr></table></figure></p><p><code>o</code>这个的对象本身并没有<code>toString</code>这个方法，但它却可以使用<code>toString</code>方法。<br>因为它继承了<code>Object.prototyoe</code>上的<code>toString</code>的方法。</p><p><strong>null</strong><br>既然对象都会继承自<code>Object.prototype</code>上面的方法，那它自己的原型又是什么呢。答案是<code>null</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.__prototype__ === null;//true</span><br></pre></td></tr></table></figure></p><p>以上仅自己学习所得，如有不当之处 望指出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直以来对于JavaScript 的原型链的概念，始终有些东西有一种模糊感，最近刚好有时间就塌下心认真的把《JavaScript高级程序设计》中相关内容认真读了一遍，也查看了很多网上很多资料，以前很多不明白的地方也渐渐明白了起来。&lt;br&gt;写一篇文章记录一下最近学习的感悟。&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用Express搭建一个简单的服务器</title>
    <link href="http://yoursite.com/2019/01/04/%E4%BD%BF%E7%94%A8Express%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2019/01/04/使用Express搭建一个简单的服务器/</id>
    <published>2019-01-04T14:21:55.000Z</published>
    <updated>2019-01-04T15:27:50.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Express框架"><a href="#Express框架" class="headerlink" title="Express框架"></a>Express框架</h2><h3 id="Web-应用程序"><a href="#Web-应用程序" class="headerlink" title="Web 应用程序"></a>Web 应用程序</h3><p>Express 是一个保持最小规模的灵活的 Node.js Web 应用程序开发框架，为 Web 和移动应用程序提供一组强大的功能。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>使用您所选择的各种 HTTP 实用工具和中间件，快速方便地创建强大的 API。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>Express 提供精简的基本 Web 应用程序功能，而不会隐藏您了解和青睐的 Node.js 功能。</p><h2 id="Express-路由基本使用"><a href="#Express-路由基本使用" class="headerlink" title="Express-路由基本使用"></a>Express-路由基本使用</h2><p>下载：<code>npm install express --save</code></p><h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><p>新建一个<code>server.js</code>文件，然后输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const app= express();</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res)=&gt;&#123;</span><br><span class="line">    req.send(&apos;Hello world&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(8083, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;Server is running at http://localhost:8083&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然后运行：<code>node server.js</code><br>打开：<a href="http://localhost:8083/" target="_blank" rel="noopener">http://localhost:8083/</a><br>就出现：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-b7ae26b3cdafc65a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11546413582_.pic.jpg" title="">                </div>                <div class="image-caption">11546413582_.pic.jpg</div>            </figure></p><h3 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h3><p>Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&apos;/&apos;, function (request, response) &#123;</span><br><span class="line">   // --</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>request 和 response 对象的具体介绍：</p><h3 id="Request-对象"><a href="#Request-对象" class="headerlink" title="Request 对象"></a>Request 对象</h3><blockquote><p>request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有：</p></blockquote><p>req.app：当callback为外部文件时，用req.app访问express的实例<br>req.baseUrl：获取路由当前安装的URL路径<br>req.body / req.cookies：获得「请求主体」/ Cookies<br>req.fresh / req.stale：判断请求是否还「新鲜」<br>req.hostname / req.ip：获取主机名和IP地址<br>req.originalUrl：获取原始请求URL<br>req.params：获取路由的parameters<br>req.path：获取请求路径<br>req.protocol：获取协议类型<br>req.query：获取URL的查询参数串<br>req.route：获取当前匹配的路由<br>req.subdomains：获取子域名<br>req.accepts()：检查可接受的请求的文档类型<br>req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages：返回指定字符集的第一个可接受字符编码<br>req.get()：获取指定的HTTP请求头<br>req.is()：判断请求头Content-Type的MIME类型</p><h3 id="Response-对象"><a href="#Response-对象" class="headerlink" title="Response 对象"></a>Response 对象</h3><blockquote><p>response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有：</p></blockquote><p>res.app：同req.app一样<br>res.append()：追加指定HTTP头<br>res.set()在res.append()后将重置之前设置的头<br>res.cookie(name，value [，option])：设置Cookie<br>opition: domain / expires / httpOnly / maxAge / path / secure / signed<br>res.clearCookie()：清除Cookie<br>res.download()：传送指定路径的文件<br>res.get()：返回指定的HTTP头<br>res.json()：传送JSON响应<br>res.jsonp()：传送JSONP响应<br>res.location()：只设置响应的Location HTTP头，不设置状态码或者close response<br>res.redirect()：设置响应的Location HTTP头，并且设置状态码302<br>res.render(view,[locals],callback)：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的页面，这样就不会自动输出了。<br>res.send()：传送HTTP响应<br>res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定Content-Type<br>res.set()：设置HTTP头，传入object可以一次设置多个头<br>res.status()：设置HTTP状态码<br>res.type()：设置Content-Type的MIME类型</p><h2 id="Express-路由"><a href="#Express-路由" class="headerlink" title="Express-路由"></a>Express-路由</h2><blockquote><p>我们已经了解了 HTTP 请求的基本应用，而路由决定了由谁(指定脚本)去响应客户端请求。<br>在HTTP请求中，我们可以通过路由提取出请求的URL以及GET/POST参数。</p></blockquote><p>路由的基本形式：<br><code>app.METHOD(PATH, HANDLER)</code></p><ol><li><code>app</code> 表示的是一个Express的实例</li><li><code>METHOD</code> 是http请求的方法（get, psot..）</li><li><code>PATH</code> 服务器上的路径</li><li><code>HANDLER</code>请求之后的执行函数</li></ol><p>下面的示例说明了如何定义路由：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 对/news 页面进行get请求</span><br><span class="line">app.get(&apos;news&apos;, (req, res)=&gt;&#123;</span><br><span class="line">    res.send(&apos;Hello news&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">// 对/about 页面进行post请求</span><br><span class="line">app.post(&apos;about&apos;, (req, res)=&gt;&#123;</span><br><span class="line">    res.send(&apos;Hello about&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">// 对/list* 可匹配 /list+任意字符</span><br><span class="line">app.get(&apos;/list*&apos;, (req, res)=&gt;&#123;</span><br><span class="line">    res.send(&apos;Hello list pages&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然后运行：<code>node server.js</code><br>打开：<a href="http://localhost:8083/" target="_blank" rel="noopener">http://localhost:8083/</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-b8692b839960c7cf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="21546417068_.pic.jpg" title="">                </div>                <div class="image-caption">21546417068_.pic.jpg</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-688f54ceb329ceb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="31546417103_.pic.jpg" title="">                </div>                <div class="image-caption">31546417103_.pic.jpg</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-e0af0827093b7ac1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="41546417120_.pic.jpg" title="">                </div>                <div class="image-caption">41546417120_.pic.jpg</div>            </figure></p><h2 id="Express-搭建静态资源库"><a href="#Express-搭建静态资源库" class="headerlink" title="Express-搭建静态资源库"></a>Express-搭建静态资源库</h2><blockquote><p>Express 提供了内置的中间件 express.static 来设置静态文件如：图片， CSS, JavaScript 等。</p></blockquote><p>你可以使用 express.static 中间件来设置静态文件路径。例如，如果你将图片， CSS, JavaScript 文件放在 public 目录下，你可以这么写：<br><code>app.use(express.static(&#39;public&#39;));</code></p><p>现在，你就可以访问 public 目录中的所有文件了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public/index.html</span><br><span class="line">public/images</span><br><span class="line">public/images/bg.jpeg</span><br><span class="line">public/css</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>如果要使用多个静态资源目录，请多次调用 express.static 中间件函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(&apos;public&apos;))</span><br><span class="line">app.use(express.static(&apos;files&apos;))</span><br></pre></td></tr></table></figure></p><p> Express 在静态目录查找文件，因此，存放静态文件的目录名不会出现在 URL 中。<br>但是您可以给静态目录添加一个路由：<br><code>app.use(&#39;/static&#39;, express.static(path.join(__dirname, &#39;public&#39;)))</code><br>设置<code>/static</code>为<code>/public</code>目录的路由。<br>现在，你就可以通过带有 /static 前缀地址来访问 public 目录中的文件了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8083/static/css</span><br><span class="line">http://localhost:8083/static/css/index.css</span><br><span class="line">http://localhost:8083/static/image</span><br><span class="line">http://localhost:8083/static/images/bg.jpeg</span><br><span class="line">http://localhost:8083/static/index.html</span><br></pre></td></tr></table></figure></p><p>为了安全，最好使用绝对路由：<br><code>app.use(&#39;/static&#39;, express.static(path.join(__dirname, &#39;public&#39;)))</code><br>然后运行：<code>node server.js</code><br>打开：<a href="http://localhost:8083/static" target="_blank" rel="noopener">http://localhost:8083/static</a><br>就可以访问public下的所有文件，如图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-8d727856b5ec84a3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="61546420083_.pic_hd.jpg" title="">                </div>                <div class="image-caption">61546420083_.pic_hd.jpg</div>            </figure></p><h2 id="Express-模板引擎之EJS"><a href="#Express-模板引擎之EJS" class="headerlink" title="Express-模板引擎之EJS"></a>Express-模板引擎之EJS</h2><blockquote><p>EJS 是一套简单的模板语言，帮你利用普通的 JavaScript 代码生成 HTML 页面。</p></blockquote><p>下载Ejs: <code>npm install ejs --save</code><br>同目录下新建<code>myejs.js</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const express= require(&apos;express&apos;);</span><br><span class="line">const app = express();</span><br><span class="line">//设置模板文件的目录,并且新建一个viwes的目录</span><br><span class="line">app.set(&apos;views&apos;, &apos;./views&apos;);</span><br><span class="line">//注册模板引擎</span><br><span class="line">app.set(&apos;view engine&apos;, &apos;ejs&apos;);</span><br><span class="line">//使用res.render()来渲染一个视图并将呈现的HTML字符串发送给客户端；</span><br><span class="line">app.get(&apos;/&apos;, function(req, res,) &#123;</span><br><span class="line">    res.render(&apos;index&apos;, &#123; title: &apos;测试&apos; &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">//监听8083端口</span><br><span class="line">app.listen(8083, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;Server is running at http://localhost:8083&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在新建views目录中新建index.ejs:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><p>然后运行：<code>node myejs.js</code><br>打开：<a href="http://localhost:8083" target="_blank" rel="noopener">http://localhost:8083</a><br>即可看到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-b333856ae590d4e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>当然，也可以返回一个json文件来渲染视图：<br>在同目录下新建一个data.json:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;list&quot;: [</span><br><span class="line">    &#123; &quot;name&quot;:&quot;小明&quot; , &quot;age&quot;:&quot;6&quot;, &quot;sex&quot;: &quot;男&quot;&#125;,</span><br><span class="line">    &#123; &quot;name&quot;:&quot;小红&quot; , &quot;age&quot;:&quot;4&quot; ,&quot;sex&quot;: &quot;女&quot;&#125;,</span><br><span class="line">    &#123; &quot;name&quot;:&quot;小亮&quot; , &quot;age&quot;:&quot;5&quot; ,&quot;sex&quot;: &quot;男&quot;&#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;source&quot;:&quot;神奇二班&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后更改myejs.js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const express= require(&apos;express&apos;);</span><br><span class="line">const fs= require(&apos;fs&apos;);</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">//设置模板文件的目录,并且新建一个viwes的目录</span><br><span class="line">app.set(&apos;views&apos;, &apos;./views&apos;);</span><br><span class="line">//注册模板引擎</span><br><span class="line">app.set(&apos;view engine&apos;, &apos;ejs&apos;);</span><br><span class="line">//使用res.render()来渲染一个视图并将呈现的HTML字符串发送给客户端；</span><br><span class="line">app.get(&apos;/&apos;, function(req, res,) &#123;</span><br><span class="line">    getDataJson((dataJson)=&gt;&#123;</span><br><span class="line">        console.log(dataJson);</span><br><span class="line">        res.render(&apos;index&apos;, dataJson);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">//访问data.json 拿到数据解析并返回</span><br><span class="line">const getDataJson=(callBack)=&gt;&#123;</span><br><span class="line">    fs.readFile(&apos;./data.json&apos;, (err, data)=&gt;&#123;</span><br><span class="line">        if(!err)&#123;</span><br><span class="line">            let jsonData= JSON.parse(data);</span><br><span class="line">            callBack(jsonData);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            throw err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//监听8083端口</span><br><span class="line">app.listen(8083, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;Server is running at http://localhost:8083&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然后更改index.ejs:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h4&gt;&lt;%=source %&gt;&lt;/h4&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;% for(var i=0; i&lt;list.length; i++)&#123; %&gt;</span><br><span class="line">        &lt;li&gt;&lt;%= list[i].name %&gt; | &lt;%= list[i].age %&gt; | &lt;%= list[i].sex %&gt;&lt;/li&gt;</span><br><span class="line">    &lt;% &#125; %&gt;    </span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>然后在运行：<br>然后运行：<code>node myejs.js</code><br>打开：<a href="http://localhost:8083/" target="_blank" rel="noopener">http://localhost:8083</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-62bf6f8073433d15.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>参考：<br><a href="https://github.com/AnsonZnl/StudyNodeJS/tree/master/demo/expressDemo" target="_blank" rel="noopener">GitHub源码</a><br><a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">Express官方文档</a><br><a href="https://ejs.bootcss.com/" target="_blank" rel="noopener">EJS 模板引擎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Express框架&quot;&gt;&lt;a href=&quot;#Express框架&quot; class=&quot;headerlink&quot; title=&quot;Express框架&quot;&gt;&lt;/a&gt;Express框架&lt;/h2&gt;&lt;h3 id=&quot;Web-应用程序&quot;&gt;&lt;a href=&quot;#Web-应用程序&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>使用NodeJS 搭建静态服务器</title>
    <link href="http://yoursite.com/2018/12/21/%E4%BD%BF%E7%94%A8Node.js%20%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2018/12/21/使用Node.js 搭建静态服务器/</id>
    <published>2018-12-21T08:21:55.000Z</published>
    <updated>2018-12-21T08:22:28.256Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们可以使用Node设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。</p></blockquote><p>解析URL需要用到Node.js提供的url模块，它使用起来非常简单，通过parse()将一个字符串解析为一个Url对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var url= require(&apos;url&apos;);</span><br><span class="line">console.log(url.parse(&apos;http://user:pass@host.com:8080/path/to/file?query=string#hash&apos;));</span><br></pre></td></tr></table></figure></p><p>解析之后是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Url &#123;</span><br><span class="line">    protocol: &apos;http:&apos;,</span><br><span class="line">    slashes: true,</span><br><span class="line">    auth: &apos;user:pass&apos;,</span><br><span class="line">    host: &apos;host.com:8080&apos;,</span><br><span class="line">    port: &apos;8080&apos;,</span><br><span class="line">    hostname: &apos;host.com&apos;,</span><br><span class="line">    hash: &apos;#hash&apos;,</span><br><span class="line">    search: &apos;?query=string&apos;,</span><br><span class="line">    query: &apos;query=string&apos;,</span><br><span class="line">    pathname: &apos;/path/to/file&apos;,</span><br><span class="line">    path: &apos;/path/to/file?query=string&apos;,</span><br><span class="line">    href:</span><br><span class="line">     &apos;http://user:pass@host.com:8080/path/to/file?query=string#hash&apos; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>处理本地文件目录需要使用Node.js提供的path模块，它可以方便地构造目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">// 解析当前目录:</span><br><span class="line">console.log(path(__dirname));</span><br><span class="line">//__dirname 表示当前所在目录  &apos;/Users&apos;</span><br><span class="line"></span><br><span class="line">// 组合完整的文件路径:当前目录+&apos;pub&apos;+&apos;index.html&apos;:</span><br><span class="line">var filePath = path.join(__dirname, &apos;fileServer&apos;, &apos;index.html&apos;);</span><br><span class="line">// &apos;/Users/fileServer/index.html&apos;</span><br></pre></td></tr></table></figure></p><p>使用path模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于<code>C:\Users\fileServer\index.html</code>，这样，我们就不关心怎么拼接路径了。</p><p>最后，我们实现一个文件服务器file_server.js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var </span><br><span class="line">    http= require(&apos;http&apos;),</span><br><span class="line">    fs= require(&apos;fs&apos;),</span><br><span class="line">    url= require(&apos;url&apos;),</span><br><span class="line">    path= require(&apos;path&apos;);</span><br><span class="line">    </span><br><span class="line">// 从命令行参数获取root目录，默认是当前目录:</span><br><span class="line">var root= path.join(__dirname, &apos;static&apos;, &apos;index.html&apos;);</span><br><span class="line"></span><br><span class="line">//创建服务器</span><br><span class="line">var server= http.createServer(function(request, response)&#123;</span><br><span class="line">    //获得ur的path 类似&apos;/css/index.css&apos;</span><br><span class="line">    var pathName= url.parse(request.url).pathname;</span><br><span class="line">    //获得对应的本地文件路径 类似’static/css/index.css‘</span><br><span class="line">    var filePath= path.join(root);</span><br><span class="line">    //获取文件状态</span><br><span class="line">    console.log(filePath);</span><br><span class="line">    fs.stat(filePath, function (err, stats) &#123;</span><br><span class="line">        if (!err &amp;&amp; stats.isFile()) &#123;</span><br><span class="line">            // 没有出错并且文件存在:</span><br><span class="line">            console.log(&apos;200 &apos; + request.url);</span><br><span class="line">            // 发送200响应:</span><br><span class="line">            response.writeHead(200);</span><br><span class="line">            // 将文件流导向response:</span><br><span class="line">            fs.createReadStream(filePath).pipe(response);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 出错了或者文件不存在:</span><br><span class="line">            console.log(&apos;404 &apos; + request.url);</span><br><span class="line">            // 发送404响应:</span><br><span class="line">            response.writeHead(404);</span><br><span class="line">            response.end(&apos;404 Not Found&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(8080);</span><br><span class="line">console.log(&apos;Server is running at http://127.0.0.1:8080/&apos;);</span><br></pre></td></tr></table></figure></p><p>当你的html文件是这样的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Road&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src=&quot;/images/bg.jpeg&quot; alt=&quot;11&quot;&gt;</span><br><span class="line">    &lt;h1&gt;书山有路勤为径,学海无涯苦做舟。&lt;/h1&gt;</span><br><span class="line">    &lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>然后请求<code>http://127.0.0.1:8080/index.html</code>就会打印出：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-5c918eec1e59e4ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="101544689152_.pic.jpg" title="">                </div>                <div class="image-caption">101544689152_.pic.jpg</div>            </figure></p><p>当然他只能发起请求，想要请求到并且正确返回还需要设置文件的ContentType属性。<br>我们可以使用<code>path.extname</code>获取请求文件的后缀：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let extname = path.extname(&apos;css/index.css&apos;);</span><br><span class="line">// .css</span><br></pre></td></tr></table></figure></p><p>我们获取到后缀之后就可以根据后缀来设置它的ContentType，这里需要用到一个mime.json文件，然后使用一个函数去匹配:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//mime 读取mime.json 里面存储了常见的文件的ContentType 为请求的对应的文件设置对应的 ContentType 属性</span><br><span class="line">function getContentType(extName, callBack)&#123;</span><br><span class="line">                //      文件后缀   回调函数</span><br><span class="line">    //读取mime.json</span><br><span class="line">    fs.readFile(&apos;./mime.json&apos;, (err, data)=&gt;&#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">        //读取失败 抛出错误</span><br><span class="line">            throw err;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 读取成功</span><br><span class="line">        let mimeJson = JSON.parse(data);</span><br><span class="line">        //转码 将json字符串转化成对象</span><br><span class="line">        let contentType = mimeJson[extName] || &apos;text/plain&apos;;</span><br><span class="line">        //取出对应json中 对应的 请求的后缀的相匹配的 ContentType 属性</span><br><span class="line">        callBack(contentType);</span><br><span class="line">        //执行这个回调函数 并传参contentType</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>搭建静态服务器的步骤应该是：</p><ol><li>先拿到请求文件的后缀名(extname)</li><li>引入mime.json 文件并读取-&gt;转码</li><li>匹配和后缀对应的ContentType</li><li>使用回调函数 所有请求的文件 都会拿到后缀 然后自动匹配相应的ContentType</li><li>执行getContentType函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getContentType(extname, (contentType)=&gt;&#123;</span><br><span class="line">    res.writeHead(200, &#123;&quot;Content-Type&quot;: contentType + &apos;;charset=UTF-8&apos;&#125;)</span><br><span class="line">    res.end(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/kuangshp128/article/details/75207984" target="_blank" rel="noopener">常见文件的mime类型</a><br><a href="https://github.com/AnsonZnl/StudyNodeJS/blob/master/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AF%BE%E6%97%B666-%E8%AF%BE%E6%97%B671%E7%AC%94%E8%AE%B0.md" target="_blank" rel="noopener">GitHub-Node 学习笔记</a><br><a href="https://www.cnblogs.com/xxchi/p/6382892.html" target="_blank" rel="noopener">参考-Node path模块相关方法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我们可以使用Node设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解析URL需要用到N
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>使用NodeJS写一个简单的api接口</title>
    <link href="http://yoursite.com/2018/12/15/%E4%BD%BF%E7%94%A8Node.js%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84api%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/12/15/使用Node.js写一个简单的api接口/</id>
    <published>2018-12-15T03:55:55.000Z</published>
    <updated>2018-12-21T08:22:22.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入Http模块"><a href="#引入Http模块" class="headerlink" title="引入Http模块"></a>引入Http模块</h2><p>默认你已经安装了<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a><br>Node当中内置了Http模块；<br>可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var http= require(&quot;http&quot;);</span><br></pre></td></tr></table></figure></p><p>引入http模块；</p><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p>用Node.js实现一个HTTP服务器程序非常简单。我们实现一个最简单的Web程序，<br>它对于所有请求，都返回Hello world!，新建一个文件夹<code>apiDemo</code> 在里面新建一个<code>server.js</code>写入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 导入http模块:</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">// 创建http server，并传入回调函数:</span><br><span class="line">var server = http.createServer(function (request, response) &#123;</span><br><span class="line">    // 回调函数接收request和response对象,</span><br><span class="line">    // 获得HTTP请求的method和url:</span><br><span class="line">    console.log(request.method + &apos;: &apos; + request.url);</span><br><span class="line">    // 将HTTP响应200写入response, 同时设置Content-Type: text/html:</span><br><span class="line">    response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/html&apos;&#125;);</span><br><span class="line">    // 将HTTP响应的HTML内容写入response:</span><br><span class="line">    response.end(&apos;Hello world!&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 让服务器监听8080端口:</span><br><span class="line">server.listen(8080);</span><br><span class="line"></span><br><span class="line">console.log(&apos;Server is running at http://127.0.0.1:8080/&apos;);</span><br></pre></td></tr></table></figure></p><p>然后在当前目录命令提示符下(cmd等)运行， 输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node server.js</span><br></pre></td></tr></table></figure></p><p>然后打开浏览器输入：<code>http://127.0.0.1:8080/</code> 就可以看到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2018/12/14/167abd49988fb8f2?w=310&h=193&f=jpeg&s=7500" alt="91544605447_.pic.jpg" title="">                </div>                <div class="image-caption">91544605447_.pic.jpg</div>            </figure></p><p>同时可以看到命令行中有打印的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET: /</span><br><span class="line">GET: /favicon.ico</span><br></pre></td></tr></table></figure></p><p>主要需要了解的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(function(request, response)&#123;&#125;)</span><br></pre></td></tr></table></figure></p><p>它的作用是创建一个http服务，里面传一个回调函数，函数中包含两个参数分别是（request，response）。<br>其中request是请求对象，response是响应对象。<br>可以根据<code>request</code>对象拿到请求头的一些信息，如: <code>request.url</code>–返回请求路径<br>响应成功后：<br><code>response.writeHead()</code>————发送一个响应头给请求<br><code>response.end(&#39;xxx&#39;)</code>————响应成功 返回xxx<br><a href="http://nodejs.cn/api/http.html" target="_blank" rel="noopener">参考 Nodez中文网-HTTP</a></p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>我们是想当访问<code>http://127.0.0.1:8080/</code>的时候返回当前目录的index.html。<br>也就是说当<code>request.url === &#39;/&#39;</code>是<code>true</code>时就可以确定当前请求的是根目录了，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var url = request.url;</span><br><span class="line">console.log(url);</span><br><span class="line">// &apos;/&apos;</span><br></pre></td></tr></table></figure></p><p>我们能创建一个服务，并且能使用<code>response.end(&#39;Hello world!&#39;);</code>返回“Hello world!”。如果想返回一个文件则需要用到Node.js的一个模块了——<strong>fs 文件系统</strong>。<br>它是Node当中处理文件的模块，首先引入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fs= require(&apos;fs&apos;);</span><br></pre></td></tr></table></figure></p><p>可以使用<code>fs.readFile()</code>来读取文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;./index.html&apos;, function(err, data)  &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(data);</span><br><span class="line">// &lt;Buffer 3c 21 44 4f 4...&gt;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>回调函数 有两个参数 (err, data)，其中 data 是文件的内容，以二进制形式返回。</p><p>然后我们就可以编写代码了，当访问根目录时，返回index.html文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var http= require(&apos;http&apos;);</span><br><span class="line">var fs= require(&apos;fs&apos;);</span><br><span class="line">var server= http.createServer(function(request, response)&#123;</span><br><span class="line">    var url = request.url;</span><br><span class="line">    if(url === &apos;/&apos;)&#123;</span><br><span class="line">        fs.readFile(&apos;./index.html&apos;, function(err, data)&#123;</span><br><span class="line">          if(!err)&#123;</span><br><span class="line">            response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/html;charset=UTF-8&quot;&#125;);</span><br><span class="line">            response.end(data)</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">              throw err;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(&quot;错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(8080, &apos;127.0.0.1&apos;);</span><br></pre></td></tr></table></figure></p><p>然后在当前目录下新建<code>index.html</code>，在这里我们可以写一个ajax请求，一会我们点击按钮来实现ajax请求一组数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;box&quot;&gt;看不到看不到&lt;/div&gt;</span><br><span class="line">   &lt;button onclick=&quot;success()&quot;&gt;我是按钮&lt;/button&gt;</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">   function success()&#123;</span><br><span class="line">       var http= new XMLHttpRequest();</span><br><span class="line">       http.onreadystatechange= function()&#123;</span><br><span class="line">           if(http.status == 200 &amp;&amp; http.readyState == 4)&#123;</span><br><span class="line">               var msg= http.responseText;</span><br><span class="line">               var box= document.getElementById(&apos;box&apos;);</span><br><span class="line">               box.innerHTML= JSON.parse(msg).name;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //发送请求</span><br><span class="line">       http.open(&apos;GET&apos;, &apos;/data&apos;);</span><br><span class="line">       http.send();</span><br><span class="line">   &#125;</span><br><span class="line">   &lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>这段代码是点击按钮的时候 会向<code>/data</code>发起一个ajsx请求,</p><h2 id="实现简单的API接口"><a href="#实现简单的API接口" class="headerlink" title="实现简单的API接口"></a>实现简单的API接口</h2><p>既然能访问根目录时可以返回html文件，那我们可以自己设定一个url，当请求这个url是我们就给它返回一组json数据。正常来讲这些数据应该是从数据库读取的，在这里只模拟一组json数据，在当前目录新建一个<code>data.json</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;: &quot;尼古拉丁 * 赵四&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>所以当前的目录结构是：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2018/12/14/167abd4998736425?w=402&h=170&f=jpeg&s=4634" alt="41544775041_.pic.jpg" title="">                </div>                <div class="image-caption">41544775041_.pic.jpg</div>            </figure></p><p>然后我们可以在server.js中判断一下，当请求的url是<code>/data</code>时，则返回data.json：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(url === &apos;/data&apos;)&#123;</span><br><span class="line">        fs.readFile(&apos;./data.json&apos;, function(err, data)&#123;</span><br><span class="line">            if(!err)&#123;</span><br><span class="line">                response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;application/json&quot;&#125;);</span><br><span class="line">                response.end(data);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                throw err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>然后打开浏览器 <code>http://127.0.0.1:8080</code> 后，就会出现index.html页面，点击出现的按钮就会触发一个对 <code>/data</code>的ajax请求，当server.js接受到请求后，就会判断<code>url === &#39;/data&#39;</code>，然后它就会吧  <code>data.json</code>返回给我们。</p><p>最后的实现是点击按钮出现<strong>尼古拉丁 * 赵四</strong>，<br>GItHub源码：<a href="https://github.com/AnsonZnl/StudyNodeJS/tree/master/%E8%AF%BE%E7%A8%8B%E8%AF%BE%E4%BB%B6%E5%8F%8A%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/apiDemo" target="_blank" rel="noopener">node-apiDemo</a><br>参考：<br><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345015296018cac40c198b543fead5c549865b9bd4a000" target="_blank" rel="noopener">廖雪峰-http详解</a><br><a href="http://nodejs.cn/api/fs.html" target="_blank" rel="noopener">Node-fs</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引入Http模块&quot;&gt;&lt;a href=&quot;#引入Http模块&quot; class=&quot;headerlink&quot; title=&quot;引入Http模块&quot;&gt;&lt;/a&gt;引入Http模块&lt;/h2&gt;&lt;p&gt;默认你已经安装了&lt;a href=&quot;https://nodejs.org/en/&quot; targe
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的预编译过程分析</title>
    <link href="http://yoursite.com/2018/12/11/JavaScript%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/11/JavaScript的预编译过程分析/</id>
    <published>2018-12-11T08:05:55.000Z</published>
    <updated>2018-12-11T08:43:37.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JavaScript概念"><a href="#一、JavaScript概念" class="headerlink" title="一、JavaScript概念"></a>一、JavaScript概念</h2><p>JavaScript ( JS ) 是一个单线程、解释型的编程语言。</p><h2 id="二、JavaScript语言特点"><a href="#二、JavaScript语言特点" class="headerlink" title="二、JavaScript语言特点"></a>二、JavaScript语言特点</h2><h3 id="2-1-单线程"><a href="#2-1-单线程" class="headerlink" title="2.1 单线程"></a>2.1 单线程</h3><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。</p><h3 id="2-2-解释型语言"><a href="#2-2-解释型语言" class="headerlink" title="2.2 解释型语言"></a>2.2 解释型语言</h3><p>自上而下，解释一行，执行一行；不会通篇编译为一个文件再执行。</p><h2 id="三、-JavaScript执行过程"><a href="#三、-JavaScript执行过程" class="headerlink" title="三、 JavaScript执行过程"></a>三、 JavaScript执行过程</h2><h3 id="3-1-语法分析"><a href="#3-1-语法分析" class="headerlink" title="3.1 语法分析"></a>3.1 语法分析</h3><p>  顾名思义 就是检查一遍js代码内有没有出现语法错误（比如少些个分号，多写个括号等）；语法分析期间不会执行代码</p><h3 id="3-2-预编译"><a href="#3-2-预编译" class="headerlink" title="3.2 预编译"></a>3.2 预编译</h3><p><strong>预编译发生在函数执行的前一刻</strong><br><strong>全局下：</strong><br>全局的变量声明和函数声明则会存放在全局对象内（Global Object 简称GO，它是window的一部分，你可以直接把他理解成window对象）中<br><strong>函数体内：</strong><br>预编译会提前把函数里的变量声明和函数声明依据规则存放在该活动对象内（Activation Object，简称AO），</p><p>预编译简单理解就是在内存中开辟一些空间，存放一些变量与函数 。</p><p>预编译大致可分为4步：</p><ol><li>创建AO(GO)对象</li><li>找形参和变量声明，将形参和变量名作为AO(GO)属性名，值为undefined</li><li>将实参值和形参统一</li><li>在函数体里面找函数声明，值赋予函数体。</li></ol><p>所以如果遇到下面这种情况，当函数声明和变量声明名称相同时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(a); </span><br><span class="line">var a= 1;</span><br><span class="line">function a()&#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>编译后的代码其实是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">function a()&#123;&#125;;</span><br><span class="line">console.log(a);</span><br><span class="line">a= 1;</span><br></pre></td></tr></table></figure></p><p>所以最后输出的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;&#125;</span><br></pre></td></tr></table></figure></p><h4 id="预编译小节"><a href="#预编译小节" class="headerlink" title="预编译小节"></a>预编译小节</h4><p><strong>预编译两个小规则</strong></p><ol><li>函数声明整体提升—(具体点说，无论函数调用和声明的位置是前是后，系统总会把函数声明移到调用前面） </li><li>变量 声明提升—(具体点说，无论变量调用和声明的位置是前是后，系统总会把声明移到调用前，注意仅仅只是声明，所以值是undefined），只有在解释执行阶段才会进行变量初始化，匿名函数不参与预编译。</li></ol><p><strong>预编译前奏</strong></p><ol><li>imply global 即任何变量，如果未经声明就赋值，则此变量就位全局变量所有(全局域就是window) 。</li><li>一切声明的全局变量，全是window的属性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var a=2; </span><br><span class="line">  console.log(window.a);//2</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-3-解释执行"><a href="#3-3-解释执行" class="headerlink" title="3.3 解释执行"></a>3.3 解释执行</h3><p>预编译完毕之后，JavaScript 脚本开始执行，执行顺序按照从上到下的顺序执行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>JavaScript执行顺序</strong></p><ol><li>语法分析</li><li>预编译<br>2.1. 创建AO(GO)对象<br>2.2. 找形参和变量声明，将形参和变量名作为AO(GO)属性名，值为undefined<br>2.3. 将实参值和形参统一<br>2.4. 在函数体里面找函数声明，值赋予函数体。  </li><li>解释执行</li></ol><p>练习：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function a(a)&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    a= 2;</span><br><span class="line">    console.log(b);</span><br><span class="line">    var b= 3;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">a(1);</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure></p><p>你可以先试想一下结果，然后复制代码到控制台去验证你的答案是否正确。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、JavaScript概念&quot;&gt;&lt;a href=&quot;#一、JavaScript概念&quot; class=&quot;headerlink&quot; title=&quot;一、JavaScript概念&quot;&gt;&lt;/a&gt;一、JavaScript概念&lt;/h2&gt;&lt;p&gt;JavaScript ( JS ) 是一个单
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>初试MongoDB学习之Mongoose的使用</title>
    <link href="http://yoursite.com/2018/11/23/MongoDB%E5%AD%A6%E4%B9%A0%E4%B9%8BMongoose%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/11/23/MongoDB学习之Mongoose的使用/</id>
    <published>2018-11-23T09:28:55.000Z</published>
    <updated>2018-12-21T08:20:27.716Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mongoose简介"><a href="#mongoose简介" class="headerlink" title="mongoose简介"></a>mongoose简介</h3><p>mongoose官网：<a href="https://mongoosejs.com/" target="_blank" rel="noopener">https://mongoosejs.com/</a></p><h4 id="为什么要用Mongoose"><a href="#为什么要用Mongoose" class="headerlink" title="为什么要用Mongoose"></a>为什么要用Mongoose</h4><blockquote><p>Mongoose就是一个让我们可以通过Node来操作MongoDB的一个模块。<br>Mongoose本质是一个对象文档模型（ODM）库，<br>他对Node原生的MongoDB模块进行了一部优化封装，并且提供了更多的功能。</p></blockquote><h4 id="Mongoose的优势"><a href="#Mongoose的优势" class="headerlink" title="Mongoose的优势"></a>Mongoose的优势</h4><ol><li>可以像操作对象一样操作数据库</li><li>可以为文档创建一个模式结构（Schema）</li><li>可以对模型中的文档/文档进行验证</li><li>数据可以通过类型转换为对象模型</li><li>可以使用中间件来应用业务逻辑挂钩</li><li>比Node原生的MongoDB驱动更容易</li></ol><h4 id="使用Mongoose"><a href="#使用Mongoose" class="headerlink" title="使用Mongoose"></a>使用Mongoose</h4><ol><li><p>下载安装mongoose模块<br><code>cnpm install mongoose --save</code></p></li><li><p>引用mongoose：<br><code>var mongoose =require(&quot;mongoose&quot;);</code></p></li><li>使用”mongoose”连接数据库：<br><code>var db =mongoose.connect(&quot;mongodb://user:pass@localhost:port/database&quot;);</code></li><li>执行下面代码检查默认数据库test，是否可以正常连接成功?<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var mongoose =require(&quot;mongoose&quot;);</span><br><span class="line">var db =mongoose.connect(&quot;mongodb://localhost/m_data&quot;);</span><br><span class="line">db.connection.on(&quot;error&quot;,function (error) &#123;</span><br><span class="line">   console.log(&quot;数据库连接失败：&quot; + error);</span><br><span class="line">&#125;);</span><br><span class="line">db.connection.on(&quot;open&quot;,function () &#123;</span><br><span class="line">   console.log(&quot;数据库连接成功！&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">db.connection.once(&apos;close&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;连接已经断开成功！&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="mongoose基本使用"><a href="#mongoose基本使用" class="headerlink" title="mongoose基本使用"></a>mongoose基本使用</h3><h4 id="mongoose的几个新的对象"><a href="#mongoose的几个新的对象" class="headerlink" title="mongoose的几个新的对象"></a>mongoose的几个新的对象</h4><p>在MongoDB中，多个Document可以组成Collection(以下简称集合)，多个集合又可以组成数据库。我们想要操作MongoDB数据，那就得先要具备上面所说的包含数据的“文档”，文档又是什么意思呢，请看如下介绍。</p><ol><li><strong>文档</strong> —— 是MongoDB的核心概念，是键值对的一个有序集，在JavaScript里文档被表示成对象。同时它也是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行，但更具表现力。</li><li><strong>集合</strong> —— 由一组文档组成，如果将MongoDB中的一个文档比喻成关系型数据库中的一行，那么一个集合就相当于一张表。</li><li><strong>Schema</strong>—— 一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅只是<strong>定义数据的类型</strong>，可以说是数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架。<br><strong>mongoose中任何任何事物都是从Schema开始的</strong>。每一个Schema对应MongoDB中的一个集合(collection)。Schema中定义了集合中文档(document)的样式。<h4 id="定义一个Schema（表-模式对象）"><a href="#定义一个Schema（表-模式对象）" class="headerlink" title="定义一个Schema（表/ 模式对象）"></a>定义一个Schema（表/ 模式对象）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//新建Schema 定义规则/字段的规则</span><br><span class="line">let Schema= mongoose.Schema;</span><br><span class="line">//定义personSchema的字段（规则）需要new一下 有点像构造函数的样子</span><br><span class="line">let personSchema= new Schema(&#123;</span><br><span class="line">    name: String,</span><br><span class="line">    sex: String,</span><br><span class="line">    age: Number</span><br><span class="line">&#125;);</span><br><span class="line">`</span><br></pre></td></tr></table></figure></li></ol><p><strong>基本属性类型有</strong>： </p><ul><li>String</li><li>Number</li><li>Date</li><li>Boolean</li><li>Buffer</li><li>ObjectId</li><li>Mixed</li><li>Array</li></ul><p><strong>Model</strong>—— 由Schema构造生成的模型，根据Schema定义的数据类型规则，可操作具体的符合改规则的数据。</p><h4 id="创建model（集合）"><a href="#创建model（集合）" class="headerlink" title="创建model（集合）"></a>创建model（集合）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let personModel= mongoose.model(&apos;person&apos;, personSchema);</span><br></pre></td></tr></table></figure><p>  person：数据库中的集合名称,当我们对其添加数据时如果person已经存在，则会保存到其目录下，如果未存在，则会创建person集合，然后在保存数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//4. 插入文档</span><br><span class="line">personModel.create(&#123;</span><br><span class="line">    name: &apos;张宁乐&apos;,</span><br><span class="line">    sex: &apos;男&apos;,</span><br><span class="line">    age: 18</span><br><span class="line">&#125;, (err)=&gt;&#123;</span><br><span class="line">   if(!err)&#123;</span><br><span class="line">       console.log(&apos;插入成功！&apos;)</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       throw err;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="mongoose-插入和查询"><a href="#mongoose-插入和查询" class="headerlink" title="mongoose 插入和查询"></a>mongoose 插入和查询</h3><p>mongoose查找数据的一些方法：<br><a href="https://mongoosejs.com/docs/api.html#model_Model.find" target="_blank" rel="noopener">https://mongoosejs.com/docs/api.html#model_Model.find</a></p><h4 id="插入多条数据"><a href="#插入多条数据" class="headerlink" title="插入多条数据"></a>插入多条数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">personModel.create([</span><br><span class="line">    &#123;name:&apos;张逗逗&apos;,age: 2,sex: &apos;男&apos;&#125;,</span><br><span class="line">    &#123;name:&apos;牛嘻嘻&apos;,age: 2,sex: &apos;女&apos;&#125;</span><br><span class="line">], (err)=&gt;&#123;</span><br><span class="line">   if(!err)&#123;</span><br><span class="line">       console.log(&apos;插入成功！&apos;)</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       throw err;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><ul><li>Model.find() <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">personModel.find(&#123;name: &apos;张宁乐&apos;&#125;, (err, data)=&gt;&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><ul><li>Model.find({}, callback) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">personModel.find(&#123;&#125;, (err, data)=&gt;&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>也可以选择查找数据的条件（0隐藏 1显示 id默认显示） 和MongoDB在命令行中的使用方法一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查询时只显示name </span><br><span class="line">personModel.find(&#123;&#125;, &#123;name: 1, _id: 0&#125;, (err,data)=&gt;&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在<code>find()</code>中  <code>skip</code>（查询开始的位置）和<code>limit</code>（增加的条数）也可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">personModel.find(&#123;&#125;, &#123;name: 1, _id: 0, age: 1&#125;, &#123;skip: 0, limit: 2&#125;, (err, data)=&gt;&#123;</span><br><span class="line">    //只显示name 和 age   从第1开始 每次查询2条 </span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>MongoDB的find()、findOne() 等命令在 mongoose里都可以使用</strong><br>具体可参考 ：<a href="https://mongoosejs.com/docs/api.html#model_Model.find" target="_blank" rel="noopener">https://mongoosejs.com/docs/api.html#model_Model.find</a></p><h3 id="mongoose-修改和删除"><a href="#mongoose-修改和删除" class="headerlink" title="mongoose 修改和删除"></a>mongoose 修改和删除</h3><p>参考： <a href="https://mongoosejs.com/docs/api.html#model_Model.update" target="_blank" rel="noopener">https://mongoosejs.com/docs/api.html#model_Model.update</a></p><h4 id="修改方法："><a href="#修改方法：" class="headerlink" title="修改方法："></a>修改方法：</h4><ul><li>Model.update()</li><li>Model.updateMany()</li><li>Model.updateOne()</li><li>Model.watch()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">personModel.update(&#123;name: &apos;张宁乐&apos;&#125;, &#123;$set: &#123;age: 20&#125;&#125;, (err, data)=&gt;&#123;</span><br><span class="line">   if(!err)&#123;</span><br><span class="line">       console.log(&apos;修改成功！&apos;)</span><br><span class="line">       console.log(data)</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       throw err;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-22be72d3058566fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4a9f49d480f66c5a64cb9a833459fdd.png" title="">                </div>                <div class="image-caption">4a9f49d480f66c5a64cb9a833459fdd.png</div>            </figure><h4 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h4><ul><li>Model.remove()</li><li>Model.deleteMany()</li><li>Model.deleteOne()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">personModel.remove(&#123;name:&apos;牛嘻嘻&apos;&#125;, (err)=&gt;&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(&apos;删除成功！&apos;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="统计文档条数"><a href="#统计文档条数" class="headerlink" title="统计文档条数"></a>统计文档条数</h4><ul><li>Model.count() <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">personModel.count(&#123;&#125;, (err,count)=&gt;&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(&apos;查询条数成功！ 一共：&apos; + count + &apos;条&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-25dcaed274322130.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2b7684dc310af51ac7fb50e5daa1123.png" title="">                </div>                <div class="image-caption">2b7684dc310af51ac7fb50e5daa1123.png</div>            </figure><h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p> Entity—— 由Model创建的实体，使用save方法保存数据，Model和Entity的操作都能影响数据库的操作，但Model比Entity更具操作性。<br>使用Model创建Entity，如下示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let mongoose= require(&apos;mongoose&apos;);</span><br><span class="line">let db= mongoose.connection(&apos;mongodb://localhost/m_data&apos;);</span><br><span class="line">db.on(&apos;open&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;连接成功！&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">let Schema= mongoose.Schema;</span><br><span class="line">let personSchema= new Schema(&#123;</span><br><span class="line">    name: String,</span><br><span class="line">    sex: String,</span><br><span class="line">    age: Number</span><br><span class="line">&#125;);</span><br><span class="line">let personModel= mongoose.model(&apos;person&apos;, personSchema);</span><br><span class="line">let personEntity = new personModel(&#123;</span><br><span class="line">    name: &apos;许巍&apos;,</span><br><span class="line">    sex: &apos;男&apos;,</span><br><span class="line">    age: 38</span><br><span class="line">&#125;)</span><br><span class="line">personEntity.save((err, person)=&gt;&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(&apos;保存成功！&apos;)</span><br><span class="line">        console.log(person);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(&apos;保存失败！&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-cef62c6a437fa126.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="c85c9b12f87f890e10e74f23555c802.png" title="">                </div>                <div class="image-caption">c85c9b12f87f890e10e74f23555c802.png</div>            </figure><p>参考：<a href="https://blog.csdn.net/swimming_in_IT_/article/details/80723866" target="_blank" rel="noopener">https://blog.csdn.net/swimming_in_IT_/article/details/80723866</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mongoose简介&quot;&gt;&lt;a href=&quot;#mongoose简介&quot; class=&quot;headerlink&quot; title=&quot;mongoose简介&quot;&gt;&lt;/a&gt;mongoose简介&lt;/h3&gt;&lt;p&gt;mongoose官网：&lt;a href=&quot;https://mongoosejs
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB中常用语句</title>
    <link href="http://yoursite.com/2018/11/17/MongoDB%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2018/11/17/MongoDB中常用语句/</id>
    <published>2018-11-17T14:23:20.000Z</published>
    <updated>2018-12-21T08:24:33.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MOngoDB-删除语句"><a href="#MOngoDB-删除语句" class="headerlink" title="MOngoDB  删除语句"></a>MOngoDB  删除语句</h3><p><strong>delete()删除</strong></p><ol><li>删除一个集合<br><code>db.collection.deleteOne()</code></li><li>删除多个集合<br><code>db.collection.deletMany();</code></li></ol><p><strong>remove()删除</strong></p><ol><li>删除所有的name：李四的数据<br><code>db.student.remove({name:&quot;李四&quot;});</code></li><li>只删除一条sex:男的数据 仅删除一条<br><code>db.student.remove({sex:&quot;男&quot;},true);</code></li><li>删除全部<br><code>db.student.remove({});</code></li></ol><h3 id="数据库假删除"><a href="#数据库假删除" class="headerlink" title="数据库假删除"></a>数据库假删除</h3><p>有时候用户删除操作的时候，需求是这样的，仅是隐藏这条数据，并不是真的从数据库中删除。<br>这时候就用到假删除了，<br>比如这个是张三发的两篇微博：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.student.insert([</span><br><span class="line">    &#123;name:&quot;张三&quot;,content:&quot;今天心情好&quot;,isDel:0&#125;,</span><br><span class="line">    &#123;name:&quot;张三&quot;,content:&quot;今天心情一般&quot;,isDel:0&#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-0cf6106c47156b0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="b21d2b7140562e21fcbe9c168e02da9.png" title="">                </div>                <div class="image-caption">b21d2b7140562e21fcbe9c168e02da9.png</div>            </figure><p>用户增加两条数据，但只保留后一条，删除前一条，这时候用到假删除 ，在添加数据时加上一个字段<code>isDel:0</code><br>所以当用户删除数据时候 执行的不是remove方法而是update方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.student.update(&#123;&quot;_id&quot; : ObjectId(&quot;5bd6a46f1eb7a22fa07cb382&quot;)&#125;,&#123;</span><br><span class="line">    $set:&#123;</span><br><span class="line">      isDel:1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-c1ca4b50a635972c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="98cf763807e662cd724e6d65f1638fb.png" title="">                </div>                <div class="image-caption">98cf763807e662cd724e6d65f1638fb.png</div>            </figure><p>当<code>isDel:0</code>是表示用户没有删除 为1是表示用户已经删除</p><p>所以在查询的时候要筛选name和isDel条件即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.student.find(&#123;name:&quot;张三&quot;,isDel:0&#125;);</span><br></pre></td></tr></table></figure></p><p>查询到用户没有删除的数据:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-a917d02348ba2b6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="121b7fc4d6f40af1de843359cdbf585.png" title="">                </div>                <div class="image-caption">121b7fc4d6f40af1de843359cdbf585.png</div>            </figure><p>然后就可以实现假删除了。</p><h3 id="批量数据的操作和修改"><a href="#批量数据的操作和修改" class="headerlink" title="批量数据的操作和修改"></a>批量数据的操作和修改</h3><ol><li><p>向集合中插入10000个文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr= [];</span><br><span class="line">for(var i=0;i&lt;10000;i++)&#123;</span><br><span class="line">   arr.push(&#123;counter:i&#125;);</span><br><span class="line">&#125;</span><br><span class="line">db.demos.insert(arr);</span><br><span class="line">db.demos.find();</span><br></pre></td></tr></table></figure></li><li><p>查询demos中counter为666的文档<br><code>db.demos.find({counter:666});</code></p></li><li>查询demos中counter小于66的文档<br><code>db.demos.find({counter:{$lt:666}});</code></li><li>查询demos中counter大T666的文档<br><code>db.demos.find({counter:{$gt:666}});</code></li><li>查询demos中counter大于66小于666的文档1120查吉demos集合中的前10余数据<br><code>db.demos.find({counter:{$gt:66, $lt:666}});</code></li><li>查石demos集合中的第1字到20条数据<br><code>db.demos.find().limit(10);</code></li><li>查春demos集合中的第2 1条到30条数据  分页功能   skip从多少条开始 limit每次查询多少条 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.demos.find().skip(0).limit(10);//第一页 从0条开始 每查询10条</span><br><span class="line">db.demos.find().skip(10).limit(10);//第二页 从10条开始 每查询10条</span><br><span class="line">db.demos.find().skip(20).limit(10);//第三页 从20条开始 每查询10条</span><br></pre></td></tr></table></figure></li></ol><h3 id="集合中文档关系"><a href="#集合中文档关系" class="headerlink" title="集合中文档关系"></a>集合中文档关系</h3><ol><li>一对一（noe to noe）:<br>比如：人和身份证   老公和老婆</li><li>一对多（noe to many）:<br>比如：父母和孩子  用户和物品</li><li>多对多（many to many）:<br>比如：老师和学生</li></ol><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>以内嵌文档的形式体现，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//一对一</span><br><span class="line">db.aAndb.insert([</span><br><span class="line"> &#123;name:&quot;杨过&quot;,wife:&#123;name:&quot;小龙女&quot;,sex:&quot;女&quot;&#125;,sex:&quot;男&quot;&#125;,</span><br><span class="line">  &#123;name:&quot;杨过&quot;,wife:&#123;name:&quot;小龙女&quot;,sex:&quot;女&quot;&#125;,sex:&quot;男&quot;&#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">db.aAndb.find();</span><br></pre></td></tr></table></figure></p><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>通过内嵌文档的形式实现或者通过集合的形式实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//一对多  比如  微博 和 微博评论</span><br><span class="line">//添加微博</span><br><span class="line">db.weibo.insert([</span><br><span class="line">&#123;weibo:&quot;世界这么大，我想去看看&quot;&#125;,</span><br><span class="line">&#123;weibo:&quot;我要做一名web开发者！！！&quot;&#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">db.weibo.find();</span><br></pre></td></tr></table></figure></p><p>添加评论<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">db.comments.insert([</span><br><span class="line">&#123;</span><br><span class="line">weibo_id: ObjectId(&quot;5bdd89e06a5e78f4cfc2b9c8&quot;),</span><br><span class="line">list:[</span><br><span class="line">   &quot;那你有钱吗&quot;,</span><br><span class="line">    &quot;一个人吗？？去呢啊？？&quot;,</span><br><span class="line">    &quot;加油！！&quot;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">weibo_id: ObjectId(&quot;5bdd89e06a5e78f4cfc2b9c9&quot;),</span><br><span class="line">list:[</span><br><span class="line">   &quot;那你要学习HTML&quot;,</span><br><span class="line">   &quot;那还要你要学习css&quot;,</span><br><span class="line">    &quot;加油！！&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">db.comments.find();</span><br></pre></td></tr></table></figure></p><p>查询一对多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var weibo_id= db.weibo.findOne(&#123;&quot;weibo&quot; : &quot;世界这么大，我想去看看&quot;&#125;)._id;</span><br><span class="line">db.comments.find(&#123;weibo_id: weibo_id&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="多对多的关系"><a href="#多对多的关系" class="headerlink" title="多对多的关系"></a>多对多的关系</h4><p>比如：学生和老师<br>可以通过多文档关联，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//多对多  老师《------》学生</span><br><span class="line"></span><br><span class="line">//插入老师集合</span><br><span class="line">db.teachers.insert([</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;语文老师&quot;,</span><br><span class="line">  teacher_id: 1,</span><br><span class="line">  student_id:[</span><br><span class="line">     1001,</span><br><span class="line">     1002,</span><br><span class="line">     1003</span><br><span class="line">  ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;数学老师&quot;,</span><br><span class="line">  teacher_id: 2,</span><br><span class="line">  student_id:[</span><br><span class="line">     1001,</span><br><span class="line">     1002,</span><br><span class="line">     1003</span><br><span class="line">  ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;英语老师&quot;,</span><br><span class="line">  teacher_id: 3,</span><br><span class="line">  student_id:[</span><br><span class="line">     1001,</span><br><span class="line">     1002,</span><br><span class="line">     1003</span><br><span class="line">  ]</span><br><span class="line"> &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">db.teachers.find();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//插入学生集合</span><br><span class="line">db.students.insert([</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;小明&quot;,</span><br><span class="line">  student_id: 1001,</span><br><span class="line">  teacher_id:[</span><br><span class="line">     1,</span><br><span class="line">     2,</span><br><span class="line">     3</span><br><span class="line">  ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;小红&quot;,</span><br><span class="line">  student_id: 1002,</span><br><span class="line">  teacher_id:[</span><br><span class="line">     1,</span><br><span class="line">     2,</span><br><span class="line">     3</span><br><span class="line">  ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;小刚&quot;,</span><br><span class="line">  student_id: 1003,</span><br><span class="line">  teacher_id:[</span><br><span class="line">     1,</span><br><span class="line">     2,</span><br><span class="line">     3</span><br><span class="line">  ]</span><br><span class="line"> &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">db.students.find();</span><br><span class="line">db.teachers.find();</span><br></pre></td></tr></table></figure></p><h3 id="排序和索引"><a href="#排序和索引" class="headerlink" title="排序和索引"></a>排序和索引</h3><h4 id="排序："><a href="#排序：" class="headerlink" title="排序："></a>排序：</h4><p>查询文档时，默认是按照_id的值进行排序的（升序）<br>sort() 可以用来指定文档的排序规则，sort() 内部需要传递一个对象来指定文档的排序规则 ，其中1表示升序 ，-1表示降序<br>limit skip sort 的顺序可以任意改变 ，运行时会自动调整。<br>不希望它默认按照id排序  希望它按照工资来排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//按照工资升序排列</span><br><span class="line"></span><br><span class="line">db.section.find().sort(&#123;wages:1&#125;);</span><br><span class="line"></span><br><span class="line">//优先按照工资升序排列  如果遇到相同的就在  按照id升序排列</span><br><span class="line">db.section.find().sort(&#123;wages: 1&#125;,&#123;_id: -1&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h4><p>展示字段中 部分内容<br>或者是提取这个字段内的部分内容<br>在查询时 ，可以在第二个参数来设置查询的结果投影</p><blockquote><p>索引： find({ 查询条件 }, { 检索范围（1显示 0隐藏）})<br>注意： <code>_id</code>如果不设置默认是1（显示） 可手动隐藏</p></blockquote><p><code>db.section.find({}, {name: 1});</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//只显示name和wages字段</span><br><span class="line">`db.section.find(&#123;&#125;, &#123;name: 1, _id: 0, wages: 1&#125;);`</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-1b481d1c9381e28f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a07a1f2945204ef671ddebc28871c00.png" title="">                </div>                <div class="image-caption">a07a1f2945204ef671ddebc28871c00.png</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MOngoDB-删除语句&quot;&gt;&lt;a href=&quot;#MOngoDB-删除语句&quot; class=&quot;headerlink&quot; title=&quot;MOngoDB  删除语句&quot;&gt;&lt;/a&gt;MOngoDB  删除语句&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;delete()删除&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>初试MongoDB数据库</title>
    <link href="http://yoursite.com/2018/11/15/%E5%88%9D%E8%AF%95MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/11/15/初试MongoDB数据库/</id>
    <published>2018-11-15T06:04:55.000Z</published>
    <updated>2018-12-21T08:21:38.380Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h3><p><strong>数据库（Database）基本概念：</strong></p><ol><li>数据库就是按照一定的数据结构来组织，储存和管理数据的仓库</li><li>我们写的程序都是在内存中运行的，一旦程序运行结束或者计算机断点，程序运行中的数据就会全部丢失；所以我们就需要将一些程序的数据持久化到键盘之中，以确保数据的安全性。</li><li>数据库则是大批量数据持久化的普遍选择，1.文件 2. 数据库  </li></ol><p><strong>为什么都采用数据库来储存数据:</strong></p><ul><li>数据库是有结构的</li><li>数据库可以提供各种接口，让数据处理（增删改查）快捷方便</li><li>各种语言（PHP jsp .net..）提供了完善的接口</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-d9cbd052415afbf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="b6dde1cf95ae2a9ec8e68c0bf1719a3.png" title="">                </div>                <div class="image-caption">b6dde1cf95ae2a9ec8e68c0bf1719a3.png</div>            </figure><p>###数据库分类</p><ol><li>ROBMS（关系型数据库）：<ul><li>比如MySql 、sql server Oracle 等</li><li>特点 通过一张张表来建立关联</li><li>基本都使用SQL语言来管理数据库，</li></ul></li><li>Nosql (非关系型数据库)：<ul><li>没有行 、列的概念 用json类储存数据</li><li>集合相当于“表”，文档相当于“行”</li><li>标准化和非标准化的摩擦。</li><li>标准化限制创新，非标准话不能统一</li></ul></li></ol><p><strong>特征</strong>：<br> 使用键值（Key Value）储存数据；<br>MongoDB的逻辑结构是一种层次结构，主要由：文档(document)、集合(collection)、数据库(database)这三部分组成的。 </p><ul><li>文档(document)：由键/值对构成，像{a:1}；{s:”abc”}等，它是MongoDB核心单元，MongoDB的文档（document），相当于关系数据库中的一行记录。 </li><li>集合（Collection）：多个文档组成一个集合（collection），相当于关系数据库的表。 </li><li>数据库（database）：多个集合（collection），逻辑上组织在一起，就是数据库（database）。<br>一个MongoDB实例支持多个数据库（database）。</li></ul><p><strong>关系型数据库和非关系型数据库区别：</strong><br>关系型数据库比较结构化，操作不是很灵活，菲关系型数据库操作灵活，但不适合大型数据存储，比较适合微架构，两者是相辅相成的关系<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-db349e8b6512241e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8bc32dd95a923344fdc2710d2fcbeab.png" title="">                </div>                <div class="image-caption">8bc32dd95a923344fdc2710d2fcbeab.png</div>            </figure></p><p><strong>非关系型数据库使用方面：</strong></p><ol><li>数据模型比较简单</li><li>需要灵活性更强的后台系统</li><li>对数据库性能要求比较高</li><li>不需要高度的数据一致性</li></ol><p><strong>非关系型数据库主要适合小微型架构的使用</strong></p><h3 id="数据库MongoDB安装"><a href="#数据库MongoDB安装" class="headerlink" title="数据库MongoDB安装"></a>数据库MongoDB安装</h3><p>MongoDB（非关系型数据库）：</p><ol><li>适合快速开发web应用而设计的数据库系统</li><li>设计目标是极简、灵活、经常在web应用栈的业务层被运用</li><li>它的数据模型是面向文档的，类似于json的结构</li><li>所以这个数据库中是各种各样的json, 并以键值形式对存储</li></ol><p>安装：<br>下载:<a href="https://www.mongodb.com/" target="_blank" rel="noopener">https://www.mongodb.com/</a><br>偶数是稳定版，奇数是开发版<br>最好下载64位的系统版本的</p><p><strong>配置环境变量:</strong></p><ol><li>新建—&gt;安装到bin路径复制到环境变量</li><li>创建data-&gt;db文件夹</li><li>打开命令行输入mongod启动DB服务器</li><li>指定端口号和路径 mongod –dbpath d:\data\db</li><li>将MongDB设置为系统服务，data\log<br>创建配置文件在bin下穿件文件mongod.cfg<br>执行一段命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.exe create MongoDB binPath= &quot;\&quot;F:\MongoDB\Server\3.2\bin\mongod.exe\&quot; --service --config= \&quot;F:\MongoDB\Server\3.2\mongod.cfg\&quot;&quot; DisplayName= &quot;MongoDB&quot; start= &quot;auto&quot;</span><br></pre></td></tr></table></figure></li></ol><p>主要是让MongoDB一直运行在内存中<br>参考资料：<br><a href="https://www.cnblogs.com/wzlblog/p/6364045.html" target="_blank" rel="noopener">https://www.cnblogs.com/wzlblog/p/6364045.html</a><br><a href="https://www.cnblogs.com/chenlq/p/6515876.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenlq/p/6515876.html</a></p><h3 id="在命令行中使用MongoDB插入命令"><a href="#在命令行中使用MongoDB插入命令" class="headerlink" title="在命令行中使用MongoDB插入命令"></a>在命令行中使用MongoDB插入命令</h3><p><strong>MongoDB的组成：</strong></p><ul><li>数据库 数据库是一个仓库 在仓库里可以放集合</li><li>集合： 集合类似数组 在集合里可以放文档</li><li>文档：文档是数据库中最小的单位 我们储存和操作的内容都是文档。</li></ul><p><strong>基本指令：</strong><br><code>show dbs</code>  显示当前所有的数据库<br><code>use</code> 数据库名  进入到指定数据库<br><code>db</code> 显示当前所在的数据库<br><code>show collections</code> 显示数据库中的所有集合</p><p>使用管理员打开 cmd<br>输入 <code>mongo</code>进入MongoDB的环境<br>进入MongoDB的环境才能执行MongoDB的命令<br>然后使用命令行进行CRUD(增删改查)：<br><code>db.&lt;collection&gt;.insert(doc)</code></p><p><strong>举例子：</strong><br>想school数据库中的学生集合student中插入一个新的学生对象<br>增加一条数据：<br><code>db.student.insert({id:&quot;001&quot;,name:&quot;znl&quot;,age:18,sex:“男”})</code><br>在当前的集合（school）中新建一条数据</p><p>查询一条数据：<br><code>db.&lt;collection&gt;.find();</code></p><p>如：<code>db.student.find();</code><br>回车 就能查询student下的所有数据<br>插入多条数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.集合名.insert([</span><br><span class="line">    &#123;name:&quot;张三&quot;,age:18,sex:&quot;man&quot;&#125;,</span><br><span class="line">    &#123;name:&quot;张三&quot;,age:18,sex:&quot;man&quot;&#125;,</span><br><span class="line">    &#123;name:&quot;张三&quot;,age:18,sex:&quot;man&quot;&#125;,</span><br><span class="line">    &#123;id:18，name:&quot;张三&quot;,age:18,sex:&quot;man&quot;&#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p><blockquote><p>插入多条数据时把多条语句放在一个数组里<br>插入可随便插入 不必拘泥于字段是否相同 当插入的字段不存在时会自动创建该字段</p></blockquote><p>查看更多更多操作：<a href="http://www.mongodb.org.cn/manual/" target="_blank" rel="noopener">http://www.mongodb.org.cn/manual/</a></p><h3 id="MongoDB-可视化工具-【NOSQL】"><a href="#MongoDB-可视化工具-【NOSQL】" class="headerlink" title="MongoDB 可视化工具 【NOSQL】"></a>MongoDB 可视化工具 【NOSQL】</h3><p>然而一直使用命令行操作是很麻烦的事情，所以推荐使用NOSQL可视化工具<br>安装可视化工具下载地址：<a href="https://www.mongodbmanager.com/download" target="_blank" rel="noopener">https://www.mongodbmanager.com/download</a></p><h3 id="使用可视化工具"><a href="#使用可视化工具" class="headerlink" title="使用可视化工具"></a>使用可视化工具</h3><p>可视化工具 查找功能：<br>插入(insert)语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.student(集合名字).insert([</span><br><span class="line">&#123;id:1,name:&quot;znl&quot;,age:18&#125;,</span><br><span class="line">&#123;id:1,name:&quot;znl&quot;,age:18&#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p><p>查询语句：<br><code>db.student(集合name).find();</code></p><p>设定条件查询：<br><code>db.student.find({ &quot;_id&quot; : ObjectId(&quot;5bd01c825f0d528d36a2c06f&quot;)});</code><br>查询id对应的数据<br><code>db.student.find({age:18,name:&quot;张三&quot;});</code><br>查询所有的age是18并且name是张三的人<br><code>db.student.findOne({age:18,name:&quot;张三&quot;});</code><br>查询单条符合条件的数据</p><p>操作符-查询有多少条数据：<br><code>db.student.find().count();</code><br>或<br><code>db.student.find().length();</code><br>返回数据总条数</p><p>查询符合条件数据的条数：<br><code>db.student.find({name:&quot;张三&quot;}).length();</code><br>返回符合name:”张三”的条数</p><h3 id="数据库更新命令"><a href="#数据库更新命令" class="headerlink" title="数据库更新命令"></a>数据库更新命令</h3><p>更新原有的字段的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;张三&quot;&#125;,&#123;$set:&#123;</span><br><span class="line">      name:&quot;刘五&quot;,</span><br><span class="line">      age:45</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure></p><p>把匹配到的<code>name:&quot;张三&quot;</code>的数据都更新成 <code>name:&quot;刘五&quot;, age:45</code><br>也可以新增没有的字段 直接写入就可以<br><strong>$set ：有这个字段就修改 没有这个字段就新增</strong></p><p>删除一个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;张三&quot;&#125;，&#123;$unset:&#123;</span><br><span class="line">    age:1</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure></p><p>查询<code>name:张三</code>的一条数据 然后删除它的age字段</p><p>修改多条：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.student.updateMany(&#123;&quot;sex&quot;:&quot;man&quot;&#125;,&#123;$set:&#123;</span><br><span class="line">    aihao:&quot;玩游戏&quot;</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure></p><p>把符合<code>sex:man</code>的语句都新增（修改）一条<code>aihao:&quot;玩游戏&quot;</code><br><strong>$set ：有则修改 无则新增</strong></p><p>更新多条数据方法2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.student.update(&#123;name:&quot;张三&quot;&#125;,&#123;$set:&#123;</span><br><span class="line">      name:&quot;王五&quot;</span><br><span class="line">&#125;&#125;, &#123;</span><br><span class="line">     multi:true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>参考文档：<a href="https://docs.mongodb.com/manual/tutorial/query-documents/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/query-documents/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据库基本概念&quot;&gt;&lt;a href=&quot;#数据库基本概念&quot; class=&quot;headerlink&quot; title=&quot;数据库基本概念&quot;&gt;&lt;/a&gt;数据库基本概念&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;数据库（Database）基本概念：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS文件系统（fs）与流（stream）</title>
    <link href="http://yoursite.com/2018/11/08/NodeJs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88fs%EF%BC%89%E4%B8%8E%E6%B5%81%EF%BC%88stream%EF%BC%89/"/>
    <id>http://yoursite.com/2018/11/08/NodeJs文件系统（fs）与流（stream）/</id>
    <published>2018-11-08T06:04:55.000Z</published>
    <updated>2018-12-21T08:22:45.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件系统（File-System）："><a href="#文件系统（File-System）：" class="headerlink" title="文件系统（File System）："></a><strong>文件系统（File System）：</strong></h2><ol><li>在Node中，文件系统的交互是非常重要的，服务器的本质就是将本地的文件发送给客户端，</li><li>Node通过fs模块来和文件系统进行交互，该模块提供了一些标准的文件访问API类打开、读取、写入文件、以及与其交互。</li><li>要是用fs模块，首先要从核心模块中加载； 使用 const fs= require(‘fs’) ; 来引入</li></ol><h3 id="fs使用特点："><a href="#fs使用特点：" class="headerlink" title="fs使用特点："></a>fs使用特点：</h3><ol><li>fs模块中的所有操作都有两种形式可供选择同步和异步，</li><li>同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。</li><li>异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//1\. 引入模块</span><br><span class="line">const fs= require(&quot;fs&quot;);</span><br><span class="line">// console.log(fs)</span><br><span class="line"></span><br><span class="line">//2\. 打开文件</span><br><span class="line">// fs.open 异步读取（通常用异步 需设置回调函数）  </span><br><span class="line">// fs.openSync 同步读取（读取时会阻塞线程）</span><br><span class="line"></span><br><span class="line">let hello = fs.openSync(&quot;hello.txt&quot;, &quot;w&quot;);</span><br><span class="line">//                     不存在会自动新建</span><br><span class="line"></span><br><span class="line">//3\. 写入内容</span><br><span class="line">fs.writeFileSync(hello,&apos;hello word!&apos;);</span><br><span class="line"></span><br><span class="line">//4\. 保存并退出</span><br><span class="line">fs.closeSync(hello);</span><br></pre></td></tr></table></figure><p> <a href="https://github.com/AnsonZnl/StudyNodeJS/blob/master/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AF%BE%E6%97%B630-%E8%AF%BE%E6%97%B634%E7%AC%94%E8%AE%B0.md#%E8%AF%BE%E6%97%B631" target="_blank" rel="noopener"></a></p><h3 id="文件操作："><a href="#文件操作：" class="headerlink" title="文件操作："></a>文件操作：</h3><ol><li>打开文件：<br><code>fs.open(path,flags[,mode],callback)</code><br>异步打开 异步都是回调 回调嵌套回调<br><code>fs.openSync(path,flags[,mode])</code><br>同步打开 </li></ol><p>文件标记（flags）： <a href="http://nodejs.cn/api/fs.html#fs_fs_open_path_flags_mode_callback" target="_blank" rel="noopener">http://nodejs.cn/api/fs.html#fs_fs_open_path_flags_mode_callback</a></p><p>一、同步打开文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//1\. 引入模块 </span><br><span class="line">let fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//2.打开文件 同步</span><br><span class="line">var fd=fs.openSync(&apos;1.txt&apos;, &apos;w&apos;);</span><br><span class="line"></span><br><span class="line">//3.写入内容</span><br><span class="line">fs.writeFileSync(fd,&quot;hello world!&quot;); </span><br><span class="line"></span><br><span class="line">//4\. 保存并关闭</span><br><span class="line">fs.closeSync(fd);</span><br></pre></td></tr></table></figure></p><p> 二、异步打开文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//1.引入模块</span><br><span class="line">let fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//2\. 打开文件</span><br><span class="line">fs.open(&apos;1.txt&apos;, &apos;a&apos;, (err, fd)=&gt;&#123;</span><br><span class="line">    //2.1判断是否出错</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        //正确 2.2写入文件</span><br><span class="line">        fs.writeFile(fd, &quot;今天天.....气真好！&quot;, (err)=&gt;&#123;</span><br><span class="line">             //2.2.1 写入成功</span><br><span class="line">             if(!err)&#123;</span><br><span class="line">                 console.log(&apos;写入成功&apos;);</span><br><span class="line">             &#125;else&#123;</span><br><span class="line">                 throw err;</span><br><span class="line">             &#125;</span><br><span class="line">             //2.3 关闭文件</span><br><span class="line">             fs.close(fd, (err)=&gt;&#123;</span><br><span class="line">                 if(!err)&#123;</span><br><span class="line">                     console.log(&apos;文件以保存并关闭&apos;)</span><br><span class="line">                 &#125;else&#123;</span><br><span class="line">                     throw err;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/AnsonZnl/StudyNodeJS/blob/master/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AF%BE%E6%97%B630-%E8%AF%BE%E6%97%B634%E7%AC%94%E8%AE%B0.md#%E8%AF%BE%E6%97%B632" target="_blank" rel="noopener"></a></p><h3 id="使用文件流写入"><a href="#使用文件流写入" class="headerlink" title="使用文件流写入"></a>使用文件流写入</h3><p>文件流写入： <a href="http://nodejs.cn/api/fs.html#fs_fs_createwritestream_path_options" target="_blank" rel="noopener">http://nodejs.cn/api/fs.html#fs_fs_createwritestream_path_options</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//同步操作</span><br><span class="line"></span><br><span class="line">//1\. 引入模块</span><br><span class="line">let fs= require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//2.建立通道</span><br><span class="line">let ws = fs.createWriteStream(&apos;fsw.txt&apos;)</span><br><span class="line"></span><br><span class="line">//3.打开通道</span><br><span class="line">ws.once(&apos;open&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;通道已经打开&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&apos;close&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;通道已经关闭&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//4\. 写入内容</span><br><span class="line">ws.write(&apos;我爱你，&apos;);</span><br><span class="line">ws.write(&apos;我爱你，&apos;);</span><br><span class="line">ws.write(&apos;我爱你，&apos;);</span><br></pre></td></tr></table></figure><p> <a href="https://github.com/AnsonZnl/StudyNodeJS/blob/master/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AF%BE%E6%97%B630-%E8%AF%BE%E6%97%B634%E7%AC%94%E8%AE%B0.md#%E8%AF%BE%E6%97%B633" target="_blank" rel="noopener"></a></p><h3 id="读写文件："><a href="#读写文件：" class="headerlink" title="读写文件："></a>读写文件：</h3><p>文档地址：<a href="http://nodejs.cn/api/fs.html#fs_fs_readfile_path_options_callback" target="_blank" rel="noopener">http://nodejs.cn/api/fs.html#fs_fs_readfile_path_options_callback</a><br>读取文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//1\. 引入模块</span><br><span class="line">let fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//2\. 读取文件</span><br><span class="line">fs.readFile(&apos;source/hello.txt&apos;,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">    //判断是否成功</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(data);//</span><br><span class="line">        // console.log(data.toString());</span><br><span class="line">        //data 默认读取的是二进制 使用toString() 方法转换成</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">读取图片：</span><br><span class="line"></span><br><span class="line">//3\. 读取图片</span><br><span class="line">fs.readFile(&quot;source/psb.jpg&quot;,(err,data)=&gt;&#123;</span><br><span class="line">    //判断是否成功</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        //写入图片</span><br><span class="line">        fs.writeFile(&apos;img.jpg&apos;, data, (err)=&gt;&#123;</span><br><span class="line">            if(!err)&#123;</span><br><span class="line">                console.log(&apos;写入成功！&apos;)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                throw err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/AnsonZnl/StudyNodeJS/blob/master/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AF%BE%E6%97%B630-%E8%AF%BE%E6%97%B634%E7%AC%94%E8%AE%B0.md#%E8%AF%BE%E6%97%B634" target="_blank" rel="noopener"></a></p><p><strong>读取视频:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//1\. 引入模块</span><br><span class="line">let fs= require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//2\. 读取视频</span><br><span class="line">fs.readFile(&apos;source/cddbb.mp4&apos;, (err, data)=&gt;&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        // 写入视频</span><br><span class="line">        fs.writeFile(&apos;nmx.mp4&apos;, data, (err)=&gt;&#123;</span><br><span class="line">            if(!err)&#123;</span><br><span class="line">                console.log(&apos;写入成功！&apos;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                throw err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//3\. 流式文件的读入（批量文件处理）</span><br><span class="line">let re= fs.createReadStream(&apos;source/cddbb.mp4&apos;);</span><br><span class="line">//建立读取流</span><br><span class="line">let ws= fs.createWriteStream(&apos;新建的视频.mp4&apos;);</span><br><span class="line">//建立写入流</span><br><span class="line"></span><br><span class="line">//4\. 创建管道</span><br><span class="line">re.pipe(ws);//文件流传输</span><br><span class="line">console.log(&apos;文件流传输完成&apos;)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.jb51.net/article/133553.htm" target="_blank" rel="noopener">详解NodeJS文件系统fs</a><br>我的GitHub总结的<a href="https://github.com/AnsonZnl/StudyNodeJS" target="_blank" rel="noopener">NodeJS笔记</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文件系统（File-System）：&quot;&gt;&lt;a href=&quot;#文件系统（File-System）：&quot; class=&quot;headerlink&quot; title=&quot;文件系统（File System）：&quot;&gt;&lt;/a&gt;&lt;strong&gt;文件系统（File System）：&lt;/stro
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS中的Buffer</title>
    <link href="http://yoursite.com/2018/11/05/Node%E4%B8%AD%E7%9A%84Buffer/"/>
    <id>http://yoursite.com/2018/11/05/Node中的Buffer/</id>
    <published>2018-11-05T06:04:55.000Z</published>
    <updated>2018-12-21T08:22:49.824Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Buffer介绍"><a href="#Buffer介绍" class="headerlink" title="Buffer介绍"></a>Buffer介绍</h3><p><strong>为什么要用Buffer？</strong></p><ol><li>在Node/ES6 出现之前，前端工程师只需要进行一些简单的额字符串或者ODM操作就可以满足业务需求了，所有对二进制数据比较陌生。</li><li>在node出现之后，前端工程师面对的技术场景发送了变化，可以深入到网络传输、文件操作、图片处理等领域。而这些操作与二进制数据紧密相关。</li><li>在Node中的Buffer，是一个二进制数据容器，数据结构和数组类似，专门用于Node中的数据放。</li></ol><h3 id="新建Buffer"><a href="#新建Buffer" class="headerlink" title="新建Buffer"></a>新建Buffer</h3><p><code>Buffer.alloc(size[, fil[,encoding]])</code><br><code>size</code>:新建的buffer期望的长度<br><code>fill</code>用来预填充新建的Buffer的值 默认0<br><code>encoding</code>: 编码格式  默认：utf-8<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">        十六进制：00- ff</span><br><span class="line">        十进制 ：0- 255</span><br><span class="line">        二进制： 00000000- 11111111</span><br><span class="line">        0 / 1 代表一位 == 比特 </span><br><span class="line">        8bit = 1B</span><br><span class="line">        1kb = 1024 B</span><br><span class="line">        1mkb= 1024Kb</span><br><span class="line">        1GB = 1024m</span><br><span class="line">        1TB = 1024GB</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 2. Buffer.alloc(size[, fill[, encoding]])</span><br><span class="line">/*</span><br><span class="line">类数组使用即可 可遍历 可选择下标等等</span><br><span class="line">初始化： 确定的长度 不能改变</span><br><span class="line">填充值</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">let buffer2= Buffer.alloc(10);//创建了一个长度是10的buffer</span><br><span class="line">buffer2[0]= 10;//可以像使用数组一样使用buffer </span><br><span class="line">buffer2[1]= oxfc;//传一个十六进制的直接取后两位 fc</span><br><span class="line">buffer2[30]= 1;//这点和数组不同 溢出隐藏 </span><br><span class="line">console.log(buffer2);</span><br></pre></td></tr></table></figure></p><h3 id="Buffer使用"><a href="#Buffer使用" class="headerlink" title="Buffer使用"></a>Buffer使用</h3><p><strong>使用新方法使用Buffer </strong></p><ol><li>Buffer.form(str):将一个字符串转换成buffer</li><li>Buffer.alloc(size):创建一个指定大小的buffer</li><li>Buffer.alloUnsafe(size):创建一个指定大小的buffer，但是可能包含敏感数据。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 历史方法</span><br><span class="line">// let buffer = new Buffer(10);//类似 Array(10) 创建十个空间</span><br><span class="line">// console.log(buffer)// &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span><br><span class="line"></span><br><span class="line">//1. 字符串转成二进制</span><br><span class="line">let str= &apos;www.zhangningle.top&apos;;</span><br><span class="line">let buffer= Buffer.from(str);</span><br><span class="line">console.log(buffer);//&lt;Buffer 77 77 77 2e 7a 68 61 6e 67 6e 69 6e 67 6c 65 2e 74 6f 70&gt;</span><br><span class="line">//把buffer转成十进制的</span><br><span class="line">console.log(buffer.toString())//www.zhangningle.top</span><br><span class="line">// 汉字转换成二进制后 一个汉字要用三个字节表示</span><br></pre></td></tr></table></figure></li></ol><p><strong>Buffer总结点：</strong></p><ol><li>Buffer的结构和数组很像，操作方法也和数组很类似。</li><li>Buffer中是以二进制的方式储存数据的</li><li>Buffer是Node自带的，不需要引入，直接可以使用。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Buffer介绍&quot;&gt;&lt;a href=&quot;#Buffer介绍&quot; class=&quot;headerlink&quot; title=&quot;Buffer介绍&quot;&gt;&lt;/a&gt;Buffer介绍&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;为什么要用Buffer？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在No
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS中的CommonJS规范</title>
    <link href="http://yoursite.com/2018/10/18/CommonJS%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/10/18/CommonJS模块化开发/</id>
    <published>2018-10-18T06:04:55.000Z</published>
    <updated>2018-12-21T08:24:19.287Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模块化的意义"><a href="#模块化的意义" class="headerlink" title="模块化的意义"></a>模块化的意义</h3><blockquote><p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。<br>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Node环境中，一个.js文件就称之为一个模块（module）。</p></blockquote><h3 id="理解模块化"><a href="#理解模块化" class="headerlink" title="理解模块化"></a>理解模块化</h3><p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。<br>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</p><p><strong>每一个文件都可以看成一个模块，模块都可以相互暴露和相互引用</strong><br>1.在Node中 一个文件就是一个模块<br>2.在Node中，通过require()函数来引入外部的模块，引入外部模块要加上 ./ 或者 ../<br>3.在Node中，每一个js文件中js代码都是独立运行在一个小闭包中，而不是全局作用域，所以一个模块在不引用的情况下它的的变量和函数都在其他模块中无法访问，如果引用到其他模块中，则被引用的文件相当与在一个闭包内，相当与局部变量。<br>目的：全局变量私有化，避免全局污染。<br>4.暴露模块中的变量和函数：使用exports<br>只需要将需要暴露给外部的变量或者方法设置为exports的属性就行，<br><strong>可以把exports看做一个全局对象，把所有暴露出来的函数和变量都存放在里面</strong><br>Node有一些自带的模块，成为核心模块，他的引用不需要加./ 或者../ 如fs http</p><p><img src="https://upload-images.jianshu.io/upload_images/7072486-0d6620b0e8d69fa6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="171539764614_.pic.jpg"></p><p>引用：<code>const  moudel = require (&#39;./02.js&#39;)</code><br>暴露：<code>exports.str = srt;</code></p><h3 id="CommonJS案例"><a href="#CommonJS案例" class="headerlink" title="CommonJS案例"></a>CommonJS案例</h3><p>先写一个01.js暴露出去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let str = &quot;我是小二&quot;;</span><br><span class="line"></span><br><span class="line">let test = ()=&gt;&#123;</span><br><span class="line">  console.log(&quot;今天天气很好!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">exports.str = str;</span><br><span class="line">exports.test = test;</span><br></pre></td></tr></table></figure></p><p>在写一个02.js把暴露的01.js引用过来, 然后暴露自身<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const module02 = require(&apos;./01.js&apos;);// [ ./  ../ ]</span><br><span class="line"></span><br><span class="line">exports.module02 = module02; //暴露</span><br><span class="line"></span><br><span class="line">console.log(module02.str);//我是小二</span><br></pre></td></tr></table></figure></p><p>最后在写一个03.js 引用暴露的02.js， 这样在03.js 里就包含了 02.js 和01.js了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const module03 = require(&apos;./02.js&apos;);</span><br><span class="line">console.log(module03.module02.str)//我是小二</span><br></pre></td></tr></table></figure></p><p>所以最后是这样的：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-d7e8e14a1da2526b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="161539764109_.pic.jpg" title="">                </div>                <div class="image-caption">161539764109_.pic.jpg</div>            </figure></p><p>类似一个同心圆</p><h3 id="案例：写一个求和-求平均数的模块"><a href="#案例：写一个求和-求平均数的模块" class="headerlink" title="案例：写一个求和 / 求平均数的模块"></a>案例：写一个求和 / 求平均数的模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">exports.sun = (...numbers)=&gt;&#123;</span><br><span class="line">    let result = 0;</span><br><span class="line">    numbers.forEach((itme)=&gt;&#123;</span><br><span class="line">        result += itme;</span><br><span class="line">    &#125;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.avg= (...numbers)=&gt;&#123;</span><br><span class="line">    let result = 0;</span><br><span class="line">    numbers.forEach((itme)=&gt;&#123;</span><br><span class="line">        result+= itme;</span><br><span class="line">    &#125;);</span><br><span class="line">    return result / numbers.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434502419592fd80bbb0613a42118ccab9435af408fd000" target="_blank" rel="noopener">廖雪峰的官网-模块开发</a><br>视频资料：<a href="https://study.163.com/course/courseLearn.htm?courseId=1005269026#/learn/video?lessonId=1052250610&amp;courseId=1005269026" target="_blank" rel="noopener">网易云课堂-叶建秋-从零玩转Node.js</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;模块化的意义&quot;&gt;&lt;a href=&quot;#模块化的意义&quot; class=&quot;headerlink&quot; title=&quot;模块化的意义&quot;&gt;&lt;/a&gt;模块化的意义&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS安装和使用</title>
    <link href="http://yoursite.com/2018/10/11/NodeJS%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/10/11/NodeJS安装和使用/</id>
    <published>2018-10-11T02:04:55.000Z</published>
    <updated>2018-12-21T08:20:34.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="了解Node"><a href="#了解Node" class="headerlink" title="了解Node"></a>了解Node</h2><p>NodeJS :主要应用于开发服务器，做数据API ,设计路由，和前端的主要区别在于，前端主要负责效果和交互、<br>node.js是追求性能极致的产物，主要的三个特点是：<br><strong>单线程、Non-blocking I/O、Event Driven</strong><br>Nodejs和其他后端语言的不同：</p><ol><li>采用单线程， 所以</li><li>需要非阻塞I/O，所以</li><li>需要事件驱动。<br>极大地提高了CPU的利用率：</li><li>node没有自己的语法，使用V8引擎，用的是js，V8引擎解析js，效率非常高。并且V8中很多东西都是异步的，，Node就是站在巨人的肩膀上，把V8中的一些功能一直到服务器上</li><li>没有web容器 就是安装配置完成之后，也么有一个根目录。（使用路由）</li><li>模块：在Node.js中，以模块为单位划分所有的功能，并且提供了一个完成的模块加载机制，我们可以将应用程序划分为各个不同的部分。</li></ol><h2 id="Windows命令"><a href="#Windows命令" class="headerlink" title="Windows命令"></a><strong>Windows命令</strong></h2><p>常用命令：<br><code>dir</code> 列出当下目录下面的所有文件<br><code>cd</code> 进入指定的目录<br><code>md</code> 创建文件夹<br><code>rd</code> 删除文件夹<br><code>cd..</code> 返回上级目录<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-01dca1d0f6a9557b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="81539743638_.pic.jpg" title="">                </div>                <div class="image-caption">81539743638_.pic.jpg</div>            </figure></p><h2 id="Mac命令"><a href="#Mac命令" class="headerlink" title="Mac命令"></a><strong>Mac命令</strong></h2><p><code>cd ~</code>进入我们的家目录<br><code>ls</code> 列出当下目录下面的所有文件<br><code>cd 目录名</code> 进入指定的目录<br><code>touch 文件名.html</code>创建一后缀是html的文件或者一次<code>touch a.txt b.html</code>一次创建多个文件<br><code>mkdir 文件夹名</code> 新建一个文件夹或者一次<code>mkdir a b c</code>新建三个文件夹<br><code>rm 文件/文件夹</code>删除文件/文件夹<br><code>less index.html</code>查看文本文件内容<br><code>pwd</code>看看自己在哪个目录下<br><code>man</code> 查看某个命令的详情<br>cd.. 返回上级目录</p><p><strong>小技巧</strong><br>用 Tab 键自动补齐命令<br>比如想到 /System 目录中去，输入 cd /Sy 然后按一下Tab 键，命令就会自动补齐成 cd /System<br>操作带名字中带有空格的文件和目录<br>空格在命令中写成 空格， 比如要进入 My Documents，命令为 cd My Documents </p><h2 id="进程和线程："><a href="#进程和线程：" class="headerlink" title="进程和线程："></a>进程和线程：</h2><p>  1.进程<br>     系统进行资源分配和调度的基本单位 操作系统的基础，我们写的代码都是放在进程里的 相当于工厂的车间<br>     如：任务管理器<br>  2.线程<br>   九三级的最小计量单位 负责执行进程中的程序，相当于车间里的操作工人，<br>单线程：<br>    js是单线程，时间片分割<br>多线程：<br>   根据任务决定开起几条线程（耗内存）<br>Node服务器：<br>   单线程，但很健壮，后台拥有一个I/O线程池进行调度。分布式服务器部署。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-9f4180b756ad90eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="91539744120_.pic.jpg" title="">                </div>                <div class="image-caption">91539744120_.pic.jpg</div>            </figure></p><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-80d875076390ef25.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="101539744899_.pic.jpg" title="">                </div>                <div class="image-caption">101539744899_.pic.jpg</div>            </figure><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node.js 下载</a><br>有些可能需要配置<strong>全局环境变量</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-43497297131cb4b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="121539745565_.pic.jpg" title="">                </div>                <div class="image-caption">121539745565_.pic.jpg</div>            </figure></p><p>node -v<br>查看版本号</p><p>node 进入node环境，在这个环境中可以执行JavaScript语句</p><h2 id="让node-js跑起来"><a href="#让node-js跑起来" class="headerlink" title="让node.js跑起来"></a>让node.js跑起来</h2><p>跑起来 node.js<br> 1.node 命令行下写js代码<br> 2.新建.js文件 &gt; cd 到指定目录 &gt; node index.js<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-65fcfa08be5b8942.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="131539747126_.pic.jpg" title="">                </div>                <div class="image-caption">131539747126_.pic.jpg</div>            </figure></p><p>建议使用最新的编辑器 有代码提示</p><h2 id="Node-js-的模块发开发"><a href="#Node-js-的模块发开发" class="headerlink" title="Node.js 的模块发开发"></a>Node.js 的模块发开发</h2><p>Node 需要模块化开发：<br>问题： js缺乏模块化的开发<br>解决：后来出现了commonJs （内部） 和npm（外部 包管理系统）它提供了模块的复用和引用,</p><p>CommonJs的出现 主要是为了弥补JavaScript没有模块化开发标准的缺陷，</p><p>CommonJS对模块化的定义：</p><ol><li>模块引用 require（“路径”）<br>2.模块定义<br>3.模块表识<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-7fc679453ac23729.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="141539756072_.pic.jpg" title="">                </div>                <div class="image-caption">141539756072_.pic.jpg</div>            </figure></li></ol><p>总结：<br>1.从文件的角度看，每个js文件就是一个模块，从结构看，多个js文件之间可以相互require，共同实现一个功能，整体上也是一个模块。<br>2.在Node.js中，一个模块中的定义的变量、函数等。都只能在这个文件内部有效；当需要从此文件外部引用这些变量、函数时，必须使用exports进行暴露，然后使用require引用。</p><p>A：我需要引用你  &gt;&gt; require B<br>B:  那好 &gt;&gt; 我暴露</p><p>13课至17课笔记<br>视频地址：<a href="https://study.163.com/course/courseMain.htm?courseId=1005269026" target="_blank" rel="noopener">https://study.163.com/course/courseMain.htm?courseId=1005269026</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;了解Node&quot;&gt;&lt;a href=&quot;#了解Node&quot; class=&quot;headerlink&quot; title=&quot;了解Node&quot;&gt;&lt;/a&gt;了解Node&lt;/h2&gt;&lt;p&gt;NodeJS :主要应用于开发服务器，做数据API ,设计路由，和前端的主要区别在于，前端主要负责效果和交互
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 知识点总结</title>
    <link href="http://yoursite.com/2018/09/17/Vue%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/09/17/Vue知识点总结/</id>
    <published>2018-09-17T06:04:54.000Z</published>
    <updated>2018-11-04T12:42:33.903Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h3><ul><li>vue的生命周期： <code>beforeCreate/created</code>、<code>beforeMount/mounted</code>、<code>beforeUpdate/updated</code>、<code>beforeDestory/destoryed</code></li><li>vue常用指令： <code>v-for</code>、<code>v-bind</code>（缩写形式<code>:prop</code>）、<code>v-on</code>(缩写形式<code>@click=’sss&#39;</code>)、<code>v-if/v-else/v-else-if</code>、<code>v-model</code>、<code>v-once</code>、<code>v-html</code>、<code>v-show</code>…</li><li>vue自定义组件：<code>Vue.component(‘componentName&#39;,{ props:[‘p1’,’p2’], template: ‘&lt;li&gt;&lt;/li&gt;&#39; })</code></li><li>vue常用实例方法和属性: <code>data/$data</code>、<code>methods/$methods</code>、<code>$el</code>、<code>computed</code>(计算属性)、<code>$watch</code>、<code>$set</code>、<code>$event</code>、<code>$emit</code>…</li><li>如果需要更新的属性需要缓存，则使用计算属性的方式，否则可以使用<code>methods</code>里的方法来更新属性（<code>methods</code>里的方法每次重新渲染都会执行）</li><li>计算属性默认提供了<code>getter</code>，你还可以给它设置<code>setter</code></li><li>当你数据变化是异步或者开销较大时，可以使用<code>watch</code>侦听器来响应数据的变化</li><li><code>v-bind:class</code>的值可以是一个对象，可实现类似<code>react</code>中<code>classnames</code>模块的功能</li><li>自定义组件上的<code>class</code>会被渲染拼接到<code>template</code>的根节点的<code>class</code>属性上（自定义组件上可使用<code>v-bind:class</code>来做class的判断显示逻辑）</li><li><code>v-bind:style</code>可以用来绑定内联样式，这个内联样式的值可以由一个对象来定义（类似css in js的模式）,且可以被定义为数组(多个样式对象)</li><li><code>v-bind:style</code>可以使用多重值的形式：<code>&lt;div :style=“display:[‘-webkit-box’,’-ms-flexbox’, ‘flex&#39;]&quot;&gt;&lt;/div&gt;</code></li><li><code>v-if/v-else/v-else-if</code>的时候，可以用key来管理可复用的元素</li><li><code>v-if</code>是’真正’的渲染，它会确保在切换条件过程中条件块内的元素的事件监听器和子组件适时的销毁和重建</li><li><code>v-if</code>是惰性的，初始为假，什么也不做，直到为真的时候才渲染元素</li><li><code>v-show</code>总是渲染元素，只是简单的进行切换</li><li><code>v-if</code>的切换开销大，<code>v-show</code>则是初始渲染开销大，频繁切换使用<code>v-show</code>，运行时经常改变则使用<code>v-if</code></li><li><code>v-if</code>和<code>v-for</code>一起使用时，<code>v-for</code>的优先级更高</li><li><code>v-for</code>可遍历数组，第二个参数是索引</li><li><code>v-for</code>可遍历对象，第二个参数是<code>key</code>，第三个参数是索引</li><li><code>v-for</code>和<code>&lt;template&gt;</code>搭配可减少渲染次数</li><li><code>v-for</code>和自定义组件使用时，需要使用<code>props</code>来传递值</li><li>尽可能的为遍历子元素加上<code>key</code>，获得渲染优化</li><li>数组变异方法：<code>push/pop/unshift/shift/splice/sort/reverse</code>改变原始数组</li><li>数组非变异方法：<code>filter/concat/slice</code> 不改变原始数组，总是返回新数组</li><li>Vue不能检测到数组索引赋值（使用<code>vm.$set</code>解决）和修改<code>length</code>长度赋值(使用<code>splice</code>解决)的情况</li><li>Vue不能检测对象属性的添加和删除(使用<code>vm.$set</code>或<code>Object.assign</code>)</li><li><code>is=“todo-item”</code>这种属性的写法比较适合DOM模板</li><li>事件修饰符，它们可串联使用：<code>.stop</code>、<code>.prevent</code>、<code>.capture</code>、<code>.self</code>、<code>.once</code>、<code>.passive</code>(尤其适合移动端)</li><li><code>.passive</code>不用同时和<code>.prevent</code>使用，后者会被忽略</li><li>按键修饰符: <code>.enter</code>、<code>.tab</code>、<code>.delete</code>、<code>.esc</code>、<code>.space</code>、<code>.up</code>、<code>.down</code>、<code>.left</code>、<code>.right</code></li><li>系统按键修饰符:<code>.ctrl</code>、<code>.alt</code>、<code>.shift</code>、<code>.meta(⌘|⊞|◆)</code>、<code>.exact</code>(允许精确控制系统修饰符组合键触发)</li><li>鼠标修饰符： <code>.left</code>、<code>.right</code>、<code>.middle</code></li><li><code>v-model</code>会忽略表单元素的<code>value</code>、<code>checked</code>、<code>selected</code>，仅仅使用实例中的数据作为数据源</li><li>表单事件修饰符：<code>.lazy</code>、<code>.number</code>、<code>.trim</code></li><li>组件是可复用的vue实例，具有vue实例大多数属性和方法</li><li>组件可复用，每个组件有独立的空间</li><li>组件上的data必须是一个函数，这样做避免影响了其他组件</li><li>通过<code>Vue.component()</code>全局注册的组件可在其被注册后的任何通过<code>new Vue()</code>创建的实例所使用，包含其组件树中的所有组件</li><li>通过插槽<code>&lt;slot&gt;</code>分发内容(其实就是类似于react的children)</li><li>动态组件<code>&lt;component&gt;</code>配合属性<code>is</code>来实现</li><li>解析DOM模板时需要注意下可能会有不生效的情况，需要使用is来传递组件</li></ul><h3 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h3><ul><li>全局注册/局部注册</li><li>局部注册组件在子组件中不可用</li><li>全局注册的行为必须在根Vue实例创建之前发生</li><li><code>camelCase</code>的属性可以在组件中使用<code>kebab-case</code></li><li>可以以对象的模式指定每一个<code>props</code>属性的类型</li><li>父级<code>props</code>的更新会向下流动，反之则不行</li><li>由于JavaScript对象和数组是引用传入的，所以当子组件对props的改变将会影响到父组件</li><li>props类型校验可以是原生构造对象的中的任意一个，也可以自定义检验类型，通过<code>instanceof</code>检查</li><li>对于绝大多数特性来说，外部传入的值会替换掉组件内部设置好的值，如input的type属性，但有的属性则是会进行合并，如class</li><li><code>inhertAttrs:false</code>设置不希望根元素继承特性，可以使用<code>$attrs</code>属性来设置继承的目标元素</li><li><code>v-on</code>在设置事件监听器时，会把事件名全部转换成小写，推荐始终使用<code>kebab-case</code>的事件名</li><li><code>v-model</code>可以使用自定义组件中的<code>model</code>属性自定义</li><li>父组件模板的所有东西都会在父级作用域内编译，子组件的所有内容都会在子组件作用域内编译</li><li>插槽(<code>&lt;slot&gt;&lt;/slot&gt;</code>)/具名插槽(<code>&lt;slot name=“header&quot;&gt;&lt;/slot&gt;</code>)/作用域插槽(<code>slot/slot-scope</code>)</li><li><code>&lt;keep-alive&gt;</code>组件可用来缓存被切换后隐藏的组件的状态</li><li><code>$root</code>访问根实例，<code>$parent</code>访问父组件实例(不推荐)</li><li>父组件访问子组件，使用<code>$refs</code>属性来获取设置了<code>ref</code>属性的子组件</li><li><code>provide</code>属性允许我们指定要分享给后代组件使用的方法，然后后代组件使用<code>inject</code>属性来获得祖先组件分享的方法(依赖注入)</li><li><p>事件侦听器（<code>$emit</code>派发的事件）</p><ul><li><code>v-on</code> 指令侦听</li><li><code>$on</code> 侦听一个事件</li><li><code>$once</code> 一次性侦听一个事件</li><li><code>$off</code> 停止侦听一个事件</li></ul></li><li>慎用递归组件</li><li>尽量避免组件的循环引用</li><li>优先使用<code>template</code>来定义模板，而不是<code>inline-template</code></li><li><code>$forceUpdate</code>来强制更新view</li><li>组件包含大量静态内容时，可使用<code>v-once</code>来标记，缓存静态内容</li></ul><h3 id="过渡-amp-动画"><a href="#过渡-amp-动画" class="headerlink" title="过渡 &amp; 动画"></a>过渡 &amp; 动画</h3><ul><li><code>transition</code>组件控制过渡动画，可以给任何元素和组件添加进入/离开过渡</li><li><p>当插入或删除<code>transition</code>中的元素时，vue会做如下处理</p><ul><li>自动嗅探元素是否使用了css过渡和动画，适当时机添加/删除类名</li><li>元素的钩子函数会在适当时机被调用</li><li>元素既没有钩子函数也没有css动画，插入和删除操作在下一帧立即执行（浏览器逐帧动画机制）</li></ul></li><li><p>过渡的类名</p><ul><li><code>v-enter/v-enter-active/v-enter-to</code></li><li><code>v-leave/v-leave-active/v-leave-to</code></li></ul></li><li>css动画用法同css过渡，区别是类名<code>v-enter</code>不会在DOM插入后立即删除，而是在<code>animationend</code>事件触发时删除</li><li><p>自定义过渡类名，使用以下属性指定:</p><ul><li><code>enter-class/enter-active-class/enter-to-class</code></li><li><code>leave-class/leave-active-class/leave-to-class</code></li><li>自定义类名优先级高于普通的类名</li></ul></li><li>使用<code>typ</code>e属性设置<code>transition</code>或<code>animation</code>来申明vue使用的动画类型</li><li><code>transition</code>组件上使用<code>duration</code>来设置动画执行的时间</li><li><p>可以使用钩子函数</p><ul><li><code>beforeEnter/enter/afterEnter/enterCancelled</code></li><li><code>beforeLeave/leave/afterLeave/leaveCancelled</code></li><li>钩子函数使用<code>v-on</code>指令绑定</li><li>钩子和结合过渡和动画使用，也可以单独使用</li><li>在<code>enter/leave</code>中，必须使用<code>done()</code>来进行回调，否则会同步调用，过渡或动画会立即完成</li><li>对于纯使用JavaScript来进行的动画，推荐使用<code>v-bind:css=“false”</code>来取消css的检测，减少css的影响</li></ul></li><li><p>可使用<code>apear</code>设置初始渲染的过渡</p><ul><li><code>apear/apear-active/apear-to</code></li><li><code>beforeApear/apear/afterApear/apearCancelled</code></li></ul></li><li>多元素过渡，设置唯一<code>key</code></li><li><p>过渡模式:</p><ul><li><code>In-out</code> 新元素先过渡，完成后当前元素过渡离开</li><li><code>out-in</code> 当前元素先过渡，完成后新元素过渡进入</li><li><code>默认行为</code>：进入和离开同时发生</li></ul></li><li>多个组件过渡使用动态组件实现</li><li><p>列表过渡 <code>&lt;transition-group&gt;</code></p><ul><li>以真实元素呈现，默认为<code>&lt;span&gt;</code>，可使用tag更改呈现标签</li><li>过渡模式不可用</li><li>内部需要唯一<code>key</code></li></ul></li><li>列表排序过渡，使用的是<code>FLIP</code>动画，使用类名<code>v-move</code>来定义class</li></ul><h3 id="可复用性-amp-组合"><a href="#可复用性-amp-组合" class="headerlink" title="可复用性 &amp; 组合"></a>可复用性 &amp; 组合</h3><ul><li><code>mixins</code>混入属性发生冲突时，以组件数据优先（一层属性深度浅合并）</li><li><code>mixins</code>混入方法发生冲突时，会将函数合并为一个数组，优先执行混入方法，其次执行组件方法</li><li><code>Vue.extend</code>策略和<code>mixins</code>相同</li><li>慎用全局混入</li><li>合并策略可以自定义（参考<code>vuex</code>的具体实现：<code>Vue.config.optionMergeStrategies</code>）</li><li>全局自定义指令：<code>Vue.directive()</code></li><li>局部自定义指令：属性<code>directives</code>，类型为<code>Object</code></li><li><p>钩子函数</p><ul><li><strong>bind</strong> 指令第一次绑定到元素时调用，只执行一次，可用于一次性初始化设置</li><li><strong>inserted</strong> 元素插入父节点时调用</li><li><strong>update</strong> 所有VNode更新时调用，可能发生在子<em>VNode</em>之前</li><li><strong>componentUpdated</strong> 指令所在组件在<em>VNode</em>和其子<em>VNode</em>更新后调用</li><li><strong>unbind</strong> 指令与元素解绑时调用</li></ul></li><li><p>钩子函数都会被传入以下参数：</p><ul><li><strong>el</strong> 指令绑定元素，可操作DOM</li><li><strong>binding</strong> 指令描述对象</li><li><strong>vnode</strong> Vue生成的虚拟节点</li><li><strong>oldVnode</strong> 上一个<code>Vnode</code>，仅在<code>update</code>和<code>componentUpdated</code>中使用</li></ul></li><li>指令接受所有合法的JavaScript表达式</li></ul><h3 id="渲染函数-amp-JSX"><a href="#渲染函数-amp-JSX" class="headerlink" title="渲染函数 &amp; JSX"></a>渲染函数 &amp; JSX</h3><ul><li><code>render</code>函数接受<code>createElement</code>方法作为参数</li><li><code>createElement</code>方法的作用是创建一个虚拟节点(VNode)</li><li><code>createElement</code>参数比较复杂，参照官网：参数</li><li>组件树中的<code>VNodes</code>必须唯一</li><li>render中的<code>v-if/v-for</code>可以使用<code>if/else</code>和<code>map</code>重写</li><li>插槽使用<code>this.$slot.default</code>访问，作用域插槽使用<code>this.$scopeSlots.default</code>访问和设置</li><li>可以使用插件<code>babel-plugin-transform-vue-jsx</code>支持JSX语法</li><li>将h作为<code>createElement</code>的别名是Vue生态的一个惯例，也是JSX要求的</li><li>函数式组件 关键词：functional</li><li>函数式组件渲染开销低，但相应的，它不会出现在Vue devtools的组件树里边</li><li>函数式组件要求你自己实现同名特性的替换与智能合并</li><li>Vue的模板实际编译成了<code>render</code>方法实现的<code>VNode</code>，可以使用<code>Vue.compile()</code>方法来输出编译结果</li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul><li><p>插件会为vue提供全局的功能，包括但不限于以下几种：</p><ul><li>添加全局的属性或方法，如<a href="https://github.com/karol-f/vue-custom-element" target="_blank" rel="noopener">vue-custom-element</a></li><li>添加全局的资源（指令、过滤器、过渡等），如：<a href="https://github.com/vuejs/vue-touch" target="_blank" rel="noopener">vue-touch</a></li><li>通过全局<code>mixins</code>添加一些组件选项，如：<a href="https://github.com/vuejs/vue-touch" target="_blank" rel="noopener">vue-router</a></li><li>添加Vue实例方法，通过添加到<code>Vue.prototype</code>上实现</li><li>一个独立的库，同时有自己的API，又实现以上部分功能，如：<a href="https://github.com/vuejs/vue-touch" target="_blank" rel="noopener">vue-router</a></li></ul></li><li>Vue插件有一个公开的方法<code>install</code>，第一个参数是Vue构造器，第二个参数是一个可选对象。</li><li>插件的使用通过全局方法<code>Vue.use(MyPlugin)</code>使用，只会注册一次插件</li><li>在CommonJS中，应该始终显式的调用<code>Vue.use</code>方法</li><li>社区插件列表<a href="https://github.com/vuejs/awesome-vue#components--libraries" target="_blank" rel="noopener">awesome-vue</a></li></ul><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; msg | filter &#125;&#125;</span><br><span class="line">&lt;div v-bind=“msg | filter&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>全局过滤器使用Vue.filter()创建</li><li>局部过滤器使用对象属性filters创建</li><li>过滤器函数总是接收表达式的值作为第一个参数，过滤器可以有多个，值依次向后传递</li><li>过滤器可以接收额外的参数</li></ul><h3 id="构建-amp-部署"><a href="#构建-amp-部署" class="headerlink" title="构建 &amp; 部署"></a>构建 &amp; 部署</h3><ul><li><code>&lt;script&gt;</code>标签引入<code>[vue.min.js](https://vuejs.org/js/vue.min.js)</code></li><li><p>使用<code>vue-cli</code></p><ul><li>webpack + vue-loader</li><li>browserify + vueify</li><li>rollup + rollup-plugin-vue</li></ul></li><li>利用钩子函数<code>Vue.config.errorHandler</code>定义配置来跟踪运行时错误，可以搭配<code>[Sentry](https://sentry.io/)</code>使用（<a href="https://sentry.io/for/vue/" target="_blank" rel="noopener">集成配置</a>）</li><li>单文件组件（<code>.vue</code>文件）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础知识：&quot;&gt;&lt;a href=&quot;#基础知识：&quot; class=&quot;headerlink&quot; title=&quot;基础知识：&quot;&gt;&lt;/a&gt;基础知识：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;vue的生命周期： &lt;code&gt;beforeCreate/created&lt;/code&gt;、&lt;code&gt;be
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="Vue.js" scheme="http://yoursite.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Array的push与unshift方法性能比较分析</title>
    <link href="http://yoursite.com/2018/09/01/Array%E7%9A%84push%E4%B8%8Eunshift%E6%96%B9%E6%B3%95%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/09/01/Array的push与unshift方法性能比较分析/</id>
    <published>2018-09-01T12:45:23.000Z</published>
    <updated>2018-09-01T11:58:10.805Z</updated>
    
    <content type="html"><![CDATA[<p>从原理就可以知道，unshift的效率是较低的。原因是，它每添加一个元素，都要把现有元素往下移一个位置。但到底效率差异有多大呢？下面来测试一下。<br>测试环境的主要硬件：CPU T7100（1.8G）；内存4G DDR2 667；硬盘5400转。主要软件：操作系统为Windows 7；浏览器为Firefox 3.6.9。测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ ], s = +new Date; </span><br><span class="line">// push性能测试 </span><br><span class="line">for (var i = 0; i &lt; 50000; i++) &#123; </span><br><span class="line">　　arr.push(i); </span><br><span class="line">&#125; </span><br><span class="line">console.log(+new Date - s); </span><br><span class="line">s = +new Date; </span><br><span class="line">arr = [ ]; </span><br><span class="line">// unshift性能测试 </span><br><span class="line">for (var i = 0; i &lt; 50000; i++) &#123; </span><br><span class="line">　　arr.unshift(i); </span><br><span class="line">&#125; </span><br><span class="line">console.log(+new Date - s);</span><br></pre></td></tr></table></figure></p><p>这段代码分别执行了50000次push和unshift操作，运行一次以后，得出结果：<br>12<br>1152<br>可见，unshift比push要慢差不多100倍！因此，平时还是要慎用unshift，特别是对大数组。那如果一定要达到unshift的效果，有没有其他方法呢？答案是肯定的。<br>Array有一个叫做reverse的方法，能够把一个数组反转。先把要放进数组的元素用push添加，再执行一次reverse，就达到了unshift的效果。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 50000; i++) &#123; </span><br><span class="line">　　arr.push(i); </span><br><span class="line">&#125; </span><br><span class="line">arr.reverse(); </span><br><span class="line"></span><br><span class="line">//reverse的性能又如何呢，下面再来测试：</span><br><span class="line">var arr = [ ], s = +new Date; </span><br><span class="line">for (var i = 0; i &lt; 50000; i++) &#123; </span><br><span class="line">　　arr.push(i); </span><br><span class="line">&#125; </span><br><span class="line">arr.reverse(); </span><br><span class="line">console.log(+new Date - s);</span><br></pre></td></tr></table></figure></p><p>结果是：<br>12<br>可见，reverse性能极高，甚至于没有额外的消耗，可以放心使用。</p><p>当你的才华撑不起你的野心的时候、请潜下心、低下头、好好学习、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从原理就可以知道，unshift的效率是较低的。原因是，它每添加一个元素，都要把现有元素往下移一个位置。但到底效率差异有多大呢？下面来测试一下。&lt;br&gt;测试环境的主要硬件：CPU T7100（1.8G）；内存4G DDR2 667；硬盘5400转。主要软件：操作系统为Win
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>焦虑的汤药</title>
    <link href="http://yoursite.com/2018/08/21/%E7%84%A6%E8%99%91%E7%9A%84%E6%B1%A4%E8%8D%AF/"/>
    <id>http://yoursite.com/2018/08/21/焦虑的汤药/</id>
    <published>2018-08-21T12:45:23.000Z</published>
    <updated>2018-10-19T09:23:57.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何正确使用时间"><a href="#如何正确使用时间" class="headerlink" title="如何正确使用时间"></a>如何正确使用时间</h1><p>你是否时常会焦虑时间过的很快，没时间学习，本文将会分享一些个人的见解。</p><h2 id="花时间补基础，读文档"><a href="#花时间补基础，读文档" class="headerlink" title="花时间补基础，读文档"></a>花时间补基础，读文档</h2><p>在工作中我们时常会花很多时间去 debug，但是你是否发现很多问题最终只是你基础不扎实或者文档没有仔细看。</p><p>基础是你技术的基石，一定要花时间打好基础，而不是追各种新的技术。一旦你的基础扎实，学习各种新的技术也肯定不在话下，因为新的技术，究其根本都是相通的。</p><p>文档同样也是一门技术的基础。一个优秀的库，开发人员肯定已经把如何使用这个库都写在文档中了，仔细阅读文档一定会是少写 bug 的最省事路子。</p><h2 id="学会搜索"><a href="#学会搜索" class="headerlink" title="学会搜索"></a>学会搜索</h2><p>如果你还在使用百度搜索编程问题，请尽快抛弃这个垃圾搜索引擎。同样一个关键字，使用百度和谷歌，谷歌基本完胜的。即使你使用中文在谷歌中搜索，得到的结果也往往是谷歌占优，所以如果你想迅速的通过搜索引擎来解决问题，那一定是谷歌。</p><h2 id="学点英语"><a href="#学点英语" class="headerlink" title="学点英语"></a>学点英语</h2><p>说到英语，一定是大家所最不想听的。其实我一直认为程序员学习英语是简单的，因为我们工作中是一直接触着英语，并且看懂技术文章，文档所需要的单词量是极少的。我时常在群里看到大家发出一个问题的截图问什么原因，其实在截图中英语已经很明白的说明了问题的所在，如果你的英语过关，完全不需要浪费时间来提问和搜索。所以我认为学点英语也是节省时间中很重要的一点。</p><p>那么如何去学习呢，chrome 装个翻译插件，直接拿英文文档或文章读，不会的就直接划词翻译，然后记录下这个单词并背诵。每天花半小时看点英文文档和文章，坚持两个月，你的英语水平不说别的，看文档和文章绝对不会有难题了。这一定是一个很划算的个人时间投资，花点时间学习英语，能为你将来的技术之路铺平很多坎。</p><h2 id="画个图，想一想再做"><a href="#画个图，想一想再做" class="headerlink" title="画个图，想一想再做"></a>画个图，想一想再做</h2><p>你是否遇到过这种问题，需求一下来，看一眼，然后马上就按照设计稿开始做了，可能中间出个问题导致你需要返工。</p><p>如果你存在这样的问题，我很推荐在看到设计稿和需求的时候花点时间想一想，画一画。考虑一下设计稿中是否可以找到可以拆分出来的复用组件，是否存在之前写过的组件。该如何组织这个界面，数据的流转是怎么样的。然后画一下这个页面的需求，最后再动手做。</p><h2 id="利用好下班时间学习"><a href="#利用好下班时间学习" class="headerlink" title="利用好下班时间学习"></a>利用好下班时间学习</h2><p>说到下班时间，那可能就有人说了公司很迟下班，这其实是国内很普遍的情况。但是我认为正常的加班是可以的，但是强制的加班就是在损耗你的身体和前途。</p><p>可以这么说，大部分的 996 公司，加班的这些时间并不会增加你的技术，无非就是在写一些重复的业务逻辑。也许你可以拿到更多的钱，但是代价是身体还有前途。程序员是靠技术吃饭的，如果你长久呆在一个长时间加班的公司，不能增长你的技术还要吞噬你的下班学习时间，那么你一定会废掉的。如果你遇到了这种情况，只能推荐尽快跳槽到非 996 的公司。</p><p>那么如果你有足够的下班时间，一定要花上 1， 2 小时去学习，上班大家基本都一样，技术的精进就是看下班以后的那几个小时了。如果你能利用好下班时间来学习，坚持下去，时间一定会给你很好的答复。</p><h2 id="列好-ToDo"><a href="#列好-ToDo" class="headerlink" title="列好 ToDo"></a>列好 ToDo</h2><p>我喜欢规划好一段时间内要做的事情，并且要把事情拆分为小点。给 ToDo 列好优先级，紧急的优先级最高。相同优先级的我喜欢先做简单的，因为这样一旦完成就能划掉一个，提高成就感。</p><h2 id="反思和整理"><a href="#反思和整理" class="headerlink" title="反思和整理"></a>反思和整理</h2><p>每周末都会花上点时间整理下本周记录的笔记和看到的不错文章。然后考虑下本周完成的工作和下周准备要完成的工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何正确使用时间&quot;&gt;&lt;a href=&quot;#如何正确使用时间&quot; class=&quot;headerlink&quot; title=&quot;如何正确使用时间&quot;&gt;&lt;/a&gt;如何正确使用时间&lt;/h1&gt;&lt;p&gt;你是否时常会焦虑时间过的很快，没时间学习，本文将会分享一些个人的见解。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
    
      <category term="生活感悟" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>webpack4快速入门</title>
    <link href="http://yoursite.com/2018/08/11/Webpack%204%20%E5%92%8C%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%EF%BC%88%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8webpack4%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8C%E7%9C%8B%E6%87%82%E4%BA%86%E4%BD%A0%E5%B0%B1%E5%85%A5%E9%97%A8%E4%BA%86%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/11/Webpack 4 和单页应用入门（史上最全webpack4入门教程，看懂了你就入门了）/</id>
    <published>2018-08-11T12:45:23.000Z</published>
    <updated>2018-10-19T09:35:36.267Z</updated>
    
    <content type="html"><![CDATA[<p><strong>可以说是我目前看到最详细的 webpack 4 入门文章。<br>基本看完这个，基本也算一个合格的初级webpack配置工程师了。</strong></p><blockquote><p>webpack 更新到了 4.0，官网还没有更新文档。因此把教程更新一下，方便大家用起 webpack 4。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-30b8f96f6314cf58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="webpack" title="">                </div>                <div class="image-caption">webpack</div>            </figure> <h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#写在开头" target="_blank" rel="noopener"></a>写在开头</h2><p><del>先说说为什么要写这篇文章，最初的原因是组里的小朋友们看了 <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> 文档后，表情都是这样的：摘自 webpack 一篇文档的评论区）</del></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-7cc744905b9edb5e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wtf" title="">                </div>                <div class="image-caption">wtf</div>            </figure> <p><del>是的，即使是外国佬也在吐槽这文档不是人能看的。回想起当年自己啃 webpack 文档的血与泪的往事，觉得有必要整一个教程，可以让大家看完后愉悦地搭建起一个 webpack 打包方案的项目。</del></p><p>官网新的 <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> 文档现在写的很详细了，能看英文的小伙伴可以直接去看官网。</p><p>可能会有人问 webpack 到底有什么用，你不能上来就糊我一脸代码让我马上搞，我照着搞了一遍结果根本没什么用，都是骗人的。所以，在说 webpack 之前，我想先谈一下前端打包方案这几年的演进历程，在什么场景下，我们遇到了什么问题，催生出了应对这些问题的工具。了解了需求和目的之后，你就知道什么时候 webpack 可以帮到你。我希望我用完之后很爽，你们用完之后也是。</p><h2 id="先说说前端打包方案的黑暗历史"><a href="#先说说前端打包方案的黑暗历史" class="headerlink" title="先说说前端打包方案的黑暗历史"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#先说说前端打包方案的黑暗历史" target="_blank" rel="noopener"></a>先说说前端打包方案的黑暗历史</h2><p>在很长的一段前端历史里，是不存在打包这个说法的。那个时候页面基本是纯静态的或者服务端输出的，没有 AJAX，也没有 jQuery。那个时候的 JavaScript 就像个玩具，用处大概就是在侧栏弄个时钟，用 media player 放个 mp3 之类的脚本，代码量不是很多，直接放在 <code>&lt;script&gt;</code> 标签里或者弄个 js 文件引一下就行，日子过得很轻松愉快。</p><p>随后的几年，人们开始尝试在一个页面里做更多的事情。容器的显示，隐藏，切换。用 css 写的弹层，图片轮播等等。但如果一个页面内不能向服务器请求数据，能做的事情毕竟有限的，代码的量也能维持在页面交互逻辑范围内。这时候很多人开始突破一个页面能做的事情的范围，使用隐藏的 iframe 和 flash 等作为和服务器通信的桥梁，新世界的大门慢慢地被打开，在一个页面内和服务器进行数据交互，意味着以前需要跳转多个页面的事情现在可以用一个页面搞定。但由于 iframe 和 flash 技术过于 tricky 和复杂，并没能得到广泛的推广。</p><p>直到 Google 推出 Gmail 的时候（2004 年），人们意识到了一个被忽略的接口，<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequest</a>, 也就是我们俗称的 AJAX, 这是一个使用方便的，兼容性良好的服务器通信接口。从此开始，我们的页面开始玩出各种花来了，前端一下子出现了各种各样的库，<a href="http://prototypejs.org/" target="_blank" rel="noopener">Prototype</a>、<a href="https://dojotoolkit.org/" target="_blank" rel="noopener">Dojo</a>、<a href="http://mootools.net/" target="_blank" rel="noopener">MooTools</a>、<a href="https://www.sencha.com/products/extjs/" target="_blank" rel="noopener">Ext JS</a>、<a href="https://jquery.com/" target="_blank" rel="noopener">jQuery</a>…… 我们开始往页面里插入各种库和插件，我们的 js 文件也就爆炸了。</p><p>随着 js 能做的事情越来越多，引用越来越多，文件越来越大，加上当时大约只有 2Mbps 左右的网速，下载速度还不如 3G 网络，对 js 文件的压缩和合并的需求越来越强烈，当然这里面也有把代码混淆了不容易被盗用等其他因素在里面。<a href="http://crockford.com/javascript/jsmin" target="_blank" rel="noopener">JSMin</a>、<a href="http://yui.github.io/yuicompressor/" target="_blank" rel="noopener">YUI Compressor</a>、<a href="https://developers.google.com/closure/compiler/" target="_blank" rel="noopener">Closure Compiler</a>、<a href="http://lisperator.net/uglifyjs/" target="_blank" rel="noopener">UglifyJS</a> 等 js 文件压缩合并工具陆陆续续诞生了。压缩工具是有了，但我们得要执行它，最简单的办法呢，就是 windows 上搞个 bat 脚本，mac / linux 上搞个 bash 脚本，哪几个文件要合并在一块的，哪几个要压缩的，发布的时候运行一下脚本，生成压缩后的文件。</p><p>基于合并压缩技术，项目越做越大，问题也越来越多，大概就是以下这些问题：</p><ul><li>库和插件为了要给他人调用，肯定要找个地方注册，一般就是在 window 下申明一个全局的函数或对象。难保哪天用的两个库在全局用同样的名字，那就冲突了。</li><li>库和插件如果还依赖其他的库和插件，就要告知使用人，需要先引哪些依赖库，那些依赖库也有自己的依赖库的话，就要先引依赖库的依赖库，以此类推。</li></ul><p>恰好就在这个时候（2009 年），随着后端 JavaScript 技术的发展，人们提出了 <a href="http://wiki.commonjs.org/wiki/Modules/1.1.1" target="_blank" rel="noopener">CommonJS</a> 的模块化规范，大概的语法是： 如果 <code>a.js</code> 依赖 <code>b.js</code> 和 <code>c.js</code>， 那么就在 <code>a.js</code> 的头部，引入这些依赖文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var b = require(&apos;./b&apos;)</span><br><span class="line">var c = require(&apos;./c&apos;)</span><br></pre></td></tr></table></figure><p>那么变量 <code>b</code> 和 <code>c</code> 会是什么呢？那就是 b.js 和 c.js 导出的东西，比如 b.js 可以这样导出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.square = function(num) &#123;</span><br><span class="line">  return num * num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在 a.js 使用这个 <code>square</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var n = b.square(2)</span><br></pre></td></tr></table></figure><p>如果 c.js 依赖 d.js， 导出的是一个 <code>Number</code>， 那么可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var d = require(&apos;./d&apos;)</span><br><span class="line">module.exports = d.PI // 假设 d.PI 的值是 3.14159</span><br></pre></td></tr></table></figure><p>那么 a.js 中的变量 <code>c</code> 就是数字 <code>3.14159</code>，具体的语法规范可以查看 Node.js 的 <a href="https://nodejs.org/api/modules.html" target="_blank" rel="noopener">文档</a>。</p><p>但是 CommonJS 在浏览器内并不适用。因为 <code>require()</code> 的返回是同步的，意味着有多个依赖的话需要一个一个依次下载，堵塞了 js 脚本的执行。所以人们就在 CommonJS 的基础上定义了 <a href="https://github.com/amdjs/amdjs-api" target="_blank" rel="noopener">Asynchronous Module Definition (AMD)</a> 规范(2011 年），使用了异步回调的语法来并行下载多个依赖项，比如作为入口的 a.js 可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;./b&apos;, &apos;./c&apos;], function(b, c) &#123;</span><br><span class="line">  var n = b.square(2)</span><br><span class="line">  console.log(c)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>相应的导出语法也是异步回调方式，比如 <code>c.js</code> 依赖 <code>d.js</code>， 就写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;./d&apos;], function(d) &#123;</span><br><span class="line">  return d.PI</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到，定义一个模块是使用 <code>define()</code> 函数，<code>define()</code> 和 <code>require()</code> 的区别是，<code>define()</code> 必须要在回调函数中返回一个值作为导出的东西，<code>require()</code> 不需要导出东西，因此回调函数中不需要返回值，也无法作为被依赖项被其他文件导入，因此一般用于入口文件，比如页面中这样加载 <code>a.js</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/a&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>以上是 AMD 规范的基本用法，更详细的就不多说了（反正也淘汰了～），有兴趣的可以看 <a href="http://requirejs.org/docs/api.html" target="_blank" rel="noopener">这里</a>。</p><p>js 模块化问题基本解决了，css 和 html 也没闲着。什么 <a href="http://lesscss.org/" target="_blank" rel="noopener">less</a>，<a href="http://sass-lang.com/" target="_blank" rel="noopener">sass</a>，<a href="http://stylus-lang.com/" target="_blank" rel="noopener">stylus</a> 的 css 预处理器横空出世，说能帮我们简化 css 的写法，自动给你加 vendor prefix。html 在这期间也出现了一堆模板语言，什么 <a href="http://handlebarsjs.com/" target="_blank" rel="noopener">handlebars</a>，<a href="http://www.embeddedjs.com/" target="_blank" rel="noopener">ejs</a>，<a href="http://jade-lang.com/" target="_blank" rel="noopener">jade</a>，可以把 ajax 拿到的数据插入到模板中，然后用 innerHTML 显示到页面上。</p><p>托 AMD 和 CSS 预处理和模板语言的福，我们的编译脚本也洋洋洒洒写了百来行。命令行脚本有个不好的地方，就是 windows 和 mac/linux 是不通用的，如果有跨平台需求的话，windows 要装个可以执行 bash 脚本的命令行工具，比如 msys（目前最新的是 <a href="http://msys2.github.io/" target="_blank" rel="noopener">msys2</a>），或者使用 php 或 python 等其他语言的脚本来编写，对于非全栈型的前端程序员来说，写 bash / php / python 还是很生涩的。因此我们需要一个简单的打包工具，可以利用各种编译工具，编译 / 压缩 js、css、html、图片等资源。然后 <a href="http://gruntjs.com/" target="_blank" rel="noopener">Grunt</a> 产生了（2012 年），配置文件格式是我们最爱的 js，写法也很简单，社区有非常多的插件支持各种编译、lint、测试工具。一年多后另一个打包工具 <a href="http://gulpjs.com/" target="_blank" rel="noopener">gulp</a> 诞生了，扩展性更强，采用流式处理效率更高。</p><p>依托 AMD 模块化编程，SPA(Single-page application) 的实现方式更为简单清晰，一个网页不再是传统的类似 word 文档的页面，而是一个完整的应用程序。SPA 应用有一个总的入口页面，我们通常把它命名为 index.html、app.html、main.html，这个 html 的 <code>&lt;body&gt;</code> 一般是空的，或者只有总的布局（layout），比如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-e4d8616ab5f42665.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure> <p>布局会把 header、nav、footer 的内容填上，但 main 区域是个空的容器。这个作为入口的 html 最主要的工作是加载启动 SPA 的 js 文件，然后由 js 驱动，根据当前浏览器地址进行路由分发，加载对应的 AMD 模块，然后该 AMD 模块执行，渲染对应的 html 到页面指定的容器内（比如图中的 main）。在点击链接等交互时，页面不会跳转，而是由 js 路由加载对应的 AMD 模块，然后该 AMD 模块渲染对应的 html 到容器内。</p><p>虽然 AMD 模块让 SPA 更容易地实现，但小问题还是很多的：</p><ul><li>不是所有的第三方库都是 AMD 规范的，这时候要配置 <code>shim</code>，很麻烦。</li><li>虽然 RequireJS 支持通过插件把 html 作为依赖加载，但 html 里面的 <code>&lt;img&gt;</code> 的路径是个问题，需要使用绝对路径并且保持打包后的图片路径和打包前的路径不变，或者使用 html 模板语言把 <code>src</code> 写成变量，在运行时生成。</li><li>不支持动态加载 css，变通的方法是把所有的 css 文件合并压缩成一个文件，在入口的 html 页面一次性加载。</li><li>SPA 项目越做越大，一个应用打包后的 js 文件到了几 MB 的大小。虽然 <a href="http://requirejs.org/docs/optimization.html" target="_blank" rel="noopener">r.js</a> 支持分模块打包，但配置很麻烦，因为模块之间会互相依赖，在配置的时候需要 exclude 那些通用的依赖项，而依赖项要在文件里一个个检查。</li><li>所有的第三方库都要自己一个个的下载，解压，放到某个目录下，更别提更新有多麻烦了。虽然可以用 <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a> 包管理工具，但 npm 的包都是 CommonJS 规范的，给后端 Node.js 用的，只有部分支持 AMD 规范，而且在 npm 3 之前，这些包有依赖项的话也是不能用的。后来有个 <a href="https://bower.io/" target="_blank" rel="noopener">bower</a> 包管理工具是专门的 web 前端仓库，这里的包一般都支持 AMD 规范。</li><li>AMD 规范定义和引用模块的语法太麻烦，上面介绍的 AMD 语法仅是最简单通用的语法，API 文档里面还有很多变异的写法，特别是当发生循环引用的时候（a 依赖 b，b 依赖 a），需要使用其他的 <a href="http://requirejs.org/docs/api.html#circular" target="_blank" rel="noopener">语法</a> 解决这个问题。而且 npm 上很多前后端通用的库都是 CommonJS 的语法。后来很多人又开始尝试使用 ES6 模块规范，如何引用 ES6 模块又是一个大问题。</li><li>项目的文件结构不合理，因为 grunt/gulp 是按照文件格式批量处理的，所以一般会把 js、html、css、图片分别放在不同的目录下，所以同一个模块的文件会散落在不同的目录下，开发的时候找文件是个麻烦的事情。code review 时想知道一个文件是哪个模块的也很麻烦，解决办法比如又要在 imgs 目录下建立按模块命名的文件夹，里面再放图片。</li></ul><p>到了这里，我们的主角 webpack 登场了（2012 年）（此处应有掌声）。</p><p>和 webpack 差不多同期登场的还有 <a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a>。这里简单介绍一下 Browserify。Browserify 的目的是让前端也能用 CommonJS 的语法 <code>require(&#39;module&#39;)</code> 来加载 js。它会从入口 js 文件开始，把所有的 <code>require()</code> 调用的文件打包合并到一个文件，这样就解决了异步加载的问题。那么 Browserify 有什么不足之处导致我不推荐使用它呢? 主要原因有下面几点：</p><ul><li>最主要的一点，Browserify 不支持把代码打包成多个文件，在有需要的时候加载。这就意味着访问任何一个页面都会全量加载所有文件。</li><li>Browserify 对其他非 js 文件的加载不够完善，因为它主要解决的是 <code>require()</code> js 模块的问题，其他文件不是它关心的部分。比如 html 文件里的 img 标签，它只能转成 <a href="https://en.wikipedia.org/wiki/Data_URI_scheme" target="_blank" rel="noopener">Data URI</a> 的形式，而不能替换为打包后的路径。</li><li>因为上面一点 Browserify 对资源文件的加载支持不够完善，导致打包时一般都要配合 gulp 或 grunt 一块使用，无谓地增加了打包的难度。</li><li>Browserify 只支持 CommonJS 模块规范，不支持 AMD 和 ES6 模块规范，这意味旧的 AMD 模块和将来的 ES6 模块不能使用。</li></ul><p>基于以上几点，Browserify 并不是一个理想的选择。那么 webpack 是否解决了以上的几个问题呢? 废话，不然介绍它干嘛。那么下面章节我们用实战的方式来说明 webpack 是怎么解决上述的问题的。</p><h2 id="上手先搞一个简单的-SPA-应用"><a href="#上手先搞一个简单的-SPA-应用" class="headerlink" title="上手先搞一个简单的 SPA 应用"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#上手先搞一个简单的-spa-应用" target="_blank" rel="noopener"></a>上手先搞一个简单的 SPA 应用</h2><p>一上来步子太大容易扯到蛋，让我们先弄个最简单的 webpack 配置来热一下身。</p><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#安装-nodejs" target="_blank" rel="noopener"></a>安装 Node.js</h3><p>webpack 是基于我大 Node.js 的打包工具，上来第一件事自然是先安装 Node.js 了，<a href="https://nodejs.org/" target="_blank" rel="noopener">传送门 -&gt;</a>。</p><h3 id="初始化一个项目"><a href="#初始化一个项目" class="headerlink" title="初始化一个项目"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#初始化一个项目" target="_blank" rel="noopener"></a>初始化一个项目</h3><p>我们先随便找个地方，建一个文件夹叫 <code>simple</code>， 然后在这里面搭项目。完成品在 <a href="https://github.com/fenivana/webpack-and-spa-guide/blob/master/examples/simple" target="_blank" rel="noopener">examples/simple</a> 目录，大家搞的时候可以参照一下。我们先看一下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── dist                      打包输出目录，只需部署这个目录到生产环境</span><br><span class="line">├── package.json              项目配置信息</span><br><span class="line">├── node_modules              npm 安装的依赖包都在这里面</span><br><span class="line">├── src                       我们的源代码</span><br><span class="line">│   ├── components            可以复用的模块放在这里面</span><br><span class="line">│   ├── index.html            入口 html</span><br><span class="line">│   ├── index.js              入口 js</span><br><span class="line">│   ├── shared                公共函数库</span><br><span class="line">│   └── views                 页面放这里</span><br><span class="line">└── webpack.config.js         webpack 配置文件</span><br></pre></td></tr></table></figure><p>打开命令行窗口，<code>cd</code> 到刚才建的 simple 目录。然后执行这个命令初始化项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>命令行会要你输入一些配置信息，我们这里一路按回车下去，生成一个默认的项目配置文件 <code>package.json</code>。</p><h3 id="给项目加上语法报错和代码规范检查"><a href="#给项目加上语法报错和代码规范检查" class="headerlink" title="给项目加上语法报错和代码规范检查"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#给项目加上语法报错和代码规范检查" target="_blank" rel="noopener"></a>给项目加上语法报错和代码规范检查</h3><p>我们安装 <a href="http://eslint.org/" target="_blank" rel="noopener">eslint</a>， 用来检查语法报错，当我们书写 js 时，有错误的地方会出现提示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint eslint-config-enough babel-eslint eslint-loader --save-dev</span><br></pre></td></tr></table></figure><p><code>npm install</code> 可以一条命令同时安装多个包，包之间用空格分隔。包会被安装进 <code>node_modules</code> 目录中。</p><p><code>--save-dev</code> 会把安装的包和版本号记录到 <code>package.json</code> 中的 <code>devDependencies</code> 对象中，还有一个 <code>--save</code>， 会记录到 <code>dependencies</code> 对象中，它们的区别，我们可以先简单的理解为打包工具和测试工具用到的包使用 <code>--save-dev</code> 存到 <code>devDependencies</code>， 比如 eslint、webpack。浏览器中执行的 js 用到的包存到 <code>dependencies</code>， 比如 jQuery 等。那么它们用来干嘛的？</p><p>因为有些 npm 包安装是需要编译的，那么导致 windows / mac /linux 上编译出的可执行文件是不同的，也就是无法通用，因此我们在提交代码到 git 上去的时候，一般都会在 <code>.gitignore</code> 里指定忽略 node_modules 目录和里面的文件，这样其他人从 git 上拉下来的项目是没有 node_modules 目录的，这时我们需要运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>它会读取 <code>package.json</code> 中的 <code>devDependencies</code> 和 <code>dependencies</code> 字段，把记录的包的相应版本下载下来。</p><p>这里 <a href="https://github.com/fenivana/eslint-config-enough" target="_blank" rel="noopener">eslint-config-enough</a> 是配置文件，它规定了代码规范，要使它生效，我们要在 <code>package.json</code> 中添加内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;eslintConfig&quot;: &#123;</span><br><span class="line">    &quot;extends&quot;: &quot;enough&quot;,</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">      &quot;browser&quot;: true,</span><br><span class="line">      &quot;node&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业界最有名的语法规范是 <a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">airbnb</a> 出品的，但它规定的太死板了，比如不允许使用 <code>for-of</code> 和 <code>for-in</code> 等。感兴趣的同学可以参照 <a href="https://www.npmjs.com/package/eslint-config-airbnb" target="_blank" rel="noopener">这里</a> 安装使用。</p><p><a href="https://github.com/babel/babel-eslint" target="_blank" rel="noopener">babel-eslint</a> 是 <code>eslint-config-enough</code> 依赖的语法解析库，替代 eslint 默认的解析库以支持还未标准化的语法。比如 <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">import()</a>。</p><p><a href="https://github.com/MoOx/eslint-loader" target="_blank" rel="noopener">eslint-loader</a> 用于在 webpack 编译的时候检查代码，如果有错误，webpack 会报错。</p><p>项目里安装了 eslint 还没用，我们的 IDE 和编辑器也得要装 eslint 插件支持它。</p><p><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a> 需要安装 <a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint" target="_blank" rel="noopener">ESLint 扩展</a></p><p><a href="https://atom.io/" target="_blank" rel="noopener">atom</a> 需要安装 <a href="https://atom.io/packages/linter" target="_blank" rel="noopener">linter</a> 和 <a href="https://atom.io/packages/linter-eslint" target="_blank" rel="noopener">linter-eslint</a> 这两个插件，装好后重启生效。</p><p><a href="https://www.jetbrains.com/webstorm/" target="_blank" rel="noopener">WebStorm</a> 需要在设置中打开 eslint 开关：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-c0a131357700b656.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure> <h3 id="写几个页面"><a href="#写几个页面" class="headerlink" title="写几个页面"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#写几个页面" target="_blank" rel="noopener"></a>写几个页面</h3><p>我们写一个最简单的 SPA 应用来介绍 SPA 应用的内部工作原理。首先，建立 src/index.html 文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>它是一个空白页面，注意这里我们不需要自己写 <code>&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</code>， 因为打包后的文件名和路径可能会变，所以我们用 webpack 插件帮我们自动加上。</p><p>src/index.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 引入 router</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line"></span><br><span class="line">// 启动 router</span><br><span class="line">router.start()</span><br></pre></td></tr></table></figure><p>src/router.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 引入页面文件</span><br><span class="line">import foo from &apos;./views/foo&apos;</span><br><span class="line">import bar from &apos;./views/bar&apos;</span><br><span class="line"></span><br><span class="line">const routes = &#123;</span><br><span class="line">  &apos;/foo&apos;: foo,</span><br><span class="line">  &apos;/bar&apos;: bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Router 类，用来控制页面根据当前 URL 切换</span><br><span class="line">class Router &#123;</span><br><span class="line">  start() &#123;</span><br><span class="line">    // 点击浏览器后退 / 前进按钮时会触发 window.onpopstate 事件，我们在这时切换到相应页面</span><br><span class="line">    // https://developer.mozilla.org/en-US/docs/Web/Events/popstate</span><br><span class="line">    window.addEventListener(&apos;popstate&apos;, () =&gt; &#123;</span><br><span class="line">      this.load(location.pathname)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 打开页面时加载当前页面</span><br><span class="line">    this.load(location.pathname)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 前往 path，变更地址栏 URL，并加载相应页面</span><br><span class="line">  go(path) &#123;</span><br><span class="line">    // 变更地址栏 URL</span><br><span class="line">    history.pushState(&#123;&#125;, &apos;&apos;, path)</span><br><span class="line">    // 加载页面</span><br><span class="line">    this.load(path)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 加载 path 路径的页面</span><br><span class="line">  load(path) &#123;</span><br><span class="line">    // 首页</span><br><span class="line">    if (path === &apos;/&apos;) path = &apos;/foo&apos;</span><br><span class="line">    // 创建页面实例</span><br><span class="line">    const view = new routes[path]()</span><br><span class="line">    // 调用页面方法，把页面加载到 document.body 中</span><br><span class="line">    view.mount(document.body)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 导出 router 实例</span><br><span class="line">export default new Router()</span><br></pre></td></tr></table></figure><p>src/views/foo/index.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 引入 router</span><br><span class="line">import router from &apos;../../router&apos;</span><br><span class="line"></span><br><span class="line">// 引入 html 模板，会被作为字符串引入</span><br><span class="line">import template from &apos;./index.html&apos;</span><br><span class="line"></span><br><span class="line">// 引入 css, 会生成 &lt;style&gt; 块插入到 &lt;head&gt; 头中</span><br><span class="line">import &apos;./style.css&apos;</span><br><span class="line"></span><br><span class="line">// 导出类</span><br><span class="line">export default class &#123;</span><br><span class="line">  mount(container) &#123;</span><br><span class="line">    document.title = &apos;foo&apos;</span><br><span class="line">    container.innerHTML = template</span><br><span class="line">    container.querySelector(&apos;.foo__gobar&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">      // 调用 router.go 方法加载 /bar 页面</span><br><span class="line">      router.go(&apos;/bar&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src/views/bar/index.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 引入 router</span><br><span class="line">import router from &apos;../../router&apos;</span><br><span class="line"></span><br><span class="line">// 引入 html 模板，会被作为字符串引入</span><br><span class="line">import template from &apos;./index.html&apos;</span><br><span class="line"></span><br><span class="line">// 引入 css, 会生成 &lt;style&gt; 块插入到 &lt;head&gt; 头中</span><br><span class="line">import &apos;./style.css&apos;</span><br><span class="line"></span><br><span class="line">// 导出类</span><br><span class="line">export default class &#123;</span><br><span class="line">  mount(container) &#123;</span><br><span class="line">    document.title = &apos;bar&apos;</span><br><span class="line">    container.innerHTML = template</span><br><span class="line">    container.querySelector(&apos;.bar__gofoo&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">      // 调用 router.go 方法加载 /foo 页面</span><br><span class="line">      router.go(&apos;/foo&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助 webpack 插件，我们可以 <code>import</code> html, css 等其他格式的文件，文本类的文件会被储存为变量打包进 js 文件，其他二进制类的文件，比如图片，可以自己配置，小图片作为 <a href="https://en.wikipedia.org/wiki/Data_URI_scheme" target="_blank" rel="noopener">Data URI</a> 打包进 js 文件，大文件打包为单独文件，我们稍后再讲这块。</p><p>其他的 src 目录下的文件大家自己浏览，拷贝一份到自己的工作目录，等会打包时会用到。</p><p>页面代码这样就差不多搞定了，接下来我们进入 webpack 的安装和配置阶段。现在我们还没有讲 webpack 配置所以页面还无法访问，等会弄好 webpack 配置后再看页面实际效果。</p><h3 id="安装-webpack-和-Babel"><a href="#安装-webpack-和-Babel" class="headerlink" title="安装 webpack 和 Babel"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#安装-webpack-和-babel" target="_blank" rel="noopener"></a>安装 webpack 和 Babel</h3><p>我们把 webpack 和它的插件安装到项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli webpack-serve html-webpack-plugin html-loader css-loader style-loader file-loader url-loader --save-dev</span><br></pre></td></tr></table></figure><p><a href="https://github.com/webpack/webpack" target="_blank" rel="noopener">webpack</a> 即 webpack 核心库。它提供了很多 <a href="https://webpack.js.org/api/node/" target="_blank" rel="noopener">API</a>, 通过 Node.js 脚本中 <code>require(&#39;webpack&#39;)</code> 的方式来使用 webpack。</p><p><a href="https://github.com/webpack/webpack-cli" target="_blank" rel="noopener">webpack-cli</a> 是 webpack 的命令行工具。让我们可以不用写打包脚本，只需配置打包配置文件，然后在命令行输入 <code>webpack-cli --config webpack.config.js</code> 来使用 webpack, 简单很多。webpack 4 之前命令行工具是集成在 webpack 包中的，4.0 开始 webpack 包本身不再集成 cli。</p><p><a href="https://github.com/webpack-contrib/webpack-serve" target="_blank" rel="noopener">webpack-serve</a> 是 webpack 提供的用来开发调试的服务器，让你可以用 <a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a> 这样的 url 打开页面来调试，有了它就不用配置 <a href="https://nginx.org/en/" target="_blank" rel="noopener">nginx</a> 了，方便很多。</p><p><a href="https://github.com/ampedandwired/html-webpack-plugin" target="_blank" rel="noopener">html-webpack-plugin</a>, <a href="https://github.com/webpack/html-loader" target="_blank" rel="noopener">html-loader</a>, <a href="https://github.com/webpack/css-loader" target="_blank" rel="noopener">css-loader</a>, <a href="https://github.com/webpack/style-loader" target="_blank" rel="noopener">style-loader</a> 等看名字就知道是打包 html 文件，css 文件的插件，大家在这里可能会有疑问，<code>html-webpack-plugin</code> 和 <code>html-loader</code> 有什么区别，<code>css-loader</code> 和 <code>style-loader</code> 有什么区别，我们等会看配置文件的时候再讲。</p><p><a href="https://github.com/webpack/file-loader" target="_blank" rel="noopener">file-loader</a> 和 <a href="https://github.com/webpack/url-loader" target="_blank" rel="noopener">url-loader</a> 是打包二进制文件的插件，具体也在配置文件章节讲解。</p><p>接下来，为了能让不支持 ES6 的浏览器 （比如 IE) 也能照常运行，我们需要安装 <a href="http://babeljs.io/" target="_blank" rel="noopener">babel</a>, 它会把我们写的 ES6 源代码转化成 ES5，这样我们源代码写 ES6，打包时生成 ES5。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-core babel-preset-env babel-loader --save-dev</span><br></pre></td></tr></table></figure><p>这里 <code>babel-core</code> 顾名思义是 babel 的核心编译器。<a href="https://babeljs.io/docs/plugins/preset-env/" target="_blank" rel="noopener">babel-preset-env</a> 是一个配置文件，我们可以使用这个配置文件转换 <a href="http://exploringjs.com/es6/" target="_blank" rel="noopener">ES2015</a>/<a href="https://leanpub.com/exploring-es2016-es2017/read" target="_blank" rel="noopener">ES2016</a>/<a href="http://www.2ality.com/2016/02/ecmascript-2017.html" target="_blank" rel="noopener">ES2017</a> 到 ES5，是的，不只 ES6 哦。babel 还有 <a href="http://babeljs.io/docs/plugins/" target="_blank" rel="noopener">其他配置文件</a>。</p><p>光安装了 <code>babel-preset-env</code>，在打包时是不会生效的，需要在 <code>package.json</code> 加入 <code>babel</code> 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;babel&quot;: &#123;</span><br><span class="line">    &quot;presets&quot;: [&quot;env&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包时 babel 会读取 <code>package.json</code> 中 <code>babel</code> 字段的内容，然后执行相应的转换。</p><p><a href="https://github.com/babel/babel-loader" target="_blank" rel="noopener">babel-loader</a> 是 webpack 的插件，我们下面章节再说。</p><h3 id="配置-webpack"><a href="#配置-webpack" class="headerlink" title="配置 webpack"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#配置-webpack" target="_blank" rel="noopener"></a>配置 webpack</h3><p>包都装好了，接下来总算可以进入正题了。我们来创建 webpack 配置文件 <code>webpack.config.js</code>，注意这个文件是在 node.js 中运行的，因此不支持 ES6 的 <code>import</code> 语法。我们来看文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">const history = require(&apos;connect-history-api-fallback&apos;)</span><br><span class="line">const convert = require(&apos;koa-connect&apos;)</span><br><span class="line"></span><br><span class="line">// 使用 WEBPACK_SERVE 环境变量检测当前是否是在 webpack-server 启动的开发环境中</span><br><span class="line">const dev = Boolean(process.env.WEBPACK_SERVE)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  /*</span><br><span class="line">  webpack 执行模式</span><br><span class="line">  development：开发环境，它会在配置文件中插入调试相关的选项，比如 moduleId 使用文件路径方便调试</span><br><span class="line">  production：生产环境，webpack 会将代码做压缩等优化</span><br><span class="line">  */</span><br><span class="line">  mode: dev ? &apos;development&apos; : &apos;production&apos;,</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  配置 source map</span><br><span class="line">  开发模式下使用 cheap-module-eval-source-map, 生成的 source map 能和源码每行对应，方便打断点调试</span><br><span class="line">  生产模式下使用 hidden-source-map, 生成独立的 source map 文件，并且不在 js 文件中插入 source map 路径，用于在 error report 工具中查看 （比如 Sentry)</span><br><span class="line">  */</span><br><span class="line">  devtool: dev ? &apos;cheap-module-eval-source-map&apos; : &apos;hidden-source-map&apos;,</span><br><span class="line"></span><br><span class="line">  // 配置页面入口 js 文件</span><br><span class="line">  entry: &apos;./src/index.js&apos;,</span><br><span class="line"></span><br><span class="line">  // 配置打包输出相关</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 打包输出目录</span><br><span class="line">    path: resolve(__dirname, &apos;dist&apos;),</span><br><span class="line"></span><br><span class="line">    // 入口 js 的打包输出文件名</span><br><span class="line">    filename: &apos;index.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  module: &#123;</span><br><span class="line">    /*</span><br><span class="line">    配置各种类型文件的加载器，称之为 loader</span><br><span class="line">    webpack 当遇到 import ... 时，会调用这里配置的 loader 对引用的文件进行编译</span><br><span class="line">    */</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        /*</span><br><span class="line">        使用 babel 编译 ES6 / ES7 / ES8 为 ES5 代码</span><br><span class="line">        使用正则表达式匹配后缀名为 .js 的文件</span><br><span class="line">        */</span><br><span class="line">        test: /\.js$/,</span><br><span class="line"></span><br><span class="line">        // 排除 node_modules 目录下的文件，npm 安装的包不需要编译</span><br><span class="line">        exclude: /node_modules/,</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        use 指定该文件的 loader, 值可以是字符串或者数组。</span><br><span class="line">        这里先使用 eslint-loader 处理，返回的结果交给 babel-loader 处理。loader 的处理顺序是从最后一个到第一个。</span><br><span class="line">        eslint-loader 用来检查代码，如果有错误，编译的时候会报错。</span><br><span class="line">        babel-loader 用来编译 js 文件。</span><br><span class="line">        */</span><br><span class="line">        use: [&apos;babel-loader&apos;, &apos;eslint-loader&apos;]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        // 匹配 html 文件</span><br><span class="line">        test: /\.html$/,</span><br><span class="line">        /*</span><br><span class="line">        使用 html-loader, 将 html 内容存为 js 字符串，比如当遇到</span><br><span class="line">        import htmlString from &apos;./template.html&apos;;</span><br><span class="line">        template.html 的文件内容会被转成一个 js 字符串，合并到 js 文件里。</span><br><span class="line">        */</span><br><span class="line">        use: &apos;html-loader&apos;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        // 匹配 css 文件</span><br><span class="line">        test: /\.css$/,</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        先使用 css-loader 处理，返回的结果交给 style-loader 处理。</span><br><span class="line">        css-loader 将 css 内容存为 js 字符串，并且会把 background, @font-face 等引用的图片，</span><br><span class="line">        字体文件交给指定的 loader 打包，类似上面的 html-loader, 用什么 loader 同样在 loaders 对象中定义，等会下面就会看到。</span><br><span class="line">        */</span><br><span class="line">        use: [&apos;style-loader&apos;, &apos;css-loader&apos;]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        /*</span><br><span class="line">        匹配各种格式的图片和字体文件</span><br><span class="line">        上面 html-loader 会把 html 中 &lt;img&gt; 标签的图片解析出来，文件名匹配到这里的 test 的正则表达式，</span><br><span class="line">        css-loader 引用的图片和字体同样会匹配到这里的 test 条件</span><br><span class="line">        */</span><br><span class="line">        test: /\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\?.+)?$/,</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        使用 url-loader, 它接受一个 limit 参数，单位为字节(byte)</span><br><span class="line"></span><br><span class="line">        当文件体积小于 limit 时，url-loader 把文件转为 Data URI 的格式内联到引用的地方</span><br><span class="line">        当文件大于 limit 时，url-loader 会调用 file-loader, 把文件储存到输出目录，并把引用的文件路径改写成输出后的路径</span><br><span class="line"></span><br><span class="line">        比如 views/foo/index.html 中</span><br><span class="line">        &lt;img src=&quot;smallpic.png&quot;&gt;</span><br><span class="line">        会被编译成</span><br><span class="line">        &lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAA...&quot;&gt;</span><br><span class="line"></span><br><span class="line">        而</span><br><span class="line">        &lt;img src=&quot;largepic.png&quot;&gt;</span><br><span class="line">        会被编译成</span><br><span class="line">        &lt;img src=&quot;/f78661bef717cf2cc2c2e5158f196384.png&quot;&gt;</span><br><span class="line">        */</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  配置 webpack 插件</span><br><span class="line">  plugin 和 loader 的区别是，loader 是在 import 时根据不同的文件名，匹配不同的 loader 对这个文件做处理，</span><br><span class="line">  而 plugin, 关注的不是文件的格式，而是在编译的各个阶段，会触发不同的事件，让你可以干预每个编译阶段。</span><br><span class="line">  */</span><br><span class="line">  plugins: [</span><br><span class="line">    /*</span><br><span class="line">    html-webpack-plugin 用来打包入口 html 文件</span><br><span class="line">    entry 配置的入口是 js 文件，webpack 以 js 文件为入口，遇到 import, 用配置的 loader 加载引入文件</span><br><span class="line">    但作为浏览器打开的入口 html, 是引用入口 js 的文件，它在整个编译过程的外面，</span><br><span class="line">    所以，我们需要 html-webpack-plugin 来打包作为入口的 html 文件</span><br><span class="line">    */</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      /*</span><br><span class="line">      template 参数指定入口 html 文件路径，插件会把这个文件交给 webpack 去编译，</span><br><span class="line">      webpack 按照正常流程，找到 loaders 中 test 条件匹配的 loader 来编译，那么这里 html-loader 就是匹配的 loader</span><br><span class="line">      html-loader 编译后产生的字符串，会由 html-webpack-plugin 储存为 html 文件到输出目录，默认文件名为 index.html</span><br><span class="line">      可以通过 filename 参数指定输出的文件名</span><br><span class="line">      html-webpack-plugin 也可以不指定 template 参数，它会使用默认的 html 模板。</span><br><span class="line">      */</span><br><span class="line">      template: &apos;./src/index.html&apos;,</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">      因为和 webpack 4 的兼容性问题，chunksSortMode 参数需要设置为 none</span><br><span class="line">      https://github.com/jantimon/html-webpack-plugin/issues/870</span><br><span class="line">      */</span><br><span class="line">      chunksSortMode: &apos;none&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">配置开发时用的服务器，让你可以用 http://127.0.0.1:8080/ 这样的 url 打开页面来调试</span><br><span class="line">并且带有热更新的功能，打代码时保存一下文件，浏览器会自动刷新。比 nginx 方便很多</span><br><span class="line">如果是修改 css, 甚至不需要刷新页面，直接生效。这让像弹框这种需要点击交互后才会出来的东西调试起来方便很多。</span><br><span class="line"></span><br><span class="line">因为 webpack-cli 无法正确识别 serve 选项，使用 webpack-cli 执行打包时会报错。</span><br><span class="line">因此我们在这里判断一下，仅当使用 webpack-serve 时插入 serve 选项。</span><br><span class="line">issue：https://github.com/webpack-contrib/webpack-serve/issues/19</span><br><span class="line">*/</span><br><span class="line">if (dev) &#123;</span><br><span class="line">  module.exports.serve = &#123;</span><br><span class="line">    // 配置监听端口，默认值 8080</span><br><span class="line">    port: 8080,</span><br><span class="line"></span><br><span class="line">    // add: 用来给服务器的 koa 实例注入 middleware 增加功能</span><br><span class="line">    add: app =&gt; &#123;</span><br><span class="line">      /*</span><br><span class="line">      配置 SPA 入口</span><br><span class="line"></span><br><span class="line">      SPA 的入口是一个统一的 html 文件，比如</span><br><span class="line">      http://localhost:8080/foo</span><br><span class="line">      我们要返回给它</span><br><span class="line">      http://localhost:8080/index.html</span><br><span class="line">      这个文件</span><br><span class="line">      */</span><br><span class="line">      app.use(convert(history()))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="走一个"><a href="#走一个" class="headerlink" title="走一个"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#走一个" target="_blank" rel="noopener"></a>走一个</h3><p>配置 OK 了，接下来我们就运行一下吧。我们先试一下开发环境用的 <code>webpack-serve</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/webpack-serve webpack.config.js</span><br></pre></td></tr></table></figure><p>执行时需要指定配置文件。</p><p>上面的命令适用于 Mac / Linux 等 * nix 系统，也适用于 Windows 上的 PowerShell 和 bash/zsh 环境（<a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" target="_blank" rel="noopener">Windows Subsystem for Linux</a>, <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git Bash</a>、<a href="http://babun.github.io/" target="_blank" rel="noopener">Babun</a>、<a href="http://msys2.github.io/" target="_blank" rel="noopener">MSYS2</a> 等）。安利一下 Windows 同学使用 <a href="https://www.microsoft.com/store/p/ubuntu/9nblggh4msv6" target="_blank" rel="noopener">Ubuntu on Windows</a>，可以避免很多跨平台的问题，比如设置环境变量。</p><p>如果使用 Windows 的 cmd.exe，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules\.bin\webpack-serve webpack.config.js</span><br></pre></td></tr></table></figure><p>npm 会把包的可执行文件安装到 <code>./node_modules/.bin/</code> 目录下，所以我们要在这个目录下执行命令。</p><p>命令执行后，控制台显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">｢wdm｣: Compiled successfully。</span><br></pre></td></tr></table></figure><p>这就代表编译成功了，我们可以在浏览器打开 <code>http://localhost:8080/</code> 看看效果。如果有报错，那可能是什么地方没弄对？请自己仔细检查一下～</p><p>我们可以随意更改一下 src 目录下的源代码，保存后，浏览器里的页面应该很快会有相应变化。</p><p>要退出编译，按 <code>ctrl+c</code>。</p><p>开发环境编译试过之后，我们试试看编译生产环境的代码，命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/webpack-cli</span><br></pre></td></tr></table></figure><p>不需要指定配置文件，默认读取 webpack.config.js</p><p>执行脚本的命令有点麻烦，因此，我们可以利用 npm，把命令写在 <code>package.json</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-serve webpack.config.js&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack-cli&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>package.json</code> 中的 <code>scripts</code> 对象，可以用来写一些脚本命令，命令不需要前缀目录 <code>./node_modules/.bin/</code>，npm 会自动寻找该目录下的命令。我们可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>来启动开发环境。</p><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>来打包生产环境的代码。</p><h2 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#进阶配置" target="_blank" rel="noopener"></a>进阶配置</h2><p>上面的项目虽然可以跑起来了，但有几个点我们还没有考虑到：</p><ul><li>设置静态资源的 url 路径前缀</li><li>各个页面分开打包</li><li>第三方库和业务代码分开打包</li><li>输出的 entry 文件加上 hash</li><li>开发环境关闭 performance.hints</li><li>配置 favicon</li><li>开发环境允许其他电脑访问</li><li>打包时自定义部分参数</li><li>webpack-serve 处理路径带后缀名的文件的特殊规则</li><li>代码中插入环境变量</li><li>简化 import 路径</li><li>优化 babel 编译后的代码性能</li><li>使用 webpack 自带的 ES6 模块处理功能</li><li>使用 autoprefixer 自动创建 css 的 vendor prefixes</li></ul><p>那么，让我们在上面的配置的基础上继续完善，下面的代码我们只写出改变的部分。代码在 <a href="https://github.com/fenivana/webpack-and-spa-guide/blob/master/examples/advanced" target="_blank" rel="noopener">examples/advanced</a> 目录。</p><h3 id="设置静态资源的-url-路径前缀"><a href="#设置静态资源的-url-路径前缀" class="headerlink" title="设置静态资源的 url 路径前缀"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#设置静态资源的-url-路径前缀" target="_blank" rel="noopener"></a>设置静态资源的 url 路径前缀</h3><p>现在我们的资源文件的 url 直接在根目录，比如 <code>http://127.0.0.1:8080/index.js</code>， 这样做缓存控制和 CDN 不是很方便，因此我们给资源文件的 url 加一个前缀，比如 <code>http://127.0.0.1:8080/assets/index.js</code>. 我们来修改一下 webpack 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: &apos;/assets/&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>webpack-serve</code> 也需要修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (dev) &#123;</span><br><span class="line">  module.exports.serve = &#123;</span><br><span class="line">    port: 8080,</span><br><span class="line">    host: &apos;0.0.0.0&apos;,</span><br><span class="line">    dev: &#123;</span><br><span class="line">      /*</span><br><span class="line">      指定 webpack-dev-middleware 的 publicpath</span><br><span class="line">      一般情况下与 output.publicPath 保持一致（除非 output.publicPath 使用的是相对路径）</span><br><span class="line">      https://github.com/webpack/webpack-dev-middleware#publicpath</span><br><span class="line">      */</span><br><span class="line">      publicPath: &apos;/assets/&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    add: app =&gt; &#123;</span><br><span class="line">      app.use(convert(history(&#123;</span><br><span class="line">        index: &apos;/assets/&apos; // index.html 文件在 /assets/ 路径下</span><br><span class="line">      &#125;)))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="各个页面分开打包"><a href="#各个页面分开打包" class="headerlink" title="各个页面分开打包"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#各个页面分开打包" target="_blank" rel="noopener"></a>各个页面分开打包</h3><p>这样浏览器只需加载当前页面所需的代码。</p><p>webpack 可以使用异步加载文件的方式引用模块，我们使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">async</a>/ <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener">await</a> 和 <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">dynamic import</a> 来实现：</p><p>src/router.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 将 async/await 转换成 ES5 代码后需要这个运行时库来支持</span><br><span class="line">import &apos;regenerator-runtime/runtime&apos;</span><br><span class="line"></span><br><span class="line">const routes = &#123;</span><br><span class="line">  // import() 返回 promise</span><br><span class="line">  &apos;/foo&apos;: () =&gt; import(&apos;./views/foo&apos;),</span><br><span class="line">  &apos;/bar.do&apos;: () =&gt; import(&apos;./views/bar.do&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Router &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  // 加载 path 路径的页面</span><br><span class="line">  // 使用 async/await 语法</span><br><span class="line">  async load(path) &#123;</span><br><span class="line">    // 首页</span><br><span class="line">    if (path === &apos;/&apos;) path = &apos;/foo&apos;</span><br><span class="line"></span><br><span class="line">    // 动态加载页面</span><br><span class="line">    const View = (await routes[path]()).default</span><br><span class="line"></span><br><span class="line">    // 创建页面实例</span><br><span class="line">    const view = new View()</span><br><span class="line"></span><br><span class="line">    // 调用页面方法，把页面加载到 document.body 中</span><br><span class="line">    view.mount(document.body)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就不需要在开头把所有页面文件都 import 进来了。</p><p><a href="https://github.com/facebook/regenerator/tree/master/packages/regenerator-runtime" target="_blank" rel="noopener">regenerator-runtime</a> 是 <a href="https://github.com/facebook/regenerator" target="_blank" rel="noopener">regenerator</a> 的运行时库。Babel 通过插件 <a href="https://babeljs.io/docs/plugins/transform-regenerator" target="_blank" rel="noopener">transform-regenerator</a> 使用 <code>regenerator</code> 将 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener">generator</a>函数和 async/await 语法转换成 ES5 语法后，需要运行时库才能正确执行。</p><p>另外因为 <code>import()</code> 还没有正式进入标准，需要使用 <a href="https://babeljs.io/docs/plugins/syntax-dynamic-import/" target="_blank" rel="noopener">syntax-dynamic-import</a> 来解析此语法。 我们可以安装 <a href="https://babeljs.io/docs/plugins/preset-stage-2/" target="_blank" rel="noopener">babel-preset-stage-2</a>，它包含了 <code>import()</code> 和其他 stage 2 的语法支持。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install regenerator-runtime babel-preset-stage-2 --save-dev</span><br></pre></td></tr></table></figure><p><code>package.json</code> 改一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;babel&quot;: &#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">      &quot;env&quot;,</span><br><span class="line">      &quot;stage-2&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 webpack 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    /*</span><br><span class="line">    代码中引用的文件（js、css、图片等）会根据配置合并为一个或多个包，我们称一个包为 chunk。</span><br><span class="line">    每个 chunk 包含多个 modules。无论是否是 js，webpack 都将引入的文件视为一个 module。</span><br><span class="line">    chunkFilename 用来配置这个 chunk 输出的文件名。</span><br><span class="line"></span><br><span class="line">    [chunkhash]：这个 chunk 的 hash 值，文件发生变化时该值也会变。使用 [chunkhash] 作为文件名可以防止浏览器读取旧的缓存文件。</span><br><span class="line"></span><br><span class="line">    还有一个占位符 [id]，编译时每个 chunk 会有一个id。</span><br><span class="line">    我们在这里不使用它，因为这个 id 是个递增的数字，增加或减少一个chunk，都可能导致其他 chunk 的 id 发生改变，导致缓存失效。</span><br><span class="line">    */</span><br><span class="line">    chunkFilename: &apos;[chunkhash].js&apos;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三方库和业务代码分开打包"><a href="#第三方库和业务代码分开打包" class="headerlink" title="第三方库和业务代码分开打包"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#第三方库和业务代码分开打包" target="_blank" rel="noopener"></a>第三方库和业务代码分开打包</h3><p>这样更新业务代码时可以借助浏览器缓存，用户不需要重新下载没有发生变化的第三方库。 Webpack 4 最大的改进便是自动拆分 chunk, 如果同时满足下列条件，chunk 就会被拆分：</p><ul><li>新的 chunk 能被复用，或者模块是来自 node_modules 目录</li><li>新的 chunk 大于 30Kb(min+gz 压缩前）</li><li>按需加载 chunk 的并发请求数量小于等于 5 个</li><li>页面初始加载时的并发请求数量小于等于 3 个</li></ul><p>一般情况只需配置这几个参数即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    使用文件路径的 hash 作为 moduleId。</span><br><span class="line">    虽然我们使用 [chunkhash] 作为 chunk 的输出名，但仍然不够。</span><br><span class="line">    因为 chunk 内部的每个 module 都有一个 id，webpack 默认使用递增的数字作为 moduleId。</span><br><span class="line">    如果引入了一个新文件或删掉一个文件，可能会导致其他文件的 moduleId 也发生改变，</span><br><span class="line">    那么受影响的 module 所在的 chunk 的 [chunkhash] 就会发生改变，导致缓存失效。</span><br><span class="line">    因此使用文件路径的 hash 作为 moduleId 来避免这个问题。</span><br><span class="line">    */</span><br><span class="line">    new webpack.HashedModuleIdsPlugin()</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    /*</span><br><span class="line">    上面提到 chunkFilename 指定了 chunk 打包输出的名字，那么文件名存在哪里了呢？</span><br><span class="line">    它就存在引用它的文件中。这意味着一个 chunk 文件名发生改变，会导致引用这个 chunk 文件也发生改变。</span><br><span class="line"></span><br><span class="line">    runtimeChunk 设置为 true, webpack 就会把 chunk 文件名全部存到一个单独的 chunk 中，</span><br><span class="line">    这样更新一个文件只会影响到它所在的 chunk 和 runtimeChunk，避免了引用这个 chunk 的文件也发生改变。</span><br><span class="line">    */</span><br><span class="line">    runtimeChunk: true,</span><br><span class="line"></span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      /*</span><br><span class="line">      默认 entry 的 chunk 不会被拆分</span><br><span class="line">      因为我们使用了 html-webpack-plugin 来动态插入 &lt;script&gt; 标签，entry 被拆成多个 chunk 也能自动被插入到 html 中，</span><br><span class="line">      所以我们可以配置成 all, 把 entry chunk 也拆分了</span><br><span class="line">      */</span><br><span class="line">      chunks: &apos;all&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack 4 支持更多的手动优化，详见： <a href="https://gist.github.com/sokra/1522d586b8e5c0f5072d7565c2bee693" target="_blank" rel="noopener">https://gist.github.com/sokra/1522d586b8e5c0f5072d7565c2bee693</a></p><p>但正如 webpack 文档中所说，默认配置已经足够优化，在没有测试的情况下不要盲目手动优化。</p><h3 id="输出的-entry-文件加上-hash"><a href="#输出的-entry-文件加上-hash" class="headerlink" title="输出的 entry 文件加上 hash"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#输出的-entry-文件加上-hash" target="_blank" rel="noopener"></a>输出的 entry 文件加上 hash</h3><p>上面我们提到了 <code>chunkFilename</code> 使用 <code>[chunkhash]</code> 防止浏览器读取错误缓存，那么 entry 同样需要加上 hash。 但使用 <code>webpack-serve</code> 启动开发环境时，entry 文件是没有 <code>[chunkhash]</code> 的，用了会报错。 因此我们只在执行 <code>webpack-cli</code> 时使用 <code>[chunkhash]</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: dev ? &apos;[name].js&apos; : &apos;[chunkhash].js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用了 <code>[name]</code> 占位符。解释它之前我们先了解一下 <code>entry</code> 的完整定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    NAME: [FILE1, FILE2, ...]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以定义多个 entry 文件，比如你的项目有多个 html 入口文件，每个 html 对应一个或多个 entry 文件。 然后每个 entry 可以定义由多个 module 组成，这些 module 会依次执行。 在 webpack 4 之前，这是很有用的功能，比如之前提到的第三方库和业务代码分开打包，在以前，我们需要这么配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry &#123;</span><br><span class="line">    main: &apos;./src/index.js&apos;,</span><br><span class="line">    vendor: [&apos;jquery&apos;, &apos;lodash&apos;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>entry 引用文件的规则和 <code>import</code> 是一样的，会寻找 <code>node_modules</code> 里的包。然后结合 <code>CommonsChunkPlugin</code> 把 vendor 定义的 module 从业务代码分离出来打包成一个单独的 chunk。 如果 entry 是一个 module，我们可以不使用数组的形式。</p><p>在 simple 项目中，我们配置了 <code>entry: &#39;./src/index.js&#39;</code>，这是最简单的形式，转换成完整的写法就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: [&apos;./src/index.js&apos;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack 会给这个 entry 指定名字为 <code>main</code>。</p><p>看到这应该知道 <code>[name]</code> 的意思了吧？它就是 entry 的名字。</p><p>有人可能注意到官网文档中还有一个 <code>[hash]</code> 占位符，这个 hash 是整个编译过程产生的一个总的 hash 值，而不是单个文件的 hash 值，项目中任何一个文件的改动，都会造成这个 hash 值的改变。<code>[hash]</code> 占位符是始终存在的，但我们不希望修改一个文件导致所有输出的文件 hash 都改变，这样就无法利用浏览器缓存了。因此这个 <code>[hash]</code> 意义不大。</p><h3 id="开发环境关闭-performance-hints"><a href="#开发环境关闭-performance-hints" class="headerlink" title="开发环境关闭 performance.hints"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#开发环境关闭-performancehints" target="_blank" rel="noopener"></a>开发环境关闭 performance.hints</h3><p>我们注意到运行开发环境是命令行会报一段 warning：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING in asset size limit: The following asset(s) exceed the recommended size limit (250 kB).</span><br><span class="line">This can impact web performance.</span><br></pre></td></tr></table></figure><p>这是说建议每个输出的 js 文件的大小不要超过 250k。但开发环境因为包含了 sourcemap 并且代码未压缩所以一般都会超过这个大小，所以我们可以在开发环境把这个 warning 关闭。</p><p>webpack 配置中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  performance: &#123;</span><br><span class="line">    hints: dev ? false : &apos;warning&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置-favicon"><a href="#配置-favicon" class="headerlink" title="配置 favicon"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#配置-favicon" target="_blank" rel="noopener"></a>配置 favicon</h3><p>在 src 目录中放一张 favicon.png，然后 <code>src/index.html</code> 的 <code>&lt;head&gt;</code> 中插入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;favicon.png&quot;&gt;</span><br></pre></td></tr></table></figure><p>修改 webpack 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.html$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;html-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              /*</span><br><span class="line">              html-loader 接受 attrs 参数，表示什么标签的什么属性需要调用 webpack 的 loader 进行打包。</span><br><span class="line">              比如 &lt;img&gt; 标签的 src 属性，webpack 会把 &lt;img&gt; 引用的图片打包，然后 src 的属性值替换为打包后的路径。</span><br><span class="line">              使用什么 loader 代码，同样是在 module.rules 定义中使用匹配的规则。</span><br><span class="line"></span><br><span class="line">              如果 html-loader 不指定 attrs 参数，默认值是 img:src, 意味着会默认打包 &lt;img&gt; 标签的图片。</span><br><span class="line">              这里我们加上 &lt;link&gt; 标签的 href 属性，用来打包入口 index.html 引入的 favicon.png 文件。</span><br><span class="line">              */</span><br><span class="line">              attrs: [&apos;img:src&apos;, &apos;link:href&apos;]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        /*</span><br><span class="line">        匹配 favicon.png</span><br><span class="line">        上面的 html-loader 会把入口 index.html 引用的 favicon.png 图标文件解析出来进行打包</span><br><span class="line">        打包规则就按照这里指定的 loader 执行</span><br><span class="line">        */</span><br><span class="line">        test: /favicon\.png$/,</span><br><span class="line"></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            // 使用 file-loader</span><br><span class="line">            loader: &apos;file-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              /*</span><br><span class="line">              name：指定文件输出名</span><br><span class="line">              [hash] 为源文件的hash值，[ext] 为后缀。</span><br><span class="line">              */</span><br><span class="line">              name: &apos;[hash].[ext]&apos;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      // 图片文件的加载配置增加一个 exclude 参数</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\?.+)?$/,</span><br><span class="line"></span><br><span class="line">        // 排除 favicon.png, 因为它已经由上面的 loader 处理了。如果不排除掉，它会被这个 loader 再处理一遍</span><br><span class="line">        exclude: /favicon\.png$/,</span><br><span class="line"></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 html-webpack-plugin 接受一个 <code>favicon</code> 参数，可以指定 favicon 文件路径，会自动打包插入到 html 文件中。但它有个 <a href="https://github.com/ampedandwired/html-webpack-plugin/issues/364" target="_blank" rel="noopener">bug</a>，打包后的文件名路径不带 hash，就算有 hash，它也是 [hash]，而不是 [chunkhash]。导致修改代码也会改变 favicon 打包输出的文件名。issue 中提到的 favicons-webpack-plugin 倒是可以用，但它依赖 PhantomJS, 非常大。</p><h3 id="开发环境允许其他电脑访问"><a href="#开发环境允许其他电脑访问" class="headerlink" title="开发环境允许其他电脑访问"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#开发环境允许其他电脑访问" target="_blank" rel="noopener"></a>开发环境允许其他电脑访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const internalIp = require(&apos;internal-ip&apos;)</span><br><span class="line"></span><br><span class="line">module.exports.serve = &#123;</span><br><span class="line">  host: &apos;0.0.0.0&apos;,</span><br><span class="line">  hot: &#123;</span><br><span class="line">    host: &#123;</span><br><span class="line">      client: internalIp.v4.sync(),</span><br><span class="line">      server: &apos;0.0.0.0&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打包时自定义部分参数"><a href="#打包时自定义部分参数" class="headerlink" title="打包时自定义部分参数"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#打包时自定义部分参数" target="_blank" rel="noopener"></a>打包时自定义部分参数</h3><p>在多人开发时，每个人可能需要有自己的配置，比如说 webpack-serve 监听的端口号，如果写死在 webpack 配置里，而那个端口号在某个同学的电脑上被其他进程占用了，简单粗暴的修改 <code>webpack.config.js</code> 会导致提交代码后其他同学的端口也被改掉。</p><p>还有一点就是开发环境、测试环境、生产环境的部分 webpack 配置是不同的，比如 <code>publicPath</code> 在生产环境可能要配置一个 CDN 地址。</p><p>我们在根目录建立一个文件夹 <code>config</code>，里面创建 3 个配置文件：</p><ul><li>default.js: 生产环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  publicPath: &apos;http://cdn.example.com/assets/&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>dev.js: 默认开发环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  publicPath: &apos;/assets/&apos;,</span><br><span class="line"></span><br><span class="line">  serve: &#123;</span><br><span class="line">    port: 8090</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>local.js: 个人本地环境，在 dev.js 基础上修改部分参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const config = require(&apos;./dev&apos;)</span><br><span class="line">config.serve.port = 8070</span><br><span class="line">module.exports = config</span><br></pre></td></tr></table></figure><p><code>package.json</code> 修改 <code>scripts</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;local&quot;: &quot;npm run webpack-serve --config=local&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;npm run webpack-serve --config=dev&quot;,</span><br><span class="line">    &quot;webpack-serve&quot;: &quot;webpack-serve webpack.config.js&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack-cli&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack 配置修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">const url = require(&apos;url&apos;)</span><br><span class="line"></span><br><span class="line">const config = require(&apos;./config/&apos; + (process.env.npm_config_config || &apos;default&apos;))</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    // ...</span><br><span class="line">    publicPath: config.publicPath</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (dev) &#123;</span><br><span class="line">  module.exports.serve = &#123;</span><br><span class="line">    host: &apos;0.0.0.0&apos;,</span><br><span class="line">    port: config.serve.port,</span><br><span class="line">    dev: &#123;</span><br><span class="line">      publicPath: config.publicPath</span><br><span class="line">    &#125;,</span><br><span class="line">    add: app =&gt; &#123;</span><br><span class="line">      app.use(convert(history(&#123;</span><br><span class="line">        index: url.parse(config.publicPath).pathname</span><br><span class="line">      &#125;)))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的关键是 <code>npm run</code> 传进来的自定义参数可以通过 <code>process.env.npm_config_*</code> 获得。参数中如果有 <code>-</code> 会被转成 <code>_</code>。</p><p>还有一点，我们不需要把自己个人用的配置文件提交到 git，所以我们在 <code>.gitignore</code> 中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config/*</span><br><span class="line">!config/default.js</span><br><span class="line">!config/dev.js</span><br></pre></td></tr></table></figure><p>把 <code>config</code> 目录排除掉，但是保留生产环境和 dev 默认配置文件。</p><p>可能有同学注意到了 <code>webpack-cli</code> 可以通过 <a href="https://webpack.js.org/api/cli/#environment-options" target="_blank" rel="noopener">–env</a> 的方式从命令行传参给脚本，遗憾的是 <code>webpack-cli</code> <a href="https://github.com/webpack-contrib/webpack-serve#webpack-function-configs" target="_blank" rel="noopener">不支持</a>。</p><h3 id="webpack-serve-处理带后缀名的文件的特殊规则"><a href="#webpack-serve-处理带后缀名的文件的特殊规则" class="headerlink" title="webpack-serve 处理带后缀名的文件的特殊规则"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#webpack-serve-处理带后缀名的文件的特殊规则" target="_blank" rel="noopener"></a>webpack-serve 处理带后缀名的文件的特殊规则</h3><p>当处理带后缀名的请求时，比如 <a href="http://localhost:8080/bar.do" target="_blank" rel="noopener">http://localhost:8080/bar.do</a> ，<code>connect-history-api-fallback</code> 会认为它应该是一个实际存在的文件，就算找不到该文件，也不会 fallback 到 index.html，而是返回 404。但在 SPA 应用中这不是我们希望的。</p><p>幸好有一个配置选项 <code>disableDotRule: true</code> 可以禁用这个规则，使带后缀的文件当不存在时也能 fallback 到 index.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports.serve = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  add: app =&gt; &#123;</span><br><span class="line">    app.use(convert(history(&#123;</span><br><span class="line">      // ...</span><br><span class="line">      disableDotRule: true,</span><br><span class="line">      htmlAcceptHeaders: [&apos;text/html&apos;, &apos;application/xhtml+xml&apos;] // 需要配合 disableDotRule 一起使用</span><br><span class="line">    &#125;)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码中插入环境变量"><a href="#代码中插入环境变量" class="headerlink" title="代码中插入环境变量"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#代码中插入环境变量" target="_blank" rel="noopener"></a>代码中插入环境变量</h3><p>在业务代码中，有些变量在开发环境和生产环境是不同的，比如域名、后台 API 地址等。还有开发环境可能需要打印调试信息等。</p><p>我们可以使用 <a href="https://webpack.js.org/plugins/define-plugin/" target="_blank" rel="noopener">DefinePlugin</a> 插件在打包时往代码中插入需要的环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">const pkgInfo = require(&apos;./package.json&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      DEBUG: dev,</span><br><span class="line">      VERSION: JSON.stringify(pkgInfo.version),</span><br><span class="line">      CONFIG: JSON.stringify(config.runtimeConfig)</span><br><span class="line">    &#125;),</span><br><span class="line">    // ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefinePlugin 插件的原理很简单，如果我们在代码中写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(DEBUG)</span><br></pre></td></tr></table></figure><p>它会做类似这样的处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;console.log(DEBUG)&apos;.replace(&apos;DEBUG&apos;, true)</span><br></pre></td></tr></table></figure><p>最后生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(true)</span><br></pre></td></tr></table></figure><p>这里有一点需要注意，像这里的 <code>VERSION</code>， 如果我们不对 <code>pkgInfo.version</code> 做 <code>JSON.stringify()</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(VERSION)</span><br></pre></td></tr></table></figure><p>然后做替换操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;console.log(VERSION)&apos;.replace(&apos;VERSION&apos;, &apos;1.0.0&apos;)</span><br></pre></td></tr></table></figure><p>最后生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(1.0.0)</span><br></pre></td></tr></table></figure><p>这样语法就错误了。所以，我们需要 <code>JSON.stringify(pkgInfo.version)</code> 转一下变成 <code>&#39;&quot;1.0.0&quot;&#39;</code>，替换的时候才会带引号。</p><p>还有一点，webpack 打包压缩的时候，会把代码进行优化，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (DEBUG) &#123;</span><br><span class="line">  console.log(&apos;debug mode&apos;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&apos;production mode&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被编译成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (false) &#123;</span><br><span class="line">  console.log(&apos;debug mode&apos;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&apos;production mode&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后压缩优化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;production mode&apos;)</span><br></pre></td></tr></table></figure><h3 id="简化-import-路径"><a href="#简化-import-路径" class="headerlink" title="简化 import 路径"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#简化-import-路径" target="_blank" rel="noopener"></a>简化 import 路径</h3><p>文件 a 引入文件 b 时，b 的路径是相对于 a 文件所在目录的。如果 a 和 b 在不同的目录，藏得又深，写起来就会很麻烦：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import b from &apos;../../../components/b&apos;</span><br></pre></td></tr></table></figure><p>为了方便，我们可以定义一个路径别名（alias）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    &apos;~&apos;: resolve(__dirname, &apos;src&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们可以以 <code>src</code> 目录为基础路径来 <code>import</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import b from &apos;~/components/b&apos;</span><br></pre></td></tr></table></figure><p>html 中的 <code>&lt;img&gt;</code> 标签没法使用这个别名功能，但 <code>html-loader</code> 有一个 <code>root</code> 参数，可以使 <code>/</code> 开头的文件相对于 <code>root</code> 目录解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.html$/,</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: &apos;html-loader&apos;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        root: resolve(__dirname, &apos;src&apos;),</span><br><span class="line">        attrs: [&apos;img:src&apos;, &apos;link:href&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，<code>&lt;img src=&quot;/favicon.png&quot;&gt;</code> 就能顺利指向到 src 目录下的 favicon.png 文件，不需要关心当前文件和目标文件的相对路径。</p><p>PS: 在调试 <code>&lt;img&gt;</code> 标签的时候遇到一个坑，<code>html-loader</code> 会解析 <code>&lt;!-- --&gt;</code> 注释中的内容，之前在注释中写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">大于 10kb 的图片，图片会被储存到输出目录，src 会被替换为打包后的路径</span><br><span class="line">&lt;img src=&quot;/assets/f78661bef717cf2cc2c2e5158f196384.png&quot;&gt;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>之前因为没有加 <code>root</code> 参数，所以 <code>/</code> 开头的文件名不会被解析，加了 <code>root</code> 导致编译时报错，找不到该文件。大家记住这一点。</p><h3 id="优化-babel-编译后的代码性能"><a href="#优化-babel-编译后的代码性能" class="headerlink" title="优化 babel 编译后的代码性能"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#优化-babel-编译后的代码性能" target="_blank" rel="noopener"></a>优化 babel 编译后的代码性能</h3><p>babel 编译后的代码一般会造成性能损失，babel 提供了一个 <a href="http://babeljs.io/docs/plugins/preset-env/#optionsloose" target="_blank" rel="noopener">loose</a> 选项，使编译后的代码不需要完全遵循 ES6 规定，简化编译后的代码，提高代码执行效率：</p><p>package.json:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;babel&quot;: &#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">      [</span><br><span class="line">        &quot;env&quot;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;loose&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;stage-2&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这么做会有兼容性的风险，可能会导致 ES6 源码理应的执行结果和编译后的 ES5 代码的实际结果并不一致。如果代码没有遇到实际的效率瓶颈，官方 <a href="http://www.2ality.com/2015/12/babel6-loose-mode.html" target="_blank" rel="noopener">不建议</a> 使用 <code>loose</code> 模式。</p><h3 id="使用-webpack-自带的-ES6-模块处理功能"><a href="#使用-webpack-自带的-ES6-模块处理功能" class="headerlink" title="使用 webpack 自带的 ES6 模块处理功能"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#使用-webpack-自带的-es6-模块处理功能" target="_blank" rel="noopener"></a>使用 webpack 自带的 ES6 模块处理功能</h3><p>我们目前的配置，babel 会把 ES6 模块定义转为 CommonJS 定义，但 webpack 自己可以处理 <code>import</code> 和 <code>export</code>， 而且 webpack 处理 <code>import</code> 时会做代码优化，把没用到的部分代码删除掉。因此我们通过 babel 提供的 <code>modules: false</code> 选项把 ES6 模块转为 CommonJS 模块的功能给关闭掉。</p><p>package.json:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;babel&quot;: &#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">      [</span><br><span class="line">        &quot;env&quot;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;loose&quot;: true,</span><br><span class="line">          &quot;modules&quot;: false</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;stage-2&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-autoprefixer-自动创建-css-的-vendor-prefixes"><a href="#使用-autoprefixer-自动创建-css-的-vendor-prefixes" class="headerlink" title="使用 autoprefixer 自动创建 css 的 vendor prefixes"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#使用-autoprefixer-自动创建-css-的-vendor-prefixes" target="_blank" rel="noopener"></a>使用 autoprefixer 自动创建 css 的 vendor prefixes</h3><p>css 有一个很麻烦的问题就是比较新的 css 属性在各个浏览器里是要加前缀的，我们可以使用 <a href="https://github.com/postcss/autoprefixer" target="_blank" rel="noopener">autoprefixer</a> 工具自动创建这些浏览器规则，那么我们的 css 中只需要写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:fullscreen a &#123;</span><br><span class="line">    display: flex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>autoprefixer 会编译成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">:-webkit-full-screen a &#123;</span><br><span class="line">    display: -webkit-box;</span><br><span class="line">    display: flex</span><br><span class="line">&#125;</span><br><span class="line">:-moz-full-screen a &#123;</span><br><span class="line">    display: flex</span><br><span class="line">&#125;</span><br><span class="line">:-ms-fullscreen a &#123;</span><br><span class="line">    display: -ms-flexbox;</span><br><span class="line">    display: flex</span><br><span class="line">&#125;</span><br><span class="line">:fullscreen a &#123;</span><br><span class="line">    display: -webkit-box;</span><br><span class="line">    display: -ms-flexbox;</span><br><span class="line">    display: flex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们用 npm 安装它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-loader autoprefixer --save-dev</span><br></pre></td></tr></table></figure><p>autoprefixer 是 <a href="http://postcss.org/" target="_blank" rel="noopener">postcss</a> 的一个插件，所以我们也要安装 postcss 的 webpack <a href="https://github.com/postcss/postcss-loader" target="_blank" rel="noopener">loader</a>。</p><p>修改一下 webpack 的 css rule：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.css$/,</span><br><span class="line">  use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;postcss-loader&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建文件 <code>postcss.config.js</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    require(&apos;autoprefixer&apos;)()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-webpack-打包多页面应用（Multiple-Page-Application）"><a href="#使用-webpack-打包多页面应用（Multiple-Page-Application）" class="headerlink" title="使用 webpack 打包多页面应用（Multiple-Page Application）"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#使用-webpack-打包多页面应用multiple-page-application" target="_blank" rel="noopener"></a>使用 webpack 打包多页面应用（Multiple-Page Application）</h2><p>多页面网站同样可以用 webpack 来打包，以便使用 npm 包，<code>import()</code>，<code>code splitting</code> 等好处。</p><p>MPA 意味着并没不是一个单一的 html 入口和 js 入口，而是每个页面对应一个 html 和多个 js。那么我们可以把项目结构设计为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">├── dist</span><br><span class="line">├── package.json</span><br><span class="line">├── node_modules</span><br><span class="line">├── src</span><br><span class="line">│   ├── components</span><br><span class="line">│   ├── shared</span><br><span class="line">|   ├── favicon.png</span><br><span class="line">│   └── pages                 页面放这里</span><br><span class="line">|       ├── foo               编译后生成 http://localhost:8080/foo.html</span><br><span class="line">|       |    ├── index.html</span><br><span class="line">|       |    ├── index.js</span><br><span class="line">|       |    ├── style.css</span><br><span class="line">|       |    └── pic.png</span><br><span class="line">|       └── bar                        http://localhost:8080/bar.html</span><br><span class="line">|           ├── index.html</span><br><span class="line">|           ├── index.js</span><br><span class="line">|           ├── style.css</span><br><span class="line">|           └── baz                    http://localhost:8080/bar/baz.html</span><br><span class="line">|               ├── index.html</span><br><span class="line">|               ├── index.js</span><br><span class="line">|               └── style.css</span><br><span class="line">└── webpack.config.js</span><br></pre></td></tr></table></figure><p>这里每个页面的 <code>index.html</code> 是个完整的从 <code>&lt;!DOCTYPE html&gt;</code> 开头到 <code>&lt;/html&gt;</code> 结束的页面，这些文件都要用 <code>html-webpack-plugin</code> 处理。<code>index.js</code> 是每个页面的业务逻辑，作为每个页面的入口 js 配置到 <code>entry</code> 中。这里我们需要用 <code>glob</code> 库来把这些文件都筛选出来批量操作。为了使用 webpack 4 的 <code>optimization.splitChunks</code> 和 <code>optimization.runtimeChunk</code> 功能，我写了 <a href="https://github.com/fenivana/html-webpack-include-sibling-chunks-plugin" target="_blank" rel="noopener">html-webpack-include-sibling-chunks-plugin</a> 插件来配合使用。还要装几个插件把 css 压缩并放到 <code>&lt;head&gt;</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install glob html-webpack-include-sibling-chunks-plugin uglifyjs-webpack-plugin mini-css-extract-plugin optimize-css-assets-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p><code>webpack.config.js</code> 修改的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;)</span><br><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;)</span><br><span class="line">const OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)</span><br><span class="line">const HtmlWebpackIncludeSiblingChunksPlugin = require(&apos;html-webpack-include-sibling-chunks-plugin&apos;)</span><br><span class="line">const glob = require(&apos;glob&apos;)</span><br><span class="line"></span><br><span class="line">const dev = Boolean(process.env.WEBPACK_SERVE)</span><br><span class="line">const config = require(&apos;./config/&apos; + (process.env.npm_config_config || &apos;default&apos;))</span><br><span class="line"></span><br><span class="line">const entries = glob.sync(&apos;./src/**/index.js&apos;)</span><br><span class="line">const entry = &#123;&#125;</span><br><span class="line">const htmlPlugins = []</span><br><span class="line">for (const path of entries) &#123;</span><br><span class="line">  const template = path.replace(&apos;index.js&apos;, &apos;index.html&apos;)</span><br><span class="line">  const chunkName = path.slice(&apos;./src/pages/&apos;.length, -&apos;/index.js&apos;.length)</span><br><span class="line">  entry[chunkName] = dev ? [path, template] : path</span><br><span class="line">  htmlPlugins.push(new HtmlWebpackPlugin(&#123;</span><br><span class="line">    template,</span><br><span class="line">    filename: chunkName + &apos;.html&apos;,</span><br><span class="line">    chunksSortMode: &apos;none&apos;,</span><br><span class="line">    chunks: [chunkName]</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    // 我们不定义 publicPath，否则访问 html 时需要带上 publicPath 前缀</span><br><span class="line">    filename: dev ? &apos;[name].js&apos; : &apos;[chunkhash].js&apos;,</span><br><span class="line">    chunkFilename: &apos;[chunkhash].js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    runtimeChunk: true,</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: &apos;all&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    minimizer: dev ? [] : [</span><br><span class="line">      new UglifyJsPlugin(&#123;</span><br><span class="line">        cache: true,</span><br><span class="line">        parallel: true,</span><br><span class="line">        sourceMap: true</span><br><span class="line">      &#125;),</span><br><span class="line">      new OptimizeCSSAssetsPlugin()</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      // ...</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [dev ? &apos;style-loader&apos; : MiniCssExtractPlugin.loader, &apos;css-loader&apos;, &apos;postcss-loader&apos;]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      // ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    这里不使用 [chunkhash]</span><br><span class="line">    因为从同一个 chunk 抽离出来的 css 共享同一个 [chunkhash]</span><br><span class="line">    [contenthash] 你可以简单理解为 moduleId + content 生成的 hash</span><br><span class="line">    因此一个 chunk 中的多个 module 有自己的 [contenthash]</span><br><span class="line">    */</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[contenthash].css&apos;,</span><br><span class="line">      chunkFilename: &apos;[contenthash].css&apos;</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    // 必须放在html-webpack-plugin前面</span><br><span class="line">    new HtmlWebpackIncludeSiblingChunksPlugin(),</span><br><span class="line"></span><br><span class="line">    ...htmlPlugins</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>entry</code> 和 <code>htmlPlugins</code> 会通过遍历 pages 目录生成，比如：</p><p>entry:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &apos;bar/baz&apos;: &apos;./src/pages/bar/baz/index.js&apos;,</span><br><span class="line">  bar: &apos;./src/pages/bar/index.js&apos;,</span><br><span class="line">  foo: &apos;./src/pages/foo/index.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发环境中，为了能够修改 html 文件后网页能够自动刷新，我们还需要把 html 文件也加入 entry 中，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: [&apos;./src/pages/foo/index.js&apos;, &apos;./src/pages/foo/index.html&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当 foo 页面的 index.js 或 index.html 文件改动时，都会触发浏览器刷新该页面。虽然把 html 加入 entry 很奇怪，但放心，不会导致错误。记得不要在生产环境这么做，不然导致 chunk 文件包含了无用的 html 片段。</p><p>htmlPlugins:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: &apos;./src/pages/bar/baz/index.html&apos;,</span><br><span class="line">    filename: &apos;bar/baz.html&apos;,</span><br><span class="line">    chunksSortMode: &apos;none&apos;,</span><br><span class="line">    chunks: [&apos;bar/baz&apos;]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: &apos;./src/pages/bar/index.html&apos;,</span><br><span class="line">    filename: &apos;bar.html&apos;,</span><br><span class="line">    chunksSortMode: &apos;none&apos;,</span><br><span class="line">    chunks: [&apos;bar&apos;]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: &apos;./src/pages/foo/index.html&apos;,</span><br><span class="line">    filename: &apos;foo.html&apos;,</span><br><span class="line">    chunksSortMode: &apos;none&apos;,</span><br><span class="line">    chunks: [&apos;foo&apos;]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>代码在 <a href="https://github.com/fenivana/webpack-and-spa-guide/blob/master/examples/mpa" target="_blank" rel="noopener">examples/mpa</a> 目录。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#总结" target="_blank" rel="noopener"></a>总结</h2><p>通过这篇文章，我想大家应该学会了 webpack 的正确打开姿势。虽然我没有提及如何用 webpack 来编译 <a href="https://facebook.github.io/react/" target="_blank" rel="noopener">React</a> 和 <a href="http://vuejs.org/" target="_blank" rel="noopener">vue.js</a>, 但大家可以想到，无非是安装一些 loader 和 plugin 来处理 <a href="https://babeljs.io/docs/plugins/preset-react/" target="_blank" rel="noopener">jsx</a> 和 <a href="http://vue-loader.vuejs.org/" target="_blank" rel="noopener">vue</a> 格式的文件，那时难度就不在于 webpack 了，而是代码架构组织的问题了。具体的大家自己去摸索一下。</p><blockquote><p>文章来源：<a href="https://github.com/wallstreetcn/webpack-and-spa-guide" target="_blank" rel="noopener">https://github.com/wallstreetcn/webpack-and-spa-guide</a><br>作者：wallstreetcn<br>声明：文章著作权归作者所有，如有侵权，请联系小编删除。</p></blockquote><p>关注公众号“web前端导航”，最新的前端教程和学习资料等你来拿！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-65e75c57ef7286c8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;可以说是我目前看到最详细的 webpack 4 入门文章。&lt;br&gt;基本看完这个，基本也算一个合格的初级webpack配置工程师了。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;webpack 更新到了 4.0，官网还没有更新文档。因此把教程更新
      
    
    </summary>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象/原型链</title>
    <link href="http://yoursite.com/2018/07/19/JavaScript%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2018/07/19/JavaScript对象原型链/</id>
    <published>2018-07-19T12:45:23.000Z</published>
    <updated>2018-09-02T11:42:38.085Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对象的原型是什么？"><a href="#对象的原型是什么？" class="headerlink" title="对象的原型是什么？"></a>对象的原型是什么？</h3><p>Object是引用类型，包括：Object 、Array 、Function 、Data等。<br><strong>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。</strong></p><p>当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前（this）对象上查找该属性，如果没有找到，就到其原型对象上找(数组是Array.prototype,function是function。prototype)，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。</p><p>比如创建了一个Array对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3]</span><br></pre></td></tr></table></figure></p><p>其原型链是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr ----&gt; Array.prototype ----&gt; Object.prototype ----&gt; null</span><br></pre></td></tr></table></figure></p><p>Array.prototype定义了indexOf()、shift()等方法，因此你可以在所有的Array对象上直接调用这些方法。甚至你都可以在Array.prototype自定义方法，但是没有必要最后不要这样做。</p><p>当我们创建一个函数时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数也是一个对象 ，他的原型链是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null</span><br></pre></td></tr></table></figure></p><p>由于Function.prototype定义了apply()等方法，因此，所有函数都可以调用apply()方法。</p><h3 id="用构造函数创建对象"><a href="#用构造函数创建对象" class="headerlink" title="用构造函数创建对象"></a>用构造函数创建对象</h3><p>用函数来创建对象比直接用var = {…}创建对象要方面的多，它就是构造函数。<br>构造函数的首字母都应该大写<br>首先先创建一个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Student(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.hello = function () &#123;</span><br><span class="line">        alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以用关键字new来调用这个函数，并返回一个对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var xiaoming = new Student(&apos;小明&apos;);</span><br><span class="line">xiaoming.name; // &apos;小明&apos;</span><br><span class="line">xiaoming.hello(); // Hello, 小明!</span><br></pre></td></tr></table></figure></p><p>注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。</p><p>新创建的xiaoming的原型链是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xiaoming ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null</span><br></pre></td></tr></table></figure></p><p>也就是说，xiaoming的原型指向函数Student的原型。如果你又创建了xiaohong、xiaojun，那么这些对象的原型与xiaoming是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaoming ↘</span><br><span class="line">xiaohong -→ Student.prototype ----&gt; Object.prototype ----&gt; null</span><br><span class="line">xiaojun  ↗</span><br></pre></td></tr></table></figure></p><p>用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(xiaoming.constructor === Student)//true</span><br></pre></td></tr></table></figure></p><p>我们可以用instanceof来检测对象类型；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(xiaohong instanceof Object);//true</span><br><span class="line">console.log(xiaohong instanceof Student);//true</span><br><span class="line">console.log(xiaoming instanceof Object);//true</span><br><span class="line">console.log(xiaoming instanceof Student);//true</span><br></pre></td></tr></table></figure></p><p>这个例子中所创建的对象即是Object的实例 也是Student的实例，因为所有的对象都继承自Object</p><p>参考：js高程第六章<br>参考：<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997235247b53be560ab041a7b10360a567422a78000" target="_blank" rel="noopener">廖雪峰的博客</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对象的原型是什么？&quot;&gt;&lt;a href=&quot;#对象的原型是什么？&quot; class=&quot;headerlink&quot; title=&quot;对象的原型是什么？&quot;&gt;&lt;/a&gt;对象的原型是什么？&lt;/h3&gt;&lt;p&gt;Object是引用类型，包括：Object 、Array 、Function 、Da
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中基本数据类型和引用数据类型的区别</title>
    <link href="http://yoursite.com/2018/07/19/JavaScript%E4%B8%AD%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/07/19/JavaScript中基本数据类型和引用数据类型的区别/</id>
    <published>2018-07-19T12:45:23.000Z</published>
    <updated>2018-09-02T11:42:23.004Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、基本数据类型和引用数据类型</strong></p><p>　　ECMAScript包括两个不同类型的值：基本数据类型和引用数据类型。</p><p>　　基本数据类型指的是简单的数据段，引用数据类型指的是有多个值构成的对象。</p><p>　　当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值。</p><p><strong>2、常见的基本数据类型：</strong></p><p>　　Number、String 、Boolean、Null和Undefined。基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。示例：</p><p>　　var a = 10;</p><p>　　var b = a;</p><p>　　b = 20;</p><p>　　console.log(a); // 10值</p><p>　　上面，b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值。</p><p>　　<strong>b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。</strong></p><p>下图演示了这种基本数据类型赋值的过程：</p><p><strong>3、引用类型数据：</strong></p><p><strong>也就是对象类型Object type，比如：Object 、Array 、Function 、Data等。</strong> </p><p>javascript的引用数据类型是保存在堆内存中的对象。</p><p>　　与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。</p><p>　　所以，引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。</p><p>　　var obj1 = new Object();</p><p>　　var obj2 = obj1;</p><p>　　obj2.name = “我有名字了”;</p><p>　　console.log(obj1.name); // 我有名字了</p><p>　　说明这两个引用数据类型指向了同一个堆内存对象。obj1赋值给onj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2，</p><p>　　但是实际上他们共同指向了同一个堆内存对象。<strong>实际上改变的是堆内存对象。</strong></p><p>下面我们来演示这个引用数据类型赋值过程：</p><pre><code>[图片上传失败...(image-3d74f7-1531992451590)]</code></pre><p><strong>4、总结区别</strong></p><p><strong>　　a 声明变量时不同的内存分配：　</strong></p><p>　　1）原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在<strong>变量访问的位置</strong>。</p><p>　　　　这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。</p><p>　　2）引用值：存储在堆（heap）中的对象，也就是说，<strong>存储在变量处的值是一个指针（point），指向存储对象的内存地址。</strong></p><p>　　　  这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。</p><p>　　　  地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。</p><p>　　<strong>b</strong> <strong>不同的内存分配机制也带来了不同的访问机制</strong></p><p>　　1）在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，</p><p>　　　　首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的<strong>按引用访问</strong>。</p><p>　　2）而原始类型的值则是可以直接访问到的。</p><p><strong>　　c 复制变量时的不同</strong></p><p>1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，<strong>此后这两个变量是完全独立的，他们只是拥有相同的value而已。</strong></p><p>　　2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，</p><p>　　　　也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。</p><p>　　　　（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。<strong>多了一个指针</strong></p><p>　　<strong>d 参数传递的不同（</strong>把实参复制给形参的过程<strong>）</strong></p><p>　　首先我们应该明确一点：ECMAScript中所有函数的参数都<strong>是按值来传递</strong>的。</p><p>　　但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 　</p><p>　　1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。</p><p>　　2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！</p><p>　　　　因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。</p><p>参考：<a href="https://www.cnblogs.com/cxying93/p/6106469.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxying93/p/6106469.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1、基本数据类型和引用数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　ECMAScript包括两个不同类型的值：基本数据类型和引用数据类型。&lt;/p&gt;
&lt;p&gt;　　基本数据类型指的是简单的数据段，引用数据类型指的是有多个值构成的对象。&lt;/p&gt;
&lt;p&gt;　　当我们把变
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack入门</title>
    <link href="http://yoursite.com/2018/07/19/webpack%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/07/19/webpack入门/</id>
    <published>2018-07-19T12:45:23.000Z</published>
    <updated>2018-10-19T09:35:46.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么使用webpack"><a href="#为什么使用webpack" class="headerlink" title="为什么使用webpack??"></a>为什么使用webpack??</h2><p><strong>一句话 webpack能够提高了我们的开发效率</strong><br>什么是Webpack<br>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>新建一个空的练习文件夹 如：webpackText<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//全局安装</span><br><span class="line">npm install -g webpack</span><br><span class="line">//安装到你的项目目录</span><br><span class="line">npm install --save-dev webpack</span><br><span class="line">//npm install --save-dev webpack@版本号</span><br><span class="line">//可下载对应版本的webpack</span><br></pre></td></tr></table></figure></p><h3 id="正式使用Webpack前的准备"><a href="#正式使用Webpack前的准备" class="headerlink" title="正式使用Webpack前的准备"></a>正式使用Webpack前的准备</h3><ol><li>创建package.json文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></li></ol><p>项目名称和作者等信息回车即可</p><ol start="2"><li><p>package.json文件已经就绪，我们在本项目中安装Webpack作为依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装Webpack</span><br><span class="line">npm install --save-dev webpack</span><br></pre></td></tr></table></figure></li><li><p>创建两个文件夹,app文件夹和public文件夹，app文件夹用来存放原始数据和我们将写的JavaScript模块，public文件夹用来存放之后供浏览器读取的文件（包括使用webpack打包生成的js文件以及一个index.html文件）创建三个文件:</p></li></ol><ul><li><code>index.html</code> –放在public文件夹中;</li><li><code>Greeter.js</code>– 放在app文件夹中;</li><li><code>main.js</code>– 放在app文件夹中;</li></ul><p>此时项目结构如下图所示<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-c977d7d00f7a1ec4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构" title="">                </div>                <div class="image-caption">项目结构</div>            </figure></p><p>我们在<strong>index.html</strong>文件中写入最基础的html代码，它在这里目的在于引入打包后的js文件（这里我们先把之后打包后的js文件命名为<code>bundle.js</code>，之后我们还会详细讲述）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- index.html --&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Webpack Sample Project&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&apos;root&apos;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>我们在Greeter.js中定义一个返回包含问候信息的html元素的函数,并依据CommonJS规范导出这个函数为一个模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Greeter.js</span><br><span class="line">module.exports = function() &#123;</span><br><span class="line">  var greet = document.createElement(&apos;div&apos;);</span><br><span class="line">  greet.textContent = &quot;Hi there and greetings!&quot;;</span><br><span class="line">  return greet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>main.js文件中我们写入下述代码，用以把Greeter模块返回的节点插入页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//main.js </span><br><span class="line">const greeter = require(&apos;./Greeter.js&apos;);</span><br><span class="line">document.querySelector(&quot;#root&quot;).appendChild(greeter());</span><br></pre></td></tr></table></figure></p><p>根目录下新建webpack.config.js，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry:  __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件</span><br><span class="line">  output: &#123;//__dirname 是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</span><br><span class="line">    path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方</span><br><span class="line">    filename: &quot;bundle.js&quot;//打包后输出文件的文件名</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了更方面的打包，在package.json中对scripts对象进行相关设置即可，设置方法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpack-sample-project&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Sample webpack project&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack&quot; // 修改的是这里，JSON文件不支持注释，引用时请清除</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;zhang&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;3.10.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>命令行中输入<code>npm start</code>试试<br>然后浏览器打开public/index.html<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-6493c12b502af61f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WechatIMG2.jpeg" title="">                </div>                <div class="image-caption">WechatIMG2.jpeg</div>            </figure></p><h3 id="使用webpack构建本地服务器"><a href="#使用webpack构建本地服务器" class="headerlink" title="使用webpack构建本地服务器"></a>使用webpack构建本地服务器</h3><ol><li>安装devserver<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure></li></ol><p>注意：webpack3.x的请下载webpack-dev-server2.9，不然会报错</p><ol start="2"><li><p>把这些命令加到webpack的配置文件中，现在的配置文件webpack.config.js如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  devtool: &apos;eval-source-map&apos;,</span><br><span class="line"></span><br><span class="line">  entry:  __dirname + &quot;/app/main.js&quot;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;/public&quot;,</span><br><span class="line">    filename: &quot;bundle.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录</span><br><span class="line">    historyApiFallback: true,//不跳转</span><br><span class="line">    inline: true//实时刷新</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在package.json中的scripts对象中添加如下命令，用以开启本地服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;webpack&quot;,</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ol><p>在终端中输入npm run server即可在本地的8080端口查看结果（实时刷新）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-cb7c29cb6d2e9dff.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WechatIMG3.jpeg" title="">                </div>                <div class="image-caption">WechatIMG3.jpeg</div>            </figure></p><h2 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h2><p>鼎鼎大名的Loaders登场了！<br>Loaders是webpack提供的最激动人心的功能之一了。通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的<br><strong>Loaders可以把React的中用到的JSX文件转换为JS文件</strong><br> Loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，Loaders的配置包括以下几方面：</p><ul><li>test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）</li><li>loader：loader的名称（必须）</li><li>include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；</li><li>query：为loaders提供额外的设置选项（可选）<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3>Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：</li></ul><p>让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持；<br>让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；<br>Babel的安装与配置<br>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-env-preset包和解析JSX的babel-preset-react包）。</p><p>一次性安装这些依赖包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// npm一次性安装多个依赖模块，模块之间用空格隔开</span><br><span class="line">npm install --save-dev babel-core babel-loader babel-preset-env babel-preset-react</span><br></pre></td></tr></table></figure></p><p>Babel其实可以完全在 webpack.config.js 中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方</span><br><span class="line">        filename: &quot;bundle.js&quot;//打包后输出文件的文件名</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &apos;eval-source-map&apos;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录</span><br><span class="line">        historyApiFallback: true,//不跳转</span><br><span class="line">        inline: true//实时刷新</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /(\.jsx|\.js)$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;babel-loader&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                exclude: /node_modules/</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//.babelrc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为webpack4都出来了 我学的这篇是webpack3.5版本的，但是基础的东西都还是一样的，最后放上这个webpack的配置文件，如果每一项都懂的话，入门应该是没问题了。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 一个常见的`webpack`配置文件</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">        entry: __dirname + &quot;/app/main.js&quot;, //已多次提及的唯一入口文件</span><br><span class="line">        output: &#123;</span><br><span class="line">            path: __dirname + &quot;/build&quot;,</span><br><span class="line">            filename: &quot;bundle-[hash].js&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        devtool: &apos;none&apos;,</span><br><span class="line">        devServer: &#123;</span><br><span class="line">            contentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录</span><br><span class="line">            historyApiFallback: true, //不跳转</span><br><span class="line">            inline: true,</span><br><span class="line">            hot: true</span><br><span class="line">        &#125;,</span><br><span class="line">        module: &#123;</span><br><span class="line">            rules: [&#123;</span><br><span class="line">                    test: /(\.jsx|\.js)$/,</span><br><span class="line">                    use: &#123;</span><br><span class="line">                        loader: &quot;babel-loader&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    exclude: /node_modules/</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    test: /\.css$/,</span><br><span class="line">                    use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                        fallback: &quot;style-loader&quot;,</span><br><span class="line">                        use: [&#123;</span><br><span class="line">                            loader: &quot;css-loader&quot;,</span><br><span class="line">                            options: &#123;</span><br><span class="line">                                modules: true,</span><br><span class="line">                                localIdentName: &apos;[name]__[local]--[hash:base64:5]&apos;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, &#123;</span><br><span class="line">                            loader: &quot;postcss-loader&quot;</span><br><span class="line">                        &#125;],</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: __dirname + &quot;/app/index.tmpl.html&quot; //new 一个这个插件的实例，并传入相关的参数</span><br><span class="line">        &#125;),</span><br><span class="line">        new webpack.optimize.OccurrenceOrderPlugin(),</span><br><span class="line">        new webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">        new ExtractTextPlugin(&quot;style.css&quot;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://www.jianshu.com/p/42e11515c10f" target="_blank" rel="noopener">https://www.jianshu.com/p/42e11515c10f</a><br>webpack中文网：<a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">https://www.webpackjs.com/concepts/</a><br>简要理解CommonJS规范：<a href="https://blog.csdn.net/u012443286/article/details/78825917" target="_blank" rel="noopener">https://blog.csdn.net/u012443286/article/details/78825917</a><br>webpack4那点东西：<a href="https://juejin.im/post/5abef5e96fb9a028e33b9035" target="_blank" rel="noopener">https://juejin.im/post/5abef5e96fb9a028e33b9035</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么使用webpack&quot;&gt;&lt;a href=&quot;#为什么使用webpack&quot; class=&quot;headerlink&quot; title=&quot;为什么使用webpack??&quot;&gt;&lt;/a&gt;为什么使用webpack??&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一句话 webpack能够提高了我们
      
    
    </summary>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
</feed>
