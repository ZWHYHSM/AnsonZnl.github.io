<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anson Blog</title>
  
  <subtitle>种一棵树最好的时间在十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-17T14:07:15.324Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>张宁乐</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MongoDB中常用语句</title>
    <link href="http://yoursite.com/2018/11/17/MongoDB%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2018/11/17/MongoDB中常用语句/</id>
    <published>2018-11-17T14:23:20.000Z</published>
    <updated>2018-11-17T14:07:15.324Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MOngoDB-删除语句"><a href="#MOngoDB-删除语句" class="headerlink" title="MOngoDB  删除语句"></a>MOngoDB  删除语句</h3><p><strong>delete()删除</strong></p><ol><li>删除一个集合<br><code>db.collection.deleteOne()</code></li><li>删除多个集合<br><code>db.collection.deletMany();</code></li></ol><p><strong>remove()删除</strong></p><ol><li>删除所有的name：李四的数据<br><code>db.student.remove({name:&quot;李四&quot;});</code></li><li>只删除一条sex:男的数据 仅删除一条<br><code>db.student.remove({sex:&quot;男&quot;},true);</code></li><li>删除全部<br><code>db.student.remove({});</code></li></ol><h3 id="数据库假删除"><a href="#数据库假删除" class="headerlink" title="数据库假删除"></a>数据库假删除</h3><p>有时候用户删除操作的时候，需求是这样的，仅是隐藏这条数据，并不是真的从数据库中删除。<br>这时候就用到假删除了，<br>比如这个是张三发的两篇微博：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.student.insert([</span><br><span class="line">    &#123;name:&quot;张三&quot;,content:&quot;今天心情好&quot;,isDel:0&#125;,</span><br><span class="line">    &#123;name:&quot;张三&quot;,content:&quot;今天心情一般&quot;,isDel:0&#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-0cf6106c47156b0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="b21d2b7140562e21fcbe9c168e02da9.png" title="">                </div>                <div class="image-caption">b21d2b7140562e21fcbe9c168e02da9.png</div>            </figure><p>用户增加两条数据，但只保留后一条，删除前一条，这时候用到假删除 ，在添加数据时加上一个字段<code>isDel:0</code><br>所以当用户删除数据时候 执行的不是remove方法而是update方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.student.update(&#123;&quot;_id&quot; : ObjectId(&quot;5bd6a46f1eb7a22fa07cb382&quot;)&#125;,&#123;</span><br><span class="line">    $set:&#123;</span><br><span class="line">      isDel:1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-c1ca4b50a635972c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="98cf763807e662cd724e6d65f1638fb.png" title="">                </div>                <div class="image-caption">98cf763807e662cd724e6d65f1638fb.png</div>            </figure><p>当<code>isDel:0</code>是表示用户没有删除 为1是表示用户已经删除</p><p>所以在查询的时候要筛选name和isDel条件即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.student.find(&#123;name:&quot;张三&quot;,isDel:0&#125;);</span><br></pre></td></tr></table></figure></p><p>查询到用户没有删除的数据:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-a917d02348ba2b6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="121b7fc4d6f40af1de843359cdbf585.png" title="">                </div>                <div class="image-caption">121b7fc4d6f40af1de843359cdbf585.png</div>            </figure><p>然后就可以实现假删除了。</p><h3 id="批量数据的操作和修改"><a href="#批量数据的操作和修改" class="headerlink" title="批量数据的操作和修改"></a>批量数据的操作和修改</h3><ol><li><p>向集合中插入10000个文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr= [];</span><br><span class="line">for(var i=0;i&lt;10000;i++)&#123;</span><br><span class="line">   arr.push(&#123;counter:i&#125;);</span><br><span class="line">&#125;</span><br><span class="line">db.demos.insert(arr);</span><br><span class="line">db.demos.find();</span><br></pre></td></tr></table></figure></li><li><p>查询demos中counter为666的文档<br><code>db.demos.find({counter:666});</code></p></li><li>查询demos中counter小于66的文档<br><code>db.demos.find({counter:{$lt:666}});</code></li><li>查询demos中counter大T666的文档<br><code>db.demos.find({counter:{$gt:666}});</code></li><li>查询demos中counter大于66小于666的文档1120查吉demos集合中的前10余数据<br><code>db.demos.find({counter:{$gt:66, $lt:666}});</code></li><li>查石demos集合中的第1字到20条数据<br><code>db.demos.find().limit(10);</code></li><li>查春demos集合中的第2 1条到30条数据  分页功能   skip从多少条开始 limit每次查询多少条 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.demos.find().skip(0).limit(10);//第一页 从0条开始 每查询10条</span><br><span class="line">db.demos.find().skip(10).limit(10);//第二页 从10条开始 每查询10条</span><br><span class="line">db.demos.find().skip(20).limit(10);//第三页 从20条开始 每查询10条</span><br></pre></td></tr></table></figure></li></ol><h3 id="集合中文档关系"><a href="#集合中文档关系" class="headerlink" title="集合中文档关系"></a>集合中文档关系</h3><ol><li>一对一（noe to noe）:<br>比如：人和身份证   老公和老婆</li><li>一对多（noe to many）:<br>比如：父母和孩子  用户和物品</li><li>多对多（many to many）:<br>比如：老师和学生</li></ol><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>以内嵌文档的形式体现，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//一对一</span><br><span class="line">db.aAndb.insert([</span><br><span class="line"> &#123;name:&quot;杨过&quot;,wife:&#123;name:&quot;小龙女&quot;,sex:&quot;女&quot;&#125;,sex:&quot;男&quot;&#125;,</span><br><span class="line">  &#123;name:&quot;杨过&quot;,wife:&#123;name:&quot;小龙女&quot;,sex:&quot;女&quot;&#125;,sex:&quot;男&quot;&#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">db.aAndb.find();</span><br></pre></td></tr></table></figure></p><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>通过内嵌文档的形式实现或者通过集合的形式实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//一对多  比如  微博 和 微博评论</span><br><span class="line">//添加微博</span><br><span class="line">db.weibo.insert([</span><br><span class="line">&#123;weibo:&quot;世界这么大，我想去看看&quot;&#125;,</span><br><span class="line">&#123;weibo:&quot;我要做一名web开发者！！！&quot;&#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">db.weibo.find();</span><br></pre></td></tr></table></figure></p><p>添加评论<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">db.comments.insert([</span><br><span class="line">&#123;</span><br><span class="line">weibo_id: ObjectId(&quot;5bdd89e06a5e78f4cfc2b9c8&quot;),</span><br><span class="line">list:[</span><br><span class="line">   &quot;那你有钱吗&quot;,</span><br><span class="line">    &quot;一个人吗？？去呢啊？？&quot;,</span><br><span class="line">    &quot;加油！！&quot;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">weibo_id: ObjectId(&quot;5bdd89e06a5e78f4cfc2b9c9&quot;),</span><br><span class="line">list:[</span><br><span class="line">   &quot;那你要学习HTML&quot;,</span><br><span class="line">   &quot;那还要你要学习css&quot;,</span><br><span class="line">    &quot;加油！！&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">db.comments.find();</span><br></pre></td></tr></table></figure></p><p>查询一对多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var weibo_id= db.weibo.findOne(&#123;&quot;weibo&quot; : &quot;世界这么大，我想去看看&quot;&#125;)._id;</span><br><span class="line">db.comments.find(&#123;weibo_id: weibo_id&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="多对多的关系"><a href="#多对多的关系" class="headerlink" title="多对多的关系"></a>多对多的关系</h4><p>比如：学生和老师<br>可以通过多文档关联，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//多对多  老师《------》学生</span><br><span class="line"></span><br><span class="line">//插入老师集合</span><br><span class="line">db.teachers.insert([</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;语文老师&quot;,</span><br><span class="line">  teacher_id: 1,</span><br><span class="line">  student_id:[</span><br><span class="line">     1001,</span><br><span class="line">     1002,</span><br><span class="line">     1003</span><br><span class="line">  ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;数学老师&quot;,</span><br><span class="line">  teacher_id: 2,</span><br><span class="line">  student_id:[</span><br><span class="line">     1001,</span><br><span class="line">     1002,</span><br><span class="line">     1003</span><br><span class="line">  ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;英语老师&quot;,</span><br><span class="line">  teacher_id: 3,</span><br><span class="line">  student_id:[</span><br><span class="line">     1001,</span><br><span class="line">     1002,</span><br><span class="line">     1003</span><br><span class="line">  ]</span><br><span class="line"> &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">db.teachers.find();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//插入学生集合</span><br><span class="line">db.students.insert([</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;小明&quot;,</span><br><span class="line">  student_id: 1001,</span><br><span class="line">  teacher_id:[</span><br><span class="line">     1,</span><br><span class="line">     2,</span><br><span class="line">     3</span><br><span class="line">  ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;小红&quot;,</span><br><span class="line">  student_id: 1002,</span><br><span class="line">  teacher_id:[</span><br><span class="line">     1,</span><br><span class="line">     2,</span><br><span class="line">     3</span><br><span class="line">  ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;小刚&quot;,</span><br><span class="line">  student_id: 1003,</span><br><span class="line">  teacher_id:[</span><br><span class="line">     1,</span><br><span class="line">     2,</span><br><span class="line">     3</span><br><span class="line">  ]</span><br><span class="line"> &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">db.students.find();</span><br><span class="line">db.teachers.find();</span><br></pre></td></tr></table></figure></p><h3 id="排序和索引"><a href="#排序和索引" class="headerlink" title="排序和索引"></a>排序和索引</h3><h4 id="排序："><a href="#排序：" class="headerlink" title="排序："></a>排序：</h4><p>查询文档时，默认是按照_id的值进行排序的（升序）<br>sort() 可以用来指定文档的排序规则，sort() 内部需要传递一个对象来指定文档的排序规则 ，其中1表示升序 ，-1表示降序<br>limit skip sort 的顺序可以任意改变 ，运行时会自动调整。<br>不希望它默认按照id排序  希望它按照工资来排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//按照工资升序排列</span><br><span class="line"></span><br><span class="line">db.section.find().sort(&#123;wages:1&#125;);</span><br><span class="line"></span><br><span class="line">//优先按照工资升序排列  如果遇到相同的就在  按照id升序排列</span><br><span class="line">db.section.find().sort(&#123;wages: 1&#125;,&#123;_id: -1&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h4><p>展示字段中 部分内容<br>或者是提取这个字段内的部分内容<br>在查询时 ，可以在第二个参数来设置查询的结果投影</p><blockquote><p>索引： find({ 查询条件 }, { 检索范围（1显示 0隐藏）})<br>注意： <code>_id</code>如果不设置默认是1（显示） 可手动隐藏</p></blockquote><p><code>db.section.find({}, {name: 1});</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//只显示name和wages字段</span><br><span class="line">`db.section.find(&#123;&#125;, &#123;name: 1, _id: 0, wages: 1&#125;);`</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-1b481d1c9381e28f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a07a1f2945204ef671ddebc28871c00.png" title="">                </div>                <div class="image-caption">a07a1f2945204ef671ddebc28871c00.png</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MOngoDB-删除语句&quot;&gt;&lt;a href=&quot;#MOngoDB-删除语句&quot; class=&quot;headerlink&quot; title=&quot;MOngoDB  删除语句&quot;&gt;&lt;/a&gt;MOngoDB  删除语句&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;delete()删除&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>初试MongoDB数据库</title>
    <link href="http://yoursite.com/2018/11/15/%E5%88%9D%E8%AF%95MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/11/15/初试MongoDB数据库/</id>
    <published>2018-11-15T06:04:55.000Z</published>
    <updated>2018-11-17T13:59:35.388Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h3><p><strong>数据库（Database）基本概念：</strong></p><ol><li>数据库就是按照一定的数据结构来组织，储存和管理数据的仓库</li><li>我们写的程序都是在内存中运行的，一旦程序运行结束或者计算机断点，程序运行中的数据就会全部丢失；所以我们就需要将一些程序的数据持久化到键盘之中，以确保数据的安全性。</li><li>数据库则是大批量数据持久化的普遍选择，1.文件 2. 数据库  </li></ol><p><strong>为什么都采用数据库来储存数据:</strong></p><ul><li>数据库是有结构的</li><li>数据库可以提供各种接口，让数据处理（增删改查）快捷方便</li><li>各种语言（PHP jsp .net..）提供了完善的接口</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-d9cbd052415afbf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="b6dde1cf95ae2a9ec8e68c0bf1719a3.png" title="">                </div>                <div class="image-caption">b6dde1cf95ae2a9ec8e68c0bf1719a3.png</div>            </figure><p>###数据库分类</p><ol><li>ROBMS（关系型数据库）：<ul><li>比如MySql 、sql server Oracle 等</li><li>特点 通过一张张表来建立关联</li><li>基本都使用SQL语言来管理数据库，</li></ul></li><li>Nosql (非关系型数据库)：<ul><li>没有行 、列的概念 用json类储存数据</li><li>集合相当于“表”，文档相当于“行”</li><li>标准化和非标准化的摩擦。</li><li>标准化限制创新，非标准话不能统一</li></ul></li></ol><p><strong>特征</strong>： 使用键值（Key Value）储存数据</p><p><strong>关系型数据库和非关系型数据库区别：</strong><br>关系型数据库比较结构化，操作不是很灵活，菲关系型数据库操作灵活，但不适合大型数据存储，比较适合微架构，两者是相辅相成的关系</p><p><strong>非关系型数据库使用方面：</strong></p><ol><li>数据模型比较简单</li><li>需要灵活性更强的后台系统</li><li>对数据库性能要求比较高</li><li>不需要高度的数据一致性</li></ol><p><strong>非关系型数据库主要适合小微型架构的使用</strong></p><h3 id="数据库MongoDB安装"><a href="#数据库MongoDB安装" class="headerlink" title="数据库MongoDB安装"></a>数据库MongoDB安装</h3><p>MongoDB（非关系型数据库）：</p><ol><li>适合快速开发web应用而设计的数据库系统</li><li>设计目标是极简、灵活、经常在web应用栈的业务层被运用</li><li>它的数据模型是面向文档的，类似于json的结构</li><li>所以这个数据库中是各种各样的json, 并以键值形式对存储</li></ol><p>安装：<br>下载:<a href="https://www.mongodb.com/" target="_blank" rel="noopener">https://www.mongodb.com/</a><br>偶数是稳定版，奇数是开发版<br>最好下载64位的系统版本的</p><p><strong>配置环境变量:</strong></p><ol><li>新建—&gt;安装到bin路径复制到环境变量</li><li>创建data-&gt;db文件夹</li><li>打开命令行输入mongod启动DB服务器</li><li>指定端口号和路径 mongod –dbpath d:\data\db</li><li>将MongDB设置为系统服务，data\log<br>创建配置文件在bin下穿件文件mongod.cfg<br>执行一段命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.exe create MongoDB binPath= &quot;\&quot;F:\MongoDB\Server\3.2\bin\mongod.exe\&quot; --service --config= \&quot;F:\MongoDB\Server\3.2\mongod.cfg\&quot;&quot; DisplayName= &quot;MongoDB&quot; start= &quot;auto&quot;</span><br></pre></td></tr></table></figure></li></ol><p>主要是让MongoDB一直运行在内存中<br>参考资料：<br><a href="https://www.cnblogs.com/wzlblog/p/6364045.html" target="_blank" rel="noopener">https://www.cnblogs.com/wzlblog/p/6364045.html</a><br><a href="https://www.cnblogs.com/chenlq/p/6515876.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenlq/p/6515876.html</a></p><h3 id="在命令行中使用MongoDB插入命令"><a href="#在命令行中使用MongoDB插入命令" class="headerlink" title="在命令行中使用MongoDB插入命令"></a>在命令行中使用MongoDB插入命令</h3><p><strong>MongoDB的组成：</strong></p><ul><li>数据库 数据库是一个仓库 在仓库里可以放集合</li><li>集合： 集合类似数组 在集合里可以放文档</li><li>文档：文档是数据库中最小的单位 我们储存和操作的内容都是文档。</li></ul><p><strong>基本指令：</strong><br><code>show dbs</code>  显示当前所有的数据库<br><code>use</code> 数据库名  进入到指定数据库<br><code>db</code> 显示当前所在的数据库<br><code>show collections</code> 显示数据库中的所有集合</p><p>使用管理员打开 cmd<br>输入 <code>mongo</code>进入MongoDB的环境<br>进入MongoDB的环境才能执行MongoDB的命令<br>然后使用命令行进行CRUD(增删改查)：<br><code>db.&lt;collection&gt;.insert(doc)</code></p><p><strong>举例子：</strong><br>想school数据库中的学生集合student中插入一个新的学生对象<br>增加一条数据：<br><code>db.student.insert({id:&quot;001&quot;,name:&quot;znl&quot;,age:18,sex:“男”})</code><br>在当前的集合（school）中新建一条数据</p><p>查询一条数据：<br><code>db.&lt;collection&gt;.find();</code></p><p>如：<code>db.student.find();</code><br>回车 就能查询student下的所有数据<br>插入多条数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.集合名.insert([</span><br><span class="line">    &#123;name:&quot;张三&quot;,age:18,sex:&quot;man&quot;&#125;,</span><br><span class="line">    &#123;name:&quot;张三&quot;,age:18,sex:&quot;man&quot;&#125;,</span><br><span class="line">    &#123;name:&quot;张三&quot;,age:18,sex:&quot;man&quot;&#125;,</span><br><span class="line">    &#123;id:18，name:&quot;张三&quot;,age:18,sex:&quot;man&quot;&#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p><blockquote><p>插入多条数据时把多条语句放在一个数组里<br>插入可随便插入 不必拘泥于字段是否相同 当插入的字段不存在时会自动创建该字段</p></blockquote><p>查看更多更多操作：<a href="http://www.mongodb.org.cn/manual/" target="_blank" rel="noopener">http://www.mongodb.org.cn/manual/</a></p><h3 id="MongoDB-可视化工具-【NOSQL】"><a href="#MongoDB-可视化工具-【NOSQL】" class="headerlink" title="MongoDB 可视化工具 【NOSQL】"></a>MongoDB 可视化工具 【NOSQL】</h3><p>然而一直使用命令行操作是很麻烦的事情，所以推荐使用NOSQL可视化工具<br>安装可视化工具下载地址：<a href="https://www.mongodbmanager.com/download" target="_blank" rel="noopener">https://www.mongodbmanager.com/download</a></p><h3 id="使用可视化工具"><a href="#使用可视化工具" class="headerlink" title="使用可视化工具"></a>使用可视化工具</h3><p>可视化工具 查找功能：<br>插入(insert)语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.student(集合名字).insert([</span><br><span class="line">&#123;id:1,name:&quot;znl&quot;,age:18&#125;,</span><br><span class="line">&#123;id:1,name:&quot;znl&quot;,age:18&#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p><p>查询语句：<br><code>db.student(集合name).find();</code></p><p>设定条件查询：<br><code>db.student.find({ &quot;_id&quot; : ObjectId(&quot;5bd01c825f0d528d36a2c06f&quot;)});</code><br>查询id对应的数据<br><code>db.student.find({age:18,name:&quot;张三&quot;});</code><br>查询所有的age是18并且name是张三的人<br><code>db.student.findOne({age:18,name:&quot;张三&quot;});</code><br>查询单条符合条件的数据</p><p>操作符-查询有多少条数据：<br><code>db.student.find().count();</code><br>或<br><code>db.student.find().length();</code><br>返回数据总条数</p><p>查询符合条件数据的条数：<br><code>db.student.find({name:&quot;张三&quot;}).length();</code><br>返回符合name:”张三”的条数</p><h3 id="数据库更新命令"><a href="#数据库更新命令" class="headerlink" title="数据库更新命令"></a>数据库更新命令</h3><p>更新原有的字段的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;张三&quot;&#125;,&#123;$set:&#123;</span><br><span class="line">      name:&quot;刘五&quot;,</span><br><span class="line">      age:45</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure></p><p>把匹配到的<code>name:&quot;张三&quot;</code>的数据都更新成 <code>name:&quot;刘五&quot;, age:45</code><br>也可以新增没有的字段 直接写入就可以<br><strong>$set ：有这个字段就修改 没有这个字段就新增</strong></p><p>删除一个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;张三&quot;&#125;，&#123;$unset:&#123;</span><br><span class="line">    age:1</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure></p><p>查询<code>name:张三</code>的一条数据 然后删除它的age字段</p><p>修改多条：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.student.updateMany(&#123;&quot;sex&quot;:&quot;man&quot;&#125;,&#123;$set:&#123;</span><br><span class="line">    aihao:&quot;玩游戏&quot;</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure></p><p>把符合<code>sex:man</code>的语句都新增（修改）一条<code>aihao:&quot;玩游戏&quot;</code><br><strong>$set ：有则修改 无则新增</strong></p><p>更新多条数据方法2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.student.update(&#123;name:&quot;张三&quot;&#125;,&#123;$set:&#123;</span><br><span class="line">      name:&quot;王五&quot;</span><br><span class="line">&#125;&#125;, &#123;</span><br><span class="line">     multi:true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>参考文档：<a href="https://docs.mongodb.com/manual/tutorial/query-documents/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/query-documents/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据库基本概念&quot;&gt;&lt;a href=&quot;#数据库基本概念&quot; class=&quot;headerlink&quot; title=&quot;数据库基本概念&quot;&gt;&lt;/a&gt;数据库基本概念&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;数据库（Database）基本概念：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数
      
    
    </summary>
    
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Node.js文件系统（fs）与流（stream）</title>
    <link href="http://yoursite.com/2018/11/08/NodeJs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88fs%EF%BC%89%E4%B8%8E%E6%B5%81%EF%BC%88stream%EF%BC%89/"/>
    <id>http://yoursite.com/2018/11/08/NodeJs文件系统（fs）与流（stream）/</id>
    <published>2018-11-08T06:04:55.000Z</published>
    <updated>2018-11-10T08:25:55.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件系统（File-System）："><a href="#文件系统（File-System）：" class="headerlink" title="文件系统（File System）："></a><strong>文件系统（File System）：</strong></h2><ol><li>在Node中，文件系统的交互是非常重要的，服务器的本质就是将本地的文件发送给客户端，</li><li>Node通过fs模块来和文件系统进行交互，该模块提供了一些标准的文件访问API类打开、读取、写入文件、以及与其交互。</li><li>要是用fs模块，首先要从核心模块中加载； 使用 const fs= require(‘fs’) ; 来引入</li></ol><h3 id="fs使用特点："><a href="#fs使用特点：" class="headerlink" title="fs使用特点："></a>fs使用特点：</h3><ol><li>fs模块中的所有操作都有两种形式可供选择同步和异步，</li><li>同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。</li><li>异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//1\. 引入模块</span><br><span class="line">const fs= require(&quot;fs&quot;);</span><br><span class="line">// console.log(fs)</span><br><span class="line"></span><br><span class="line">//2\. 打开文件</span><br><span class="line">// fs.open 异步读取（通常用异步 需设置回调函数）  </span><br><span class="line">// fs.openSync 同步读取（读取时会阻塞线程）</span><br><span class="line"></span><br><span class="line">let hello = fs.openSync(&quot;hello.txt&quot;, &quot;w&quot;);</span><br><span class="line">//                     不存在会自动新建</span><br><span class="line"></span><br><span class="line">//3\. 写入内容</span><br><span class="line">fs.writeFileSync(hello,&apos;hello word!&apos;);</span><br><span class="line"></span><br><span class="line">//4\. 保存并退出</span><br><span class="line">fs.closeSync(hello);</span><br></pre></td></tr></table></figure><p> <a href="https://github.com/AnsonZnl/StudyNodeJS/blob/master/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AF%BE%E6%97%B630-%E8%AF%BE%E6%97%B634%E7%AC%94%E8%AE%B0.md#%E8%AF%BE%E6%97%B631" target="_blank" rel="noopener"></a></p><h3 id="文件操作："><a href="#文件操作：" class="headerlink" title="文件操作："></a>文件操作：</h3><ol><li>打开文件：<br><code>fs.open(path,flags[,mode],callback)</code><br>异步打开 异步都是回调 回调嵌套回调<br><code>fs.openSync(path,flags[,mode])</code><br>同步打开 </li></ol><p>文件标记（flags）： <a href="http://nodejs.cn/api/fs.html#fs_fs_open_path_flags_mode_callback" target="_blank" rel="noopener">http://nodejs.cn/api/fs.html#fs_fs_open_path_flags_mode_callback</a></p><p>一、同步打开文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//1\. 引入模块 </span><br><span class="line">let fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//2.打开文件 同步</span><br><span class="line">var fd=fs.openSync(&apos;1.txt&apos;, &apos;w&apos;);</span><br><span class="line"></span><br><span class="line">//3.写入内容</span><br><span class="line">fs.writeFileSync(fd,&quot;hello world!&quot;); </span><br><span class="line"></span><br><span class="line">//4\. 保存并关闭</span><br><span class="line">fs.closeSync(fd);</span><br></pre></td></tr></table></figure></p><p> 二、异步打开文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//1.引入模块</span><br><span class="line">let fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//2\. 打开文件</span><br><span class="line">fs.open(&apos;1.txt&apos;, &apos;a&apos;, (err, fd)=&gt;&#123;</span><br><span class="line">    //2.1判断是否出错</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        //正确 2.2写入文件</span><br><span class="line">        fs.writeFile(fd, &quot;今天天.....气真好！&quot;, (err)=&gt;&#123;</span><br><span class="line">             //2.2.1 写入成功</span><br><span class="line">             if(!err)&#123;</span><br><span class="line">                 console.log(&apos;写入成功&apos;);</span><br><span class="line">             &#125;else&#123;</span><br><span class="line">                 throw err;</span><br><span class="line">             &#125;</span><br><span class="line">             //2.3 关闭文件</span><br><span class="line">             fs.close(fd, (err)=&gt;&#123;</span><br><span class="line">                 if(!err)&#123;</span><br><span class="line">                     console.log(&apos;文件以保存并关闭&apos;)</span><br><span class="line">                 &#125;else&#123;</span><br><span class="line">                     throw err;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/AnsonZnl/StudyNodeJS/blob/master/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AF%BE%E6%97%B630-%E8%AF%BE%E6%97%B634%E7%AC%94%E8%AE%B0.md#%E8%AF%BE%E6%97%B632" target="_blank" rel="noopener"></a></p><h3 id="使用文件流写入"><a href="#使用文件流写入" class="headerlink" title="使用文件流写入"></a>使用文件流写入</h3><p>文件流写入： <a href="http://nodejs.cn/api/fs.html#fs_fs_createwritestream_path_options" target="_blank" rel="noopener">http://nodejs.cn/api/fs.html#fs_fs_createwritestream_path_options</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//同步操作</span><br><span class="line"></span><br><span class="line">//1\. 引入模块</span><br><span class="line">let fs= require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//2.建立通道</span><br><span class="line">let ws = fs.createWriteStream(&apos;fsw.txt&apos;)</span><br><span class="line"></span><br><span class="line">//3.打开通道</span><br><span class="line">ws.once(&apos;open&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;通道已经打开&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&apos;close&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;通道已经关闭&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//4\. 写入内容</span><br><span class="line">ws.write(&apos;我爱你，&apos;);</span><br><span class="line">ws.write(&apos;我爱你，&apos;);</span><br><span class="line">ws.write(&apos;我爱你，&apos;);</span><br></pre></td></tr></table></figure><p> <a href="https://github.com/AnsonZnl/StudyNodeJS/blob/master/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AF%BE%E6%97%B630-%E8%AF%BE%E6%97%B634%E7%AC%94%E8%AE%B0.md#%E8%AF%BE%E6%97%B633" target="_blank" rel="noopener"></a></p><h3 id="读写文件："><a href="#读写文件：" class="headerlink" title="读写文件："></a>读写文件：</h3><p>文档地址：<a href="http://nodejs.cn/api/fs.html#fs_fs_readfile_path_options_callback" target="_blank" rel="noopener">http://nodejs.cn/api/fs.html#fs_fs_readfile_path_options_callback</a><br>读取文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//1\. 引入模块</span><br><span class="line">let fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//2\. 读取文件</span><br><span class="line">fs.readFile(&apos;source/hello.txt&apos;,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">    //判断是否成功</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(data);//</span><br><span class="line">        // console.log(data.toString());</span><br><span class="line">        //data 默认读取的是二进制 使用toString() 方法转换成</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">读取图片：</span><br><span class="line"></span><br><span class="line">//3\. 读取图片</span><br><span class="line">fs.readFile(&quot;source/psb.jpg&quot;,(err,data)=&gt;&#123;</span><br><span class="line">    //判断是否成功</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        //写入图片</span><br><span class="line">        fs.writeFile(&apos;img.jpg&apos;, data, (err)=&gt;&#123;</span><br><span class="line">            if(!err)&#123;</span><br><span class="line">                console.log(&apos;写入成功！&apos;)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                throw err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/AnsonZnl/StudyNodeJS/blob/master/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AF%BE%E6%97%B630-%E8%AF%BE%E6%97%B634%E7%AC%94%E8%AE%B0.md#%E8%AF%BE%E6%97%B634" target="_blank" rel="noopener"></a></p><p><strong>读取视频:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//1\. 引入模块</span><br><span class="line">let fs= require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//2\. 读取视频</span><br><span class="line">fs.readFile(&apos;source/cddbb.mp4&apos;, (err, data)=&gt;&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        // 写入视频</span><br><span class="line">        fs.writeFile(&apos;nmx.mp4&apos;, data, (err)=&gt;&#123;</span><br><span class="line">            if(!err)&#123;</span><br><span class="line">                console.log(&apos;写入成功！&apos;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                throw err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//3\. 流式文件的读入（批量文件处理）</span><br><span class="line">let re= fs.createReadStream(&apos;source/cddbb.mp4&apos;);</span><br><span class="line">//建立读取流</span><br><span class="line">let ws= fs.createWriteStream(&apos;新建的视频.mp4&apos;);</span><br><span class="line">//建立写入流</span><br><span class="line"></span><br><span class="line">//4\. 创建管道</span><br><span class="line">re.pipe(ws);//文件流传输</span><br><span class="line">console.log(&apos;文件流传输完成&apos;)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.jb51.net/article/133553.htm" target="_blank" rel="noopener">详解NodeJS文件系统fs</a><br>我的GitHub总结的<a href="https://github.com/AnsonZnl/StudyNodeJS" target="_blank" rel="noopener">NodeJS笔记</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文件系统（File-System）：&quot;&gt;&lt;a href=&quot;#文件系统（File-System）：&quot; class=&quot;headerlink&quot; title=&quot;文件系统（File System）：&quot;&gt;&lt;/a&gt;&lt;strong&gt;文件系统（File System）：&lt;/stro
      
    
    </summary>
    
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Node.js中的Buffer</title>
    <link href="http://yoursite.com/2018/11/05/Node%E4%B8%AD%E7%9A%84Buffer/"/>
    <id>http://yoursite.com/2018/11/05/Node中的Buffer/</id>
    <published>2018-11-05T06:04:55.000Z</published>
    <updated>2018-11-04T13:02:32.505Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Buffer介绍"><a href="#Buffer介绍" class="headerlink" title="Buffer介绍"></a>Buffer介绍</h3><p><strong>为什么要用Buffer？</strong></p><ol><li>在Node/ES6 出现之前，前端工程师只需要进行一些简单的额字符串或者ODM操作就可以满足业务需求了，所有对二进制数据比较陌生。</li><li>在node出现之后，前端工程师面对的技术场景发送了变化，可以深入到网络传输、文件操作、图片处理等领域。而这些操作与二进制数据紧密相关。</li><li>在Node中的Buffer，是一个二进制数据容器，数据结构和数组类似，专门用于Node中的数据放。</li></ol><h3 id="新建Buffer"><a href="#新建Buffer" class="headerlink" title="新建Buffer"></a>新建Buffer</h3><p><code>Buffer.alloc(size[, fil[,encoding]])</code><br><code>size</code>:新建的buffer期望的长度<br><code>fill</code>用来预填充新建的Buffer的值 默认0<br><code>encoding</code>: 编码格式  默认：utf-8<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">        十六进制：00- ff</span><br><span class="line">        十进制 ：0- 255</span><br><span class="line">        二进制： 00000000- 11111111</span><br><span class="line">        0 / 1 代表一位 == 比特 </span><br><span class="line">        8bit = 1B</span><br><span class="line">        1kb = 1024 B</span><br><span class="line">        1mkb= 1024Kb</span><br><span class="line">        1GB = 1024m</span><br><span class="line">        1TB = 1024GB</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 2. Buffer.alloc(size[, fill[, encoding]])</span><br><span class="line">/*</span><br><span class="line">类数组使用即可 可遍历 可选择下标等等</span><br><span class="line">初始化： 确定的长度 不能改变</span><br><span class="line">填充值</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">let buffer2= Buffer.alloc(10);//创建了一个长度是10的buffer</span><br><span class="line">buffer2[0]= 10;//可以像使用数组一样使用buffer </span><br><span class="line">buffer2[1]= oxfc;//传一个十六进制的直接取后两位 fc</span><br><span class="line">buffer2[30]= 1;//这点和数组不同 溢出隐藏 </span><br><span class="line">console.log(buffer2);</span><br></pre></td></tr></table></figure></p><h3 id="Buffer使用"><a href="#Buffer使用" class="headerlink" title="Buffer使用"></a>Buffer使用</h3><p><strong>使用新方法使用Buffer </strong></p><ol><li>Buffer.form(str):将一个字符串转换成buffer</li><li>Buffer.alloc(size):创建一个指定大小的buffer</li><li>Buffer.alloUnsafe(size):创建一个指定大小的buffer，但是可能包含敏感数据。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 历史方法</span><br><span class="line">// let buffer = new Buffer(10);//类似 Array(10) 创建十个空间</span><br><span class="line">// console.log(buffer)// &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span><br><span class="line"></span><br><span class="line">//1. 字符串转成二进制</span><br><span class="line">let str= &apos;www.zhangningle.top&apos;;</span><br><span class="line">let buffer= Buffer.from(str);</span><br><span class="line">console.log(buffer);//&lt;Buffer 77 77 77 2e 7a 68 61 6e 67 6e 69 6e 67 6c 65 2e 74 6f 70&gt;</span><br><span class="line">//把buffer转成十进制的</span><br><span class="line">console.log(buffer.toString())//www.zhangningle.top</span><br><span class="line">// 汉字转换成二进制后 一个汉字要用三个字节表示</span><br></pre></td></tr></table></figure></li></ol><p><strong>Buffer总结点：</strong></p><ol><li>Buffer的结构和数组很像，操作方法也和数组很类似。</li><li>Buffer中是以二进制的方式储存数据的</li><li>Buffer是Node自带的，不需要引入，直接可以使用。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Buffer介绍&quot;&gt;&lt;a href=&quot;#Buffer介绍&quot; class=&quot;headerlink&quot; title=&quot;Buffer介绍&quot;&gt;&lt;/a&gt;Buffer介绍&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;为什么要用Buffer？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在No
      
    
    </summary>
    
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Node.js中的CommonJS规范</title>
    <link href="http://yoursite.com/2018/10/18/CommonJS%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/10/18/CommonJS模块化开发/</id>
    <published>2018-10-18T06:04:55.000Z</published>
    <updated>2018-11-04T12:54:20.830Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模块化的意义"><a href="#模块化的意义" class="headerlink" title="模块化的意义"></a>模块化的意义</h3><blockquote><p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。<br>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Node环境中，一个.js文件就称之为一个模块（module）。</p></blockquote><h3 id="理解模块化"><a href="#理解模块化" class="headerlink" title="理解模块化"></a>理解模块化</h3><p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。<br>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</p><p><strong>每一个文件都可以看成一个模块，模块都可以相互暴露和相互引用</strong><br>1.在Node中 一个文件就是一个模块<br>2.在Node中，通过require()函数来引入外部的模块，引入外部模块要加上 ./ 或者 ../<br>3.在Node中，每一个js文件中js代码都是独立运行在一个小闭包中，而不是全局作用域，所以一个模块在不引用的情况下它的的变量和函数都在其他模块中无法访问，如果引用到其他模块中，则被引用的文件相当与在一个闭包内，相当与局部变量。<br>目的：全局变量私有化，避免全局污染。<br>4.暴露模块中的变量和函数：使用exports<br>只需要将需要暴露给外部的变量或者方法设置为exports的属性就行，<br><strong>可以把exports看做一个全局对象，把所有暴露出来的函数和变量都存放在里面</strong><br>Node有一些自带的模块，成为核心模块，他的引用不需要加./ 或者../ 如fs http</p><p><img src="https://upload-images.jianshu.io/upload_images/7072486-0d6620b0e8d69fa6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="171539764614_.pic.jpg"></p><p>引用：<code>const  moudel = require (&#39;./02.js&#39;)</code><br>暴露：<code>exports.str = srt;</code></p><h3 id="CommonJS案例"><a href="#CommonJS案例" class="headerlink" title="CommonJS案例"></a>CommonJS案例</h3><p>先写一个01.js暴露出去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let str = &quot;我是小二&quot;;</span><br><span class="line"></span><br><span class="line">let test = ()=&gt;&#123;</span><br><span class="line">  console.log(&quot;今天天气很好!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">exports.str = str;</span><br><span class="line">exports.test = test;</span><br></pre></td></tr></table></figure></p><p>在写一个02.js把暴露的01.js引用过来, 然后暴露自身<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const module02 = require(&apos;./01.js&apos;);// [ ./  ../ ]</span><br><span class="line"></span><br><span class="line">exports.module02 = module02; //暴露</span><br><span class="line"></span><br><span class="line">console.log(module02.str);//我是小二</span><br></pre></td></tr></table></figure></p><p>最后在写一个03.js 引用暴露的02.js， 这样在03.js 里就包含了 02.js 和01.js了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const module03 = require(&apos;./02.js&apos;);</span><br><span class="line">console.log(module03.module02.str)//我是小二</span><br></pre></td></tr></table></figure></p><p>所以最后是这样的：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-d7e8e14a1da2526b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="161539764109_.pic.jpg" title="">                </div>                <div class="image-caption">161539764109_.pic.jpg</div>            </figure></p><p>类似一个同心圆</p><h3 id="案例：写一个求和-求平均数的模块"><a href="#案例：写一个求和-求平均数的模块" class="headerlink" title="案例：写一个求和 / 求平均数的模块"></a>案例：写一个求和 / 求平均数的模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">exports.sun = (...numbers)=&gt;&#123;</span><br><span class="line">    let result = 0;</span><br><span class="line">    numbers.forEach((itme)=&gt;&#123;</span><br><span class="line">        result += itme;</span><br><span class="line">    &#125;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.avg= (...numbers)=&gt;&#123;</span><br><span class="line">    let result = 0;</span><br><span class="line">    numbers.forEach((itme)=&gt;&#123;</span><br><span class="line">        result+= itme;</span><br><span class="line">    &#125;);</span><br><span class="line">    return result / numbers.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434502419592fd80bbb0613a42118ccab9435af408fd000" target="_blank" rel="noopener">廖雪峰的官网-模块开发</a><br>视频资料：<a href="https://study.163.com/course/courseLearn.htm?courseId=1005269026#/learn/video?lessonId=1052250610&amp;courseId=1005269026" target="_blank" rel="noopener">网易云课堂-叶建秋-从零玩转Node.js</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;模块化的意义&quot;&gt;&lt;a href=&quot;#模块化的意义&quot; class=&quot;headerlink&quot; title=&quot;模块化的意义&quot;&gt;&lt;/a&gt;模块化的意义&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来
      
    
    </summary>
    
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS安装和使用</title>
    <link href="http://yoursite.com/2018/10/11/NodeJS%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/10/11/NodeJS安装和使用/</id>
    <published>2018-10-11T02:04:55.000Z</published>
    <updated>2018-11-04T12:51:34.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="了解Node"><a href="#了解Node" class="headerlink" title="了解Node"></a>了解Node</h2><p>NodeJS :主要应用于开发服务器，做数据API ,设计路由，和前端的主要区别在于，前端主要负责效果和交互、<br>node.js是追求性能极致的产物，主要的三个特点是：<br><strong>单线程、Non-blocking I/O、Event Driven</strong><br>Nodejs和其他后端语言的不同：</p><ol><li>采用单线程， 所以</li><li>需要非阻塞I/O，所以</li><li>需要事件驱动。<br>极大地提高了CPU的利用率：</li><li>node没有自己的语法，使用V8引擎，用的是js，V8引擎解析js，效率非常高。并且V8中很多东西都是异步的，，Node就是站在巨人的肩膀上，把V8中的一些功能一直到服务器上</li><li>没有web容器 就是安装配置完成之后，也么有一个根目录。（使用路由）</li><li>模块：在Node.js中，以模块为单位划分所有的功能，并且提供了一个完成的模块加载机制，我们可以将应用程序划分为各个不同的部分。</li></ol><h2 id="Windows命令"><a href="#Windows命令" class="headerlink" title="Windows命令"></a><strong>Windows命令</strong></h2><p>常用命令：<br><code>dir</code> 列出当下目录下面的所有文件<br><code>cd</code> 进入指定的目录<br><code>md</code> 创建文件夹<br><code>rd</code> 删除文件夹<br><code>cd..</code> 返回上级目录<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-01dca1d0f6a9557b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="81539743638_.pic.jpg" title="">                </div>                <div class="image-caption">81539743638_.pic.jpg</div>            </figure></p><h2 id="Mac命令"><a href="#Mac命令" class="headerlink" title="Mac命令"></a><strong>Mac命令</strong></h2><p><code>cd ~</code>进入我们的家目录<br><code>ls</code> 列出当下目录下面的所有文件<br><code>cd 目录名</code> 进入指定的目录<br><code>touch 文件名.html</code>创建一后缀是html的文件或者一次<code>touch a.txt b.html</code>一次创建多个文件<br><code>mkdir 文件夹名</code> 新建一个文件夹或者一次<code>mkdir a b c</code>新建三个文件夹<br><code>rm 文件/文件夹</code>删除文件/文件夹<br><code>less index.html</code>查看文本文件内容<br><code>pwd</code>看看自己在哪个目录下<br><code>man</code> 查看某个命令的详情<br>cd.. 返回上级目录</p><p><strong>小技巧</strong><br>用 Tab 键自动补齐命令<br>比如想到 /System 目录中去，输入 cd /Sy 然后按一下Tab 键，命令就会自动补齐成 cd /System<br>操作带名字中带有空格的文件和目录<br>空格在命令中写成 空格， 比如要进入 My Documents，命令为 cd My Documents </p><h2 id="进程和线程："><a href="#进程和线程：" class="headerlink" title="进程和线程："></a>进程和线程：</h2><p>  1.进程<br>     系统进行资源分配和调度的基本单位 操作系统的基础，我们写的代码都是放在进程里的 相当于工厂的车间<br>     如：任务管理器<br>  2.线程<br>   九三级的最小计量单位 负责执行进程中的程序，相当于车间里的操作工人，<br>单线程：<br>    js是单线程，时间片分割<br>多线程：<br>   根据任务决定开起几条线程（耗内存）<br>Node服务器：<br>   单线程，但很健壮，后台拥有一个I/O线程池进行调度。分布式服务器部署。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-9f4180b756ad90eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="91539744120_.pic.jpg" title="">                </div>                <div class="image-caption">91539744120_.pic.jpg</div>            </figure></p><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-80d875076390ef25.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="101539744899_.pic.jpg" title="">                </div>                <div class="image-caption">101539744899_.pic.jpg</div>            </figure><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node.js 下载</a><br>有些可能需要配置<strong>全局环境变量</strong><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-43497297131cb4b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="121539745565_.pic.jpg" title="">                </div>                <div class="image-caption">121539745565_.pic.jpg</div>            </figure></p><p>node -v<br>查看版本号</p><p>node 进入node环境，在这个环境中可以执行JavaScript语句</p><h2 id="让node-js跑起来"><a href="#让node-js跑起来" class="headerlink" title="让node.js跑起来"></a>让node.js跑起来</h2><p>跑起来 node.js<br> 1.node 命令行下写js代码<br> 2.新建.js文件 &gt; cd 到指定目录 &gt; node index.js<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-65fcfa08be5b8942.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="131539747126_.pic.jpg" title="">                </div>                <div class="image-caption">131539747126_.pic.jpg</div>            </figure></p><p>建议使用最新的编辑器 有代码提示</p><h2 id="Node-js-的模块发开发"><a href="#Node-js-的模块发开发" class="headerlink" title="Node.js 的模块发开发"></a>Node.js 的模块发开发</h2><p>Node 需要模块化开发：<br>问题： js缺乏模块化的开发<br>解决：后来出现了commonJs （内部） 和npm（外部 包管理系统）它提供了模块的复用和引用,</p><p>CommonJs的出现 主要是为了弥补JavaScript没有模块化开发标准的缺陷，</p><p>CommonJS对模块化的定义：</p><ol><li>模块引用 require（“路径”）<br>2.模块定义<br>3.模块表识<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-7fc679453ac23729.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="141539756072_.pic.jpg" title="">                </div>                <div class="image-caption">141539756072_.pic.jpg</div>            </figure></li></ol><p>总结：<br>1.从文件的角度看，每个js文件就是一个模块，从结构看，多个js文件之间可以相互require，共同实现一个功能，整体上也是一个模块。<br>2.在Node.js中，一个模块中的定义的变量、函数等。都只能在这个文件内部有效；当需要从此文件外部引用这些变量、函数时，必须使用exports进行暴露，然后使用require引用。</p><p>A：我需要引用你  &gt;&gt; require B<br>B:  那好 &gt;&gt; 我暴露</p><p>13课至17课笔记<br>视频地址：<a href="https://study.163.com/course/courseMain.htm?courseId=1005269026" target="_blank" rel="noopener">https://study.163.com/course/courseMain.htm?courseId=1005269026</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;了解Node&quot;&gt;&lt;a href=&quot;#了解Node&quot; class=&quot;headerlink&quot; title=&quot;了解Node&quot;&gt;&lt;/a&gt;了解Node&lt;/h2&gt;&lt;p&gt;NodeJS :主要应用于开发服务器，做数据API ,设计路由，和前端的主要区别在于，前端主要负责效果和交互
      
    
    </summary>
    
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 知识点总结</title>
    <link href="http://yoursite.com/2018/09/17/Vue%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/09/17/Vue知识点总结/</id>
    <published>2018-09-17T06:04:54.000Z</published>
    <updated>2018-11-04T12:42:33.903Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h3><ul><li>vue的生命周期： <code>beforeCreate/created</code>、<code>beforeMount/mounted</code>、<code>beforeUpdate/updated</code>、<code>beforeDestory/destoryed</code></li><li>vue常用指令： <code>v-for</code>、<code>v-bind</code>（缩写形式<code>:prop</code>）、<code>v-on</code>(缩写形式<code>@click=’sss&#39;</code>)、<code>v-if/v-else/v-else-if</code>、<code>v-model</code>、<code>v-once</code>、<code>v-html</code>、<code>v-show</code>…</li><li>vue自定义组件：<code>Vue.component(‘componentName&#39;,{ props:[‘p1’,’p2’], template: ‘&lt;li&gt;&lt;/li&gt;&#39; })</code></li><li>vue常用实例方法和属性: <code>data/$data</code>、<code>methods/$methods</code>、<code>$el</code>、<code>computed</code>(计算属性)、<code>$watch</code>、<code>$set</code>、<code>$event</code>、<code>$emit</code>…</li><li>如果需要更新的属性需要缓存，则使用计算属性的方式，否则可以使用<code>methods</code>里的方法来更新属性（<code>methods</code>里的方法每次重新渲染都会执行）</li><li>计算属性默认提供了<code>getter</code>，你还可以给它设置<code>setter</code></li><li>当你数据变化是异步或者开销较大时，可以使用<code>watch</code>侦听器来响应数据的变化</li><li><code>v-bind:class</code>的值可以是一个对象，可实现类似<code>react</code>中<code>classnames</code>模块的功能</li><li>自定义组件上的<code>class</code>会被渲染拼接到<code>template</code>的根节点的<code>class</code>属性上（自定义组件上可使用<code>v-bind:class</code>来做class的判断显示逻辑）</li><li><code>v-bind:style</code>可以用来绑定内联样式，这个内联样式的值可以由一个对象来定义（类似css in js的模式）,且可以被定义为数组(多个样式对象)</li><li><code>v-bind:style</code>可以使用多重值的形式：<code>&lt;div :style=“display:[‘-webkit-box’,’-ms-flexbox’, ‘flex&#39;]&quot;&gt;&lt;/div&gt;</code></li><li><code>v-if/v-else/v-else-if</code>的时候，可以用key来管理可复用的元素</li><li><code>v-if</code>是’真正’的渲染，它会确保在切换条件过程中条件块内的元素的事件监听器和子组件适时的销毁和重建</li><li><code>v-if</code>是惰性的，初始为假，什么也不做，直到为真的时候才渲染元素</li><li><code>v-show</code>总是渲染元素，只是简单的进行切换</li><li><code>v-if</code>的切换开销大，<code>v-show</code>则是初始渲染开销大，频繁切换使用<code>v-show</code>，运行时经常改变则使用<code>v-if</code></li><li><code>v-if</code>和<code>v-for</code>一起使用时，<code>v-for</code>的优先级更高</li><li><code>v-for</code>可遍历数组，第二个参数是索引</li><li><code>v-for</code>可遍历对象，第二个参数是<code>key</code>，第三个参数是索引</li><li><code>v-for</code>和<code>&lt;template&gt;</code>搭配可减少渲染次数</li><li><code>v-for</code>和自定义组件使用时，需要使用<code>props</code>来传递值</li><li>尽可能的为遍历子元素加上<code>key</code>，获得渲染优化</li><li>数组变异方法：<code>push/pop/unshift/shift/splice/sort/reverse</code>改变原始数组</li><li>数组非变异方法：<code>filter/concat/slice</code> 不改变原始数组，总是返回新数组</li><li>Vue不能检测到数组索引赋值（使用<code>vm.$set</code>解决）和修改<code>length</code>长度赋值(使用<code>splice</code>解决)的情况</li><li>Vue不能检测对象属性的添加和删除(使用<code>vm.$set</code>或<code>Object.assign</code>)</li><li><code>is=“todo-item”</code>这种属性的写法比较适合DOM模板</li><li>事件修饰符，它们可串联使用：<code>.stop</code>、<code>.prevent</code>、<code>.capture</code>、<code>.self</code>、<code>.once</code>、<code>.passive</code>(尤其适合移动端)</li><li><code>.passive</code>不用同时和<code>.prevent</code>使用，后者会被忽略</li><li>按键修饰符: <code>.enter</code>、<code>.tab</code>、<code>.delete</code>、<code>.esc</code>、<code>.space</code>、<code>.up</code>、<code>.down</code>、<code>.left</code>、<code>.right</code></li><li>系统按键修饰符:<code>.ctrl</code>、<code>.alt</code>、<code>.shift</code>、<code>.meta(⌘|⊞|◆)</code>、<code>.exact</code>(允许精确控制系统修饰符组合键触发)</li><li>鼠标修饰符： <code>.left</code>、<code>.right</code>、<code>.middle</code></li><li><code>v-model</code>会忽略表单元素的<code>value</code>、<code>checked</code>、<code>selected</code>，仅仅使用实例中的数据作为数据源</li><li>表单事件修饰符：<code>.lazy</code>、<code>.number</code>、<code>.trim</code></li><li>组件是可复用的vue实例，具有vue实例大多数属性和方法</li><li>组件可复用，每个组件有独立的空间</li><li>组件上的data必须是一个函数，这样做避免影响了其他组件</li><li>通过<code>Vue.component()</code>全局注册的组件可在其被注册后的任何通过<code>new Vue()</code>创建的实例所使用，包含其组件树中的所有组件</li><li>通过插槽<code>&lt;slot&gt;</code>分发内容(其实就是类似于react的children)</li><li>动态组件<code>&lt;component&gt;</code>配合属性<code>is</code>来实现</li><li>解析DOM模板时需要注意下可能会有不生效的情况，需要使用is来传递组件</li></ul><h3 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h3><ul><li>全局注册/局部注册</li><li>局部注册组件在子组件中不可用</li><li>全局注册的行为必须在根Vue实例创建之前发生</li><li><code>camelCase</code>的属性可以在组件中使用<code>kebab-case</code></li><li>可以以对象的模式指定每一个<code>props</code>属性的类型</li><li>父级<code>props</code>的更新会向下流动，反之则不行</li><li>由于JavaScript对象和数组是引用传入的，所以当子组件对props的改变将会影响到父组件</li><li>props类型校验可以是原生构造对象的中的任意一个，也可以自定义检验类型，通过<code>instanceof</code>检查</li><li>对于绝大多数特性来说，外部传入的值会替换掉组件内部设置好的值，如input的type属性，但有的属性则是会进行合并，如class</li><li><code>inhertAttrs:false</code>设置不希望根元素继承特性，可以使用<code>$attrs</code>属性来设置继承的目标元素</li><li><code>v-on</code>在设置事件监听器时，会把事件名全部转换成小写，推荐始终使用<code>kebab-case</code>的事件名</li><li><code>v-model</code>可以使用自定义组件中的<code>model</code>属性自定义</li><li>父组件模板的所有东西都会在父级作用域内编译，子组件的所有内容都会在子组件作用域内编译</li><li>插槽(<code>&lt;slot&gt;&lt;/slot&gt;</code>)/具名插槽(<code>&lt;slot name=“header&quot;&gt;&lt;/slot&gt;</code>)/作用域插槽(<code>slot/slot-scope</code>)</li><li><code>&lt;keep-alive&gt;</code>组件可用来缓存被切换后隐藏的组件的状态</li><li><code>$root</code>访问根实例，<code>$parent</code>访问父组件实例(不推荐)</li><li>父组件访问子组件，使用<code>$refs</code>属性来获取设置了<code>ref</code>属性的子组件</li><li><code>provide</code>属性允许我们指定要分享给后代组件使用的方法，然后后代组件使用<code>inject</code>属性来获得祖先组件分享的方法(依赖注入)</li><li><p>事件侦听器（<code>$emit</code>派发的事件）</p><ul><li><code>v-on</code> 指令侦听</li><li><code>$on</code> 侦听一个事件</li><li><code>$once</code> 一次性侦听一个事件</li><li><code>$off</code> 停止侦听一个事件</li></ul></li><li>慎用递归组件</li><li>尽量避免组件的循环引用</li><li>优先使用<code>template</code>来定义模板，而不是<code>inline-template</code></li><li><code>$forceUpdate</code>来强制更新view</li><li>组件包含大量静态内容时，可使用<code>v-once</code>来标记，缓存静态内容</li></ul><h3 id="过渡-amp-动画"><a href="#过渡-amp-动画" class="headerlink" title="过渡 &amp; 动画"></a>过渡 &amp; 动画</h3><ul><li><code>transition</code>组件控制过渡动画，可以给任何元素和组件添加进入/离开过渡</li><li><p>当插入或删除<code>transition</code>中的元素时，vue会做如下处理</p><ul><li>自动嗅探元素是否使用了css过渡和动画，适当时机添加/删除类名</li><li>元素的钩子函数会在适当时机被调用</li><li>元素既没有钩子函数也没有css动画，插入和删除操作在下一帧立即执行（浏览器逐帧动画机制）</li></ul></li><li><p>过渡的类名</p><ul><li><code>v-enter/v-enter-active/v-enter-to</code></li><li><code>v-leave/v-leave-active/v-leave-to</code></li></ul></li><li>css动画用法同css过渡，区别是类名<code>v-enter</code>不会在DOM插入后立即删除，而是在<code>animationend</code>事件触发时删除</li><li><p>自定义过渡类名，使用以下属性指定:</p><ul><li><code>enter-class/enter-active-class/enter-to-class</code></li><li><code>leave-class/leave-active-class/leave-to-class</code></li><li>自定义类名优先级高于普通的类名</li></ul></li><li>使用<code>typ</code>e属性设置<code>transition</code>或<code>animation</code>来申明vue使用的动画类型</li><li><code>transition</code>组件上使用<code>duration</code>来设置动画执行的时间</li><li><p>可以使用钩子函数</p><ul><li><code>beforeEnter/enter/afterEnter/enterCancelled</code></li><li><code>beforeLeave/leave/afterLeave/leaveCancelled</code></li><li>钩子函数使用<code>v-on</code>指令绑定</li><li>钩子和结合过渡和动画使用，也可以单独使用</li><li>在<code>enter/leave</code>中，必须使用<code>done()</code>来进行回调，否则会同步调用，过渡或动画会立即完成</li><li>对于纯使用JavaScript来进行的动画，推荐使用<code>v-bind:css=“false”</code>来取消css的检测，减少css的影响</li></ul></li><li><p>可使用<code>apear</code>设置初始渲染的过渡</p><ul><li><code>apear/apear-active/apear-to</code></li><li><code>beforeApear/apear/afterApear/apearCancelled</code></li></ul></li><li>多元素过渡，设置唯一<code>key</code></li><li><p>过渡模式:</p><ul><li><code>In-out</code> 新元素先过渡，完成后当前元素过渡离开</li><li><code>out-in</code> 当前元素先过渡，完成后新元素过渡进入</li><li><code>默认行为</code>：进入和离开同时发生</li></ul></li><li>多个组件过渡使用动态组件实现</li><li><p>列表过渡 <code>&lt;transition-group&gt;</code></p><ul><li>以真实元素呈现，默认为<code>&lt;span&gt;</code>，可使用tag更改呈现标签</li><li>过渡模式不可用</li><li>内部需要唯一<code>key</code></li></ul></li><li>列表排序过渡，使用的是<code>FLIP</code>动画，使用类名<code>v-move</code>来定义class</li></ul><h3 id="可复用性-amp-组合"><a href="#可复用性-amp-组合" class="headerlink" title="可复用性 &amp; 组合"></a>可复用性 &amp; 组合</h3><ul><li><code>mixins</code>混入属性发生冲突时，以组件数据优先（一层属性深度浅合并）</li><li><code>mixins</code>混入方法发生冲突时，会将函数合并为一个数组，优先执行混入方法，其次执行组件方法</li><li><code>Vue.extend</code>策略和<code>mixins</code>相同</li><li>慎用全局混入</li><li>合并策略可以自定义（参考<code>vuex</code>的具体实现：<code>Vue.config.optionMergeStrategies</code>）</li><li>全局自定义指令：<code>Vue.directive()</code></li><li>局部自定义指令：属性<code>directives</code>，类型为<code>Object</code></li><li><p>钩子函数</p><ul><li><strong>bind</strong> 指令第一次绑定到元素时调用，只执行一次，可用于一次性初始化设置</li><li><strong>inserted</strong> 元素插入父节点时调用</li><li><strong>update</strong> 所有VNode更新时调用，可能发生在子<em>VNode</em>之前</li><li><strong>componentUpdated</strong> 指令所在组件在<em>VNode</em>和其子<em>VNode</em>更新后调用</li><li><strong>unbind</strong> 指令与元素解绑时调用</li></ul></li><li><p>钩子函数都会被传入以下参数：</p><ul><li><strong>el</strong> 指令绑定元素，可操作DOM</li><li><strong>binding</strong> 指令描述对象</li><li><strong>vnode</strong> Vue生成的虚拟节点</li><li><strong>oldVnode</strong> 上一个<code>Vnode</code>，仅在<code>update</code>和<code>componentUpdated</code>中使用</li></ul></li><li>指令接受所有合法的JavaScript表达式</li></ul><h3 id="渲染函数-amp-JSX"><a href="#渲染函数-amp-JSX" class="headerlink" title="渲染函数 &amp; JSX"></a>渲染函数 &amp; JSX</h3><ul><li><code>render</code>函数接受<code>createElement</code>方法作为参数</li><li><code>createElement</code>方法的作用是创建一个虚拟节点(VNode)</li><li><code>createElement</code>参数比较复杂，参照官网：参数</li><li>组件树中的<code>VNodes</code>必须唯一</li><li>render中的<code>v-if/v-for</code>可以使用<code>if/else</code>和<code>map</code>重写</li><li>插槽使用<code>this.$slot.default</code>访问，作用域插槽使用<code>this.$scopeSlots.default</code>访问和设置</li><li>可以使用插件<code>babel-plugin-transform-vue-jsx</code>支持JSX语法</li><li>将h作为<code>createElement</code>的别名是Vue生态的一个惯例，也是JSX要求的</li><li>函数式组件 关键词：functional</li><li>函数式组件渲染开销低，但相应的，它不会出现在Vue devtools的组件树里边</li><li>函数式组件要求你自己实现同名特性的替换与智能合并</li><li>Vue的模板实际编译成了<code>render</code>方法实现的<code>VNode</code>，可以使用<code>Vue.compile()</code>方法来输出编译结果</li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul><li><p>插件会为vue提供全局的功能，包括但不限于以下几种：</p><ul><li>添加全局的属性或方法，如<a href="https://github.com/karol-f/vue-custom-element" target="_blank" rel="noopener">vue-custom-element</a></li><li>添加全局的资源（指令、过滤器、过渡等），如：<a href="https://github.com/vuejs/vue-touch" target="_blank" rel="noopener">vue-touch</a></li><li>通过全局<code>mixins</code>添加一些组件选项，如：<a href="https://github.com/vuejs/vue-touch" target="_blank" rel="noopener">vue-router</a></li><li>添加Vue实例方法，通过添加到<code>Vue.prototype</code>上实现</li><li>一个独立的库，同时有自己的API，又实现以上部分功能，如：<a href="https://github.com/vuejs/vue-touch" target="_blank" rel="noopener">vue-router</a></li></ul></li><li>Vue插件有一个公开的方法<code>install</code>，第一个参数是Vue构造器，第二个参数是一个可选对象。</li><li>插件的使用通过全局方法<code>Vue.use(MyPlugin)</code>使用，只会注册一次插件</li><li>在CommonJS中，应该始终显式的调用<code>Vue.use</code>方法</li><li>社区插件列表<a href="https://github.com/vuejs/awesome-vue#components--libraries" target="_blank" rel="noopener">awesome-vue</a></li></ul><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; msg | filter &#125;&#125;</span><br><span class="line">&lt;div v-bind=“msg | filter&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>全局过滤器使用Vue.filter()创建</li><li>局部过滤器使用对象属性filters创建</li><li>过滤器函数总是接收表达式的值作为第一个参数，过滤器可以有多个，值依次向后传递</li><li>过滤器可以接收额外的参数</li></ul><h3 id="构建-amp-部署"><a href="#构建-amp-部署" class="headerlink" title="构建 &amp; 部署"></a>构建 &amp; 部署</h3><ul><li><code>&lt;script&gt;</code>标签引入<code>[vue.min.js](https://vuejs.org/js/vue.min.js)</code></li><li><p>使用<code>vue-cli</code></p><ul><li>webpack + vue-loader</li><li>browserify + vueify</li><li>rollup + rollup-plugin-vue</li></ul></li><li>利用钩子函数<code>Vue.config.errorHandler</code>定义配置来跟踪运行时错误，可以搭配<code>[Sentry](https://sentry.io/)</code>使用（<a href="https://sentry.io/for/vue/" target="_blank" rel="noopener">集成配置</a>）</li><li>单文件组件（<code>.vue</code>文件）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础知识：&quot;&gt;&lt;a href=&quot;#基础知识：&quot; class=&quot;headerlink&quot; title=&quot;基础知识：&quot;&gt;&lt;/a&gt;基础知识：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;vue的生命周期： &lt;code&gt;beforeCreate/created&lt;/code&gt;、&lt;code&gt;be
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="Vue.js" scheme="http://yoursite.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Array的push与unshift方法性能比较分析</title>
    <link href="http://yoursite.com/2018/09/01/Array%E7%9A%84push%E4%B8%8Eunshift%E6%96%B9%E6%B3%95%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/09/01/Array的push与unshift方法性能比较分析/</id>
    <published>2018-09-01T12:45:23.000Z</published>
    <updated>2018-09-01T11:58:10.805Z</updated>
    
    <content type="html"><![CDATA[<p>从原理就可以知道，unshift的效率是较低的。原因是，它每添加一个元素，都要把现有元素往下移一个位置。但到底效率差异有多大呢？下面来测试一下。<br>测试环境的主要硬件：CPU T7100（1.8G）；内存4G DDR2 667；硬盘5400转。主要软件：操作系统为Windows 7；浏览器为Firefox 3.6.9。测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ ], s = +new Date; </span><br><span class="line">// push性能测试 </span><br><span class="line">for (var i = 0; i &lt; 50000; i++) &#123; </span><br><span class="line">　　arr.push(i); </span><br><span class="line">&#125; </span><br><span class="line">console.log(+new Date - s); </span><br><span class="line">s = +new Date; </span><br><span class="line">arr = [ ]; </span><br><span class="line">// unshift性能测试 </span><br><span class="line">for (var i = 0; i &lt; 50000; i++) &#123; </span><br><span class="line">　　arr.unshift(i); </span><br><span class="line">&#125; </span><br><span class="line">console.log(+new Date - s);</span><br></pre></td></tr></table></figure></p><p>这段代码分别执行了50000次push和unshift操作，运行一次以后，得出结果：<br>12<br>1152<br>可见，unshift比push要慢差不多100倍！因此，平时还是要慎用unshift，特别是对大数组。那如果一定要达到unshift的效果，有没有其他方法呢？答案是肯定的。<br>Array有一个叫做reverse的方法，能够把一个数组反转。先把要放进数组的元素用push添加，再执行一次reverse，就达到了unshift的效果。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 50000; i++) &#123; </span><br><span class="line">　　arr.push(i); </span><br><span class="line">&#125; </span><br><span class="line">arr.reverse(); </span><br><span class="line"></span><br><span class="line">//reverse的性能又如何呢，下面再来测试：</span><br><span class="line">var arr = [ ], s = +new Date; </span><br><span class="line">for (var i = 0; i &lt; 50000; i++) &#123; </span><br><span class="line">　　arr.push(i); </span><br><span class="line">&#125; </span><br><span class="line">arr.reverse(); </span><br><span class="line">console.log(+new Date - s);</span><br></pre></td></tr></table></figure></p><p>结果是：<br>12<br>可见，reverse性能极高，甚至于没有额外的消耗，可以放心使用。</p><p>当你的才华撑不起你的野心的时候、请潜下心、低下头、好好学习、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从原理就可以知道，unshift的效率是较低的。原因是，它每添加一个元素，都要把现有元素往下移一个位置。但到底效率差异有多大呢？下面来测试一下。&lt;br&gt;测试环境的主要硬件：CPU T7100（1.8G）；内存4G DDR2 667；硬盘5400转。主要软件：操作系统为Win
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>焦虑的汤药</title>
    <link href="http://yoursite.com/2018/08/21/%E7%84%A6%E8%99%91%E7%9A%84%E6%B1%A4%E8%8D%AF/"/>
    <id>http://yoursite.com/2018/08/21/焦虑的汤药/</id>
    <published>2018-08-21T12:45:23.000Z</published>
    <updated>2018-10-19T09:23:57.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何正确使用时间"><a href="#如何正确使用时间" class="headerlink" title="如何正确使用时间"></a>如何正确使用时间</h1><p>你是否时常会焦虑时间过的很快，没时间学习，本文将会分享一些个人的见解。</p><h2 id="花时间补基础，读文档"><a href="#花时间补基础，读文档" class="headerlink" title="花时间补基础，读文档"></a>花时间补基础，读文档</h2><p>在工作中我们时常会花很多时间去 debug，但是你是否发现很多问题最终只是你基础不扎实或者文档没有仔细看。</p><p>基础是你技术的基石，一定要花时间打好基础，而不是追各种新的技术。一旦你的基础扎实，学习各种新的技术也肯定不在话下，因为新的技术，究其根本都是相通的。</p><p>文档同样也是一门技术的基础。一个优秀的库，开发人员肯定已经把如何使用这个库都写在文档中了，仔细阅读文档一定会是少写 bug 的最省事路子。</p><h2 id="学会搜索"><a href="#学会搜索" class="headerlink" title="学会搜索"></a>学会搜索</h2><p>如果你还在使用百度搜索编程问题，请尽快抛弃这个垃圾搜索引擎。同样一个关键字，使用百度和谷歌，谷歌基本完胜的。即使你使用中文在谷歌中搜索，得到的结果也往往是谷歌占优，所以如果你想迅速的通过搜索引擎来解决问题，那一定是谷歌。</p><h2 id="学点英语"><a href="#学点英语" class="headerlink" title="学点英语"></a>学点英语</h2><p>说到英语，一定是大家所最不想听的。其实我一直认为程序员学习英语是简单的，因为我们工作中是一直接触着英语，并且看懂技术文章，文档所需要的单词量是极少的。我时常在群里看到大家发出一个问题的截图问什么原因，其实在截图中英语已经很明白的说明了问题的所在，如果你的英语过关，完全不需要浪费时间来提问和搜索。所以我认为学点英语也是节省时间中很重要的一点。</p><p>那么如何去学习呢，chrome 装个翻译插件，直接拿英文文档或文章读，不会的就直接划词翻译，然后记录下这个单词并背诵。每天花半小时看点英文文档和文章，坚持两个月，你的英语水平不说别的，看文档和文章绝对不会有难题了。这一定是一个很划算的个人时间投资，花点时间学习英语，能为你将来的技术之路铺平很多坎。</p><h2 id="画个图，想一想再做"><a href="#画个图，想一想再做" class="headerlink" title="画个图，想一想再做"></a>画个图，想一想再做</h2><p>你是否遇到过这种问题，需求一下来，看一眼，然后马上就按照设计稿开始做了，可能中间出个问题导致你需要返工。</p><p>如果你存在这样的问题，我很推荐在看到设计稿和需求的时候花点时间想一想，画一画。考虑一下设计稿中是否可以找到可以拆分出来的复用组件，是否存在之前写过的组件。该如何组织这个界面，数据的流转是怎么样的。然后画一下这个页面的需求，最后再动手做。</p><h2 id="利用好下班时间学习"><a href="#利用好下班时间学习" class="headerlink" title="利用好下班时间学习"></a>利用好下班时间学习</h2><p>说到下班时间，那可能就有人说了公司很迟下班，这其实是国内很普遍的情况。但是我认为正常的加班是可以的，但是强制的加班就是在损耗你的身体和前途。</p><p>可以这么说，大部分的 996 公司，加班的这些时间并不会增加你的技术，无非就是在写一些重复的业务逻辑。也许你可以拿到更多的钱，但是代价是身体还有前途。程序员是靠技术吃饭的，如果你长久呆在一个长时间加班的公司，不能增长你的技术还要吞噬你的下班学习时间，那么你一定会废掉的。如果你遇到了这种情况，只能推荐尽快跳槽到非 996 的公司。</p><p>那么如果你有足够的下班时间，一定要花上 1， 2 小时去学习，上班大家基本都一样，技术的精进就是看下班以后的那几个小时了。如果你能利用好下班时间来学习，坚持下去，时间一定会给你很好的答复。</p><h2 id="列好-ToDo"><a href="#列好-ToDo" class="headerlink" title="列好 ToDo"></a>列好 ToDo</h2><p>我喜欢规划好一段时间内要做的事情，并且要把事情拆分为小点。给 ToDo 列好优先级，紧急的优先级最高。相同优先级的我喜欢先做简单的，因为这样一旦完成就能划掉一个，提高成就感。</p><h2 id="反思和整理"><a href="#反思和整理" class="headerlink" title="反思和整理"></a>反思和整理</h2><p>每周末都会花上点时间整理下本周记录的笔记和看到的不错文章。然后考虑下本周完成的工作和下周准备要完成的工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何正确使用时间&quot;&gt;&lt;a href=&quot;#如何正确使用时间&quot; class=&quot;headerlink&quot; title=&quot;如何正确使用时间&quot;&gt;&lt;/a&gt;如何正确使用时间&lt;/h1&gt;&lt;p&gt;你是否时常会焦虑时间过的很快，没时间学习，本文将会分享一些个人的见解。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
    
      <category term="生活感悟" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>webpack4快速入门</title>
    <link href="http://yoursite.com/2018/08/11/Webpack%204%20%E5%92%8C%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%EF%BC%88%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8webpack4%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8C%E7%9C%8B%E6%87%82%E4%BA%86%E4%BD%A0%E5%B0%B1%E5%85%A5%E9%97%A8%E4%BA%86%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/11/Webpack 4 和单页应用入门（史上最全webpack4入门教程，看懂了你就入门了）/</id>
    <published>2018-08-11T12:45:23.000Z</published>
    <updated>2018-10-19T09:35:36.267Z</updated>
    
    <content type="html"><![CDATA[<p><strong>可以说是我目前看到最详细的 webpack 4 入门文章。<br>基本看完这个，基本也算一个合格的初级webpack配置工程师了。</strong></p><blockquote><p>webpack 更新到了 4.0，官网还没有更新文档。因此把教程更新一下，方便大家用起 webpack 4。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-30b8f96f6314cf58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="webpack" title="">                </div>                <div class="image-caption">webpack</div>            </figure> <h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#写在开头" target="_blank" rel="noopener"></a>写在开头</h2><p><del>先说说为什么要写这篇文章，最初的原因是组里的小朋友们看了 <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> 文档后，表情都是这样的：摘自 webpack 一篇文档的评论区）</del></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-7cc744905b9edb5e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wtf" title="">                </div>                <div class="image-caption">wtf</div>            </figure> <p><del>是的，即使是外国佬也在吐槽这文档不是人能看的。回想起当年自己啃 webpack 文档的血与泪的往事，觉得有必要整一个教程，可以让大家看完后愉悦地搭建起一个 webpack 打包方案的项目。</del></p><p>官网新的 <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> 文档现在写的很详细了，能看英文的小伙伴可以直接去看官网。</p><p>可能会有人问 webpack 到底有什么用，你不能上来就糊我一脸代码让我马上搞，我照着搞了一遍结果根本没什么用，都是骗人的。所以，在说 webpack 之前，我想先谈一下前端打包方案这几年的演进历程，在什么场景下，我们遇到了什么问题，催生出了应对这些问题的工具。了解了需求和目的之后，你就知道什么时候 webpack 可以帮到你。我希望我用完之后很爽，你们用完之后也是。</p><h2 id="先说说前端打包方案的黑暗历史"><a href="#先说说前端打包方案的黑暗历史" class="headerlink" title="先说说前端打包方案的黑暗历史"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#先说说前端打包方案的黑暗历史" target="_blank" rel="noopener"></a>先说说前端打包方案的黑暗历史</h2><p>在很长的一段前端历史里，是不存在打包这个说法的。那个时候页面基本是纯静态的或者服务端输出的，没有 AJAX，也没有 jQuery。那个时候的 JavaScript 就像个玩具，用处大概就是在侧栏弄个时钟，用 media player 放个 mp3 之类的脚本，代码量不是很多，直接放在 <code>&lt;script&gt;</code> 标签里或者弄个 js 文件引一下就行，日子过得很轻松愉快。</p><p>随后的几年，人们开始尝试在一个页面里做更多的事情。容器的显示，隐藏，切换。用 css 写的弹层，图片轮播等等。但如果一个页面内不能向服务器请求数据，能做的事情毕竟有限的，代码的量也能维持在页面交互逻辑范围内。这时候很多人开始突破一个页面能做的事情的范围，使用隐藏的 iframe 和 flash 等作为和服务器通信的桥梁，新世界的大门慢慢地被打开，在一个页面内和服务器进行数据交互，意味着以前需要跳转多个页面的事情现在可以用一个页面搞定。但由于 iframe 和 flash 技术过于 tricky 和复杂，并没能得到广泛的推广。</p><p>直到 Google 推出 Gmail 的时候（2004 年），人们意识到了一个被忽略的接口，<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequest</a>, 也就是我们俗称的 AJAX, 这是一个使用方便的，兼容性良好的服务器通信接口。从此开始，我们的页面开始玩出各种花来了，前端一下子出现了各种各样的库，<a href="http://prototypejs.org/" target="_blank" rel="noopener">Prototype</a>、<a href="https://dojotoolkit.org/" target="_blank" rel="noopener">Dojo</a>、<a href="http://mootools.net/" target="_blank" rel="noopener">MooTools</a>、<a href="https://www.sencha.com/products/extjs/" target="_blank" rel="noopener">Ext JS</a>、<a href="https://jquery.com/" target="_blank" rel="noopener">jQuery</a>…… 我们开始往页面里插入各种库和插件，我们的 js 文件也就爆炸了。</p><p>随着 js 能做的事情越来越多，引用越来越多，文件越来越大，加上当时大约只有 2Mbps 左右的网速，下载速度还不如 3G 网络，对 js 文件的压缩和合并的需求越来越强烈，当然这里面也有把代码混淆了不容易被盗用等其他因素在里面。<a href="http://crockford.com/javascript/jsmin" target="_blank" rel="noopener">JSMin</a>、<a href="http://yui.github.io/yuicompressor/" target="_blank" rel="noopener">YUI Compressor</a>、<a href="https://developers.google.com/closure/compiler/" target="_blank" rel="noopener">Closure Compiler</a>、<a href="http://lisperator.net/uglifyjs/" target="_blank" rel="noopener">UglifyJS</a> 等 js 文件压缩合并工具陆陆续续诞生了。压缩工具是有了，但我们得要执行它，最简单的办法呢，就是 windows 上搞个 bat 脚本，mac / linux 上搞个 bash 脚本，哪几个文件要合并在一块的，哪几个要压缩的，发布的时候运行一下脚本，生成压缩后的文件。</p><p>基于合并压缩技术，项目越做越大，问题也越来越多，大概就是以下这些问题：</p><ul><li>库和插件为了要给他人调用，肯定要找个地方注册，一般就是在 window 下申明一个全局的函数或对象。难保哪天用的两个库在全局用同样的名字，那就冲突了。</li><li>库和插件如果还依赖其他的库和插件，就要告知使用人，需要先引哪些依赖库，那些依赖库也有自己的依赖库的话，就要先引依赖库的依赖库，以此类推。</li></ul><p>恰好就在这个时候（2009 年），随着后端 JavaScript 技术的发展，人们提出了 <a href="http://wiki.commonjs.org/wiki/Modules/1.1.1" target="_blank" rel="noopener">CommonJS</a> 的模块化规范，大概的语法是： 如果 <code>a.js</code> 依赖 <code>b.js</code> 和 <code>c.js</code>， 那么就在 <code>a.js</code> 的头部，引入这些依赖文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var b = require(&apos;./b&apos;)</span><br><span class="line">var c = require(&apos;./c&apos;)</span><br></pre></td></tr></table></figure><p>那么变量 <code>b</code> 和 <code>c</code> 会是什么呢？那就是 b.js 和 c.js 导出的东西，比如 b.js 可以这样导出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.square = function(num) &#123;</span><br><span class="line">  return num * num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在 a.js 使用这个 <code>square</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var n = b.square(2)</span><br></pre></td></tr></table></figure><p>如果 c.js 依赖 d.js， 导出的是一个 <code>Number</code>， 那么可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var d = require(&apos;./d&apos;)</span><br><span class="line">module.exports = d.PI // 假设 d.PI 的值是 3.14159</span><br></pre></td></tr></table></figure><p>那么 a.js 中的变量 <code>c</code> 就是数字 <code>3.14159</code>，具体的语法规范可以查看 Node.js 的 <a href="https://nodejs.org/api/modules.html" target="_blank" rel="noopener">文档</a>。</p><p>但是 CommonJS 在浏览器内并不适用。因为 <code>require()</code> 的返回是同步的，意味着有多个依赖的话需要一个一个依次下载，堵塞了 js 脚本的执行。所以人们就在 CommonJS 的基础上定义了 <a href="https://github.com/amdjs/amdjs-api" target="_blank" rel="noopener">Asynchronous Module Definition (AMD)</a> 规范(2011 年），使用了异步回调的语法来并行下载多个依赖项，比如作为入口的 a.js 可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;./b&apos;, &apos;./c&apos;], function(b, c) &#123;</span><br><span class="line">  var n = b.square(2)</span><br><span class="line">  console.log(c)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>相应的导出语法也是异步回调方式，比如 <code>c.js</code> 依赖 <code>d.js</code>， 就写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;./d&apos;], function(d) &#123;</span><br><span class="line">  return d.PI</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到，定义一个模块是使用 <code>define()</code> 函数，<code>define()</code> 和 <code>require()</code> 的区别是，<code>define()</code> 必须要在回调函数中返回一个值作为导出的东西，<code>require()</code> 不需要导出东西，因此回调函数中不需要返回值，也无法作为被依赖项被其他文件导入，因此一般用于入口文件，比如页面中这样加载 <code>a.js</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/a&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>以上是 AMD 规范的基本用法，更详细的就不多说了（反正也淘汰了～），有兴趣的可以看 <a href="http://requirejs.org/docs/api.html" target="_blank" rel="noopener">这里</a>。</p><p>js 模块化问题基本解决了，css 和 html 也没闲着。什么 <a href="http://lesscss.org/" target="_blank" rel="noopener">less</a>，<a href="http://sass-lang.com/" target="_blank" rel="noopener">sass</a>，<a href="http://stylus-lang.com/" target="_blank" rel="noopener">stylus</a> 的 css 预处理器横空出世，说能帮我们简化 css 的写法，自动给你加 vendor prefix。html 在这期间也出现了一堆模板语言，什么 <a href="http://handlebarsjs.com/" target="_blank" rel="noopener">handlebars</a>，<a href="http://www.embeddedjs.com/" target="_blank" rel="noopener">ejs</a>，<a href="http://jade-lang.com/" target="_blank" rel="noopener">jade</a>，可以把 ajax 拿到的数据插入到模板中，然后用 innerHTML 显示到页面上。</p><p>托 AMD 和 CSS 预处理和模板语言的福，我们的编译脚本也洋洋洒洒写了百来行。命令行脚本有个不好的地方，就是 windows 和 mac/linux 是不通用的，如果有跨平台需求的话，windows 要装个可以执行 bash 脚本的命令行工具，比如 msys（目前最新的是 <a href="http://msys2.github.io/" target="_blank" rel="noopener">msys2</a>），或者使用 php 或 python 等其他语言的脚本来编写，对于非全栈型的前端程序员来说，写 bash / php / python 还是很生涩的。因此我们需要一个简单的打包工具，可以利用各种编译工具，编译 / 压缩 js、css、html、图片等资源。然后 <a href="http://gruntjs.com/" target="_blank" rel="noopener">Grunt</a> 产生了（2012 年），配置文件格式是我们最爱的 js，写法也很简单，社区有非常多的插件支持各种编译、lint、测试工具。一年多后另一个打包工具 <a href="http://gulpjs.com/" target="_blank" rel="noopener">gulp</a> 诞生了，扩展性更强，采用流式处理效率更高。</p><p>依托 AMD 模块化编程，SPA(Single-page application) 的实现方式更为简单清晰，一个网页不再是传统的类似 word 文档的页面，而是一个完整的应用程序。SPA 应用有一个总的入口页面，我们通常把它命名为 index.html、app.html、main.html，这个 html 的 <code>&lt;body&gt;</code> 一般是空的，或者只有总的布局（layout），比如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-e4d8616ab5f42665.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure> <p>布局会把 header、nav、footer 的内容填上，但 main 区域是个空的容器。这个作为入口的 html 最主要的工作是加载启动 SPA 的 js 文件，然后由 js 驱动，根据当前浏览器地址进行路由分发，加载对应的 AMD 模块，然后该 AMD 模块执行，渲染对应的 html 到页面指定的容器内（比如图中的 main）。在点击链接等交互时，页面不会跳转，而是由 js 路由加载对应的 AMD 模块，然后该 AMD 模块渲染对应的 html 到容器内。</p><p>虽然 AMD 模块让 SPA 更容易地实现，但小问题还是很多的：</p><ul><li>不是所有的第三方库都是 AMD 规范的，这时候要配置 <code>shim</code>，很麻烦。</li><li>虽然 RequireJS 支持通过插件把 html 作为依赖加载，但 html 里面的 <code>&lt;img&gt;</code> 的路径是个问题，需要使用绝对路径并且保持打包后的图片路径和打包前的路径不变，或者使用 html 模板语言把 <code>src</code> 写成变量，在运行时生成。</li><li>不支持动态加载 css，变通的方法是把所有的 css 文件合并压缩成一个文件，在入口的 html 页面一次性加载。</li><li>SPA 项目越做越大，一个应用打包后的 js 文件到了几 MB 的大小。虽然 <a href="http://requirejs.org/docs/optimization.html" target="_blank" rel="noopener">r.js</a> 支持分模块打包，但配置很麻烦，因为模块之间会互相依赖，在配置的时候需要 exclude 那些通用的依赖项，而依赖项要在文件里一个个检查。</li><li>所有的第三方库都要自己一个个的下载，解压，放到某个目录下，更别提更新有多麻烦了。虽然可以用 <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a> 包管理工具，但 npm 的包都是 CommonJS 规范的，给后端 Node.js 用的，只有部分支持 AMD 规范，而且在 npm 3 之前，这些包有依赖项的话也是不能用的。后来有个 <a href="https://bower.io/" target="_blank" rel="noopener">bower</a> 包管理工具是专门的 web 前端仓库，这里的包一般都支持 AMD 规范。</li><li>AMD 规范定义和引用模块的语法太麻烦，上面介绍的 AMD 语法仅是最简单通用的语法，API 文档里面还有很多变异的写法，特别是当发生循环引用的时候（a 依赖 b，b 依赖 a），需要使用其他的 <a href="http://requirejs.org/docs/api.html#circular" target="_blank" rel="noopener">语法</a> 解决这个问题。而且 npm 上很多前后端通用的库都是 CommonJS 的语法。后来很多人又开始尝试使用 ES6 模块规范，如何引用 ES6 模块又是一个大问题。</li><li>项目的文件结构不合理，因为 grunt/gulp 是按照文件格式批量处理的，所以一般会把 js、html、css、图片分别放在不同的目录下，所以同一个模块的文件会散落在不同的目录下，开发的时候找文件是个麻烦的事情。code review 时想知道一个文件是哪个模块的也很麻烦，解决办法比如又要在 imgs 目录下建立按模块命名的文件夹，里面再放图片。</li></ul><p>到了这里，我们的主角 webpack 登场了（2012 年）（此处应有掌声）。</p><p>和 webpack 差不多同期登场的还有 <a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a>。这里简单介绍一下 Browserify。Browserify 的目的是让前端也能用 CommonJS 的语法 <code>require(&#39;module&#39;)</code> 来加载 js。它会从入口 js 文件开始，把所有的 <code>require()</code> 调用的文件打包合并到一个文件，这样就解决了异步加载的问题。那么 Browserify 有什么不足之处导致我不推荐使用它呢? 主要原因有下面几点：</p><ul><li>最主要的一点，Browserify 不支持把代码打包成多个文件，在有需要的时候加载。这就意味着访问任何一个页面都会全量加载所有文件。</li><li>Browserify 对其他非 js 文件的加载不够完善，因为它主要解决的是 <code>require()</code> js 模块的问题，其他文件不是它关心的部分。比如 html 文件里的 img 标签，它只能转成 <a href="https://en.wikipedia.org/wiki/Data_URI_scheme" target="_blank" rel="noopener">Data URI</a> 的形式，而不能替换为打包后的路径。</li><li>因为上面一点 Browserify 对资源文件的加载支持不够完善，导致打包时一般都要配合 gulp 或 grunt 一块使用，无谓地增加了打包的难度。</li><li>Browserify 只支持 CommonJS 模块规范，不支持 AMD 和 ES6 模块规范，这意味旧的 AMD 模块和将来的 ES6 模块不能使用。</li></ul><p>基于以上几点，Browserify 并不是一个理想的选择。那么 webpack 是否解决了以上的几个问题呢? 废话，不然介绍它干嘛。那么下面章节我们用实战的方式来说明 webpack 是怎么解决上述的问题的。</p><h2 id="上手先搞一个简单的-SPA-应用"><a href="#上手先搞一个简单的-SPA-应用" class="headerlink" title="上手先搞一个简单的 SPA 应用"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#上手先搞一个简单的-spa-应用" target="_blank" rel="noopener"></a>上手先搞一个简单的 SPA 应用</h2><p>一上来步子太大容易扯到蛋，让我们先弄个最简单的 webpack 配置来热一下身。</p><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#安装-nodejs" target="_blank" rel="noopener"></a>安装 Node.js</h3><p>webpack 是基于我大 Node.js 的打包工具，上来第一件事自然是先安装 Node.js 了，<a href="https://nodejs.org/" target="_blank" rel="noopener">传送门 -&gt;</a>。</p><h3 id="初始化一个项目"><a href="#初始化一个项目" class="headerlink" title="初始化一个项目"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#初始化一个项目" target="_blank" rel="noopener"></a>初始化一个项目</h3><p>我们先随便找个地方，建一个文件夹叫 <code>simple</code>， 然后在这里面搭项目。完成品在 <a href="https://github.com/fenivana/webpack-and-spa-guide/blob/master/examples/simple" target="_blank" rel="noopener">examples/simple</a> 目录，大家搞的时候可以参照一下。我们先看一下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── dist                      打包输出目录，只需部署这个目录到生产环境</span><br><span class="line">├── package.json              项目配置信息</span><br><span class="line">├── node_modules              npm 安装的依赖包都在这里面</span><br><span class="line">├── src                       我们的源代码</span><br><span class="line">│   ├── components            可以复用的模块放在这里面</span><br><span class="line">│   ├── index.html            入口 html</span><br><span class="line">│   ├── index.js              入口 js</span><br><span class="line">│   ├── shared                公共函数库</span><br><span class="line">│   └── views                 页面放这里</span><br><span class="line">└── webpack.config.js         webpack 配置文件</span><br></pre></td></tr></table></figure><p>打开命令行窗口，<code>cd</code> 到刚才建的 simple 目录。然后执行这个命令初始化项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>命令行会要你输入一些配置信息，我们这里一路按回车下去，生成一个默认的项目配置文件 <code>package.json</code>。</p><h3 id="给项目加上语法报错和代码规范检查"><a href="#给项目加上语法报错和代码规范检查" class="headerlink" title="给项目加上语法报错和代码规范检查"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#给项目加上语法报错和代码规范检查" target="_blank" rel="noopener"></a>给项目加上语法报错和代码规范检查</h3><p>我们安装 <a href="http://eslint.org/" target="_blank" rel="noopener">eslint</a>， 用来检查语法报错，当我们书写 js 时，有错误的地方会出现提示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint eslint-config-enough babel-eslint eslint-loader --save-dev</span><br></pre></td></tr></table></figure><p><code>npm install</code> 可以一条命令同时安装多个包，包之间用空格分隔。包会被安装进 <code>node_modules</code> 目录中。</p><p><code>--save-dev</code> 会把安装的包和版本号记录到 <code>package.json</code> 中的 <code>devDependencies</code> 对象中，还有一个 <code>--save</code>， 会记录到 <code>dependencies</code> 对象中，它们的区别，我们可以先简单的理解为打包工具和测试工具用到的包使用 <code>--save-dev</code> 存到 <code>devDependencies</code>， 比如 eslint、webpack。浏览器中执行的 js 用到的包存到 <code>dependencies</code>， 比如 jQuery 等。那么它们用来干嘛的？</p><p>因为有些 npm 包安装是需要编译的，那么导致 windows / mac /linux 上编译出的可执行文件是不同的，也就是无法通用，因此我们在提交代码到 git 上去的时候，一般都会在 <code>.gitignore</code> 里指定忽略 node_modules 目录和里面的文件，这样其他人从 git 上拉下来的项目是没有 node_modules 目录的，这时我们需要运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>它会读取 <code>package.json</code> 中的 <code>devDependencies</code> 和 <code>dependencies</code> 字段，把记录的包的相应版本下载下来。</p><p>这里 <a href="https://github.com/fenivana/eslint-config-enough" target="_blank" rel="noopener">eslint-config-enough</a> 是配置文件，它规定了代码规范，要使它生效，我们要在 <code>package.json</code> 中添加内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;eslintConfig&quot;: &#123;</span><br><span class="line">    &quot;extends&quot;: &quot;enough&quot;,</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">      &quot;browser&quot;: true,</span><br><span class="line">      &quot;node&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业界最有名的语法规范是 <a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">airbnb</a> 出品的，但它规定的太死板了，比如不允许使用 <code>for-of</code> 和 <code>for-in</code> 等。感兴趣的同学可以参照 <a href="https://www.npmjs.com/package/eslint-config-airbnb" target="_blank" rel="noopener">这里</a> 安装使用。</p><p><a href="https://github.com/babel/babel-eslint" target="_blank" rel="noopener">babel-eslint</a> 是 <code>eslint-config-enough</code> 依赖的语法解析库，替代 eslint 默认的解析库以支持还未标准化的语法。比如 <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">import()</a>。</p><p><a href="https://github.com/MoOx/eslint-loader" target="_blank" rel="noopener">eslint-loader</a> 用于在 webpack 编译的时候检查代码，如果有错误，webpack 会报错。</p><p>项目里安装了 eslint 还没用，我们的 IDE 和编辑器也得要装 eslint 插件支持它。</p><p><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a> 需要安装 <a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint" target="_blank" rel="noopener">ESLint 扩展</a></p><p><a href="https://atom.io/" target="_blank" rel="noopener">atom</a> 需要安装 <a href="https://atom.io/packages/linter" target="_blank" rel="noopener">linter</a> 和 <a href="https://atom.io/packages/linter-eslint" target="_blank" rel="noopener">linter-eslint</a> 这两个插件，装好后重启生效。</p><p><a href="https://www.jetbrains.com/webstorm/" target="_blank" rel="noopener">WebStorm</a> 需要在设置中打开 eslint 开关：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-c0a131357700b656.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure> <h3 id="写几个页面"><a href="#写几个页面" class="headerlink" title="写几个页面"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#写几个页面" target="_blank" rel="noopener"></a>写几个页面</h3><p>我们写一个最简单的 SPA 应用来介绍 SPA 应用的内部工作原理。首先，建立 src/index.html 文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>它是一个空白页面，注意这里我们不需要自己写 <code>&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</code>， 因为打包后的文件名和路径可能会变，所以我们用 webpack 插件帮我们自动加上。</p><p>src/index.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 引入 router</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line"></span><br><span class="line">// 启动 router</span><br><span class="line">router.start()</span><br></pre></td></tr></table></figure><p>src/router.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 引入页面文件</span><br><span class="line">import foo from &apos;./views/foo&apos;</span><br><span class="line">import bar from &apos;./views/bar&apos;</span><br><span class="line"></span><br><span class="line">const routes = &#123;</span><br><span class="line">  &apos;/foo&apos;: foo,</span><br><span class="line">  &apos;/bar&apos;: bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Router 类，用来控制页面根据当前 URL 切换</span><br><span class="line">class Router &#123;</span><br><span class="line">  start() &#123;</span><br><span class="line">    // 点击浏览器后退 / 前进按钮时会触发 window.onpopstate 事件，我们在这时切换到相应页面</span><br><span class="line">    // https://developer.mozilla.org/en-US/docs/Web/Events/popstate</span><br><span class="line">    window.addEventListener(&apos;popstate&apos;, () =&gt; &#123;</span><br><span class="line">      this.load(location.pathname)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 打开页面时加载当前页面</span><br><span class="line">    this.load(location.pathname)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 前往 path，变更地址栏 URL，并加载相应页面</span><br><span class="line">  go(path) &#123;</span><br><span class="line">    // 变更地址栏 URL</span><br><span class="line">    history.pushState(&#123;&#125;, &apos;&apos;, path)</span><br><span class="line">    // 加载页面</span><br><span class="line">    this.load(path)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 加载 path 路径的页面</span><br><span class="line">  load(path) &#123;</span><br><span class="line">    // 首页</span><br><span class="line">    if (path === &apos;/&apos;) path = &apos;/foo&apos;</span><br><span class="line">    // 创建页面实例</span><br><span class="line">    const view = new routes[path]()</span><br><span class="line">    // 调用页面方法，把页面加载到 document.body 中</span><br><span class="line">    view.mount(document.body)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 导出 router 实例</span><br><span class="line">export default new Router()</span><br></pre></td></tr></table></figure><p>src/views/foo/index.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 引入 router</span><br><span class="line">import router from &apos;../../router&apos;</span><br><span class="line"></span><br><span class="line">// 引入 html 模板，会被作为字符串引入</span><br><span class="line">import template from &apos;./index.html&apos;</span><br><span class="line"></span><br><span class="line">// 引入 css, 会生成 &lt;style&gt; 块插入到 &lt;head&gt; 头中</span><br><span class="line">import &apos;./style.css&apos;</span><br><span class="line"></span><br><span class="line">// 导出类</span><br><span class="line">export default class &#123;</span><br><span class="line">  mount(container) &#123;</span><br><span class="line">    document.title = &apos;foo&apos;</span><br><span class="line">    container.innerHTML = template</span><br><span class="line">    container.querySelector(&apos;.foo__gobar&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">      // 调用 router.go 方法加载 /bar 页面</span><br><span class="line">      router.go(&apos;/bar&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src/views/bar/index.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 引入 router</span><br><span class="line">import router from &apos;../../router&apos;</span><br><span class="line"></span><br><span class="line">// 引入 html 模板，会被作为字符串引入</span><br><span class="line">import template from &apos;./index.html&apos;</span><br><span class="line"></span><br><span class="line">// 引入 css, 会生成 &lt;style&gt; 块插入到 &lt;head&gt; 头中</span><br><span class="line">import &apos;./style.css&apos;</span><br><span class="line"></span><br><span class="line">// 导出类</span><br><span class="line">export default class &#123;</span><br><span class="line">  mount(container) &#123;</span><br><span class="line">    document.title = &apos;bar&apos;</span><br><span class="line">    container.innerHTML = template</span><br><span class="line">    container.querySelector(&apos;.bar__gofoo&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">      // 调用 router.go 方法加载 /foo 页面</span><br><span class="line">      router.go(&apos;/foo&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助 webpack 插件，我们可以 <code>import</code> html, css 等其他格式的文件，文本类的文件会被储存为变量打包进 js 文件，其他二进制类的文件，比如图片，可以自己配置，小图片作为 <a href="https://en.wikipedia.org/wiki/Data_URI_scheme" target="_blank" rel="noopener">Data URI</a> 打包进 js 文件，大文件打包为单独文件，我们稍后再讲这块。</p><p>其他的 src 目录下的文件大家自己浏览，拷贝一份到自己的工作目录，等会打包时会用到。</p><p>页面代码这样就差不多搞定了，接下来我们进入 webpack 的安装和配置阶段。现在我们还没有讲 webpack 配置所以页面还无法访问，等会弄好 webpack 配置后再看页面实际效果。</p><h3 id="安装-webpack-和-Babel"><a href="#安装-webpack-和-Babel" class="headerlink" title="安装 webpack 和 Babel"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#安装-webpack-和-babel" target="_blank" rel="noopener"></a>安装 webpack 和 Babel</h3><p>我们把 webpack 和它的插件安装到项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli webpack-serve html-webpack-plugin html-loader css-loader style-loader file-loader url-loader --save-dev</span><br></pre></td></tr></table></figure><p><a href="https://github.com/webpack/webpack" target="_blank" rel="noopener">webpack</a> 即 webpack 核心库。它提供了很多 <a href="https://webpack.js.org/api/node/" target="_blank" rel="noopener">API</a>, 通过 Node.js 脚本中 <code>require(&#39;webpack&#39;)</code> 的方式来使用 webpack。</p><p><a href="https://github.com/webpack/webpack-cli" target="_blank" rel="noopener">webpack-cli</a> 是 webpack 的命令行工具。让我们可以不用写打包脚本，只需配置打包配置文件，然后在命令行输入 <code>webpack-cli --config webpack.config.js</code> 来使用 webpack, 简单很多。webpack 4 之前命令行工具是集成在 webpack 包中的，4.0 开始 webpack 包本身不再集成 cli。</p><p><a href="https://github.com/webpack-contrib/webpack-serve" target="_blank" rel="noopener">webpack-serve</a> 是 webpack 提供的用来开发调试的服务器，让你可以用 <a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a> 这样的 url 打开页面来调试，有了它就不用配置 <a href="https://nginx.org/en/" target="_blank" rel="noopener">nginx</a> 了，方便很多。</p><p><a href="https://github.com/ampedandwired/html-webpack-plugin" target="_blank" rel="noopener">html-webpack-plugin</a>, <a href="https://github.com/webpack/html-loader" target="_blank" rel="noopener">html-loader</a>, <a href="https://github.com/webpack/css-loader" target="_blank" rel="noopener">css-loader</a>, <a href="https://github.com/webpack/style-loader" target="_blank" rel="noopener">style-loader</a> 等看名字就知道是打包 html 文件，css 文件的插件，大家在这里可能会有疑问，<code>html-webpack-plugin</code> 和 <code>html-loader</code> 有什么区别，<code>css-loader</code> 和 <code>style-loader</code> 有什么区别，我们等会看配置文件的时候再讲。</p><p><a href="https://github.com/webpack/file-loader" target="_blank" rel="noopener">file-loader</a> 和 <a href="https://github.com/webpack/url-loader" target="_blank" rel="noopener">url-loader</a> 是打包二进制文件的插件，具体也在配置文件章节讲解。</p><p>接下来，为了能让不支持 ES6 的浏览器 （比如 IE) 也能照常运行，我们需要安装 <a href="http://babeljs.io/" target="_blank" rel="noopener">babel</a>, 它会把我们写的 ES6 源代码转化成 ES5，这样我们源代码写 ES6，打包时生成 ES5。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-core babel-preset-env babel-loader --save-dev</span><br></pre></td></tr></table></figure><p>这里 <code>babel-core</code> 顾名思义是 babel 的核心编译器。<a href="https://babeljs.io/docs/plugins/preset-env/" target="_blank" rel="noopener">babel-preset-env</a> 是一个配置文件，我们可以使用这个配置文件转换 <a href="http://exploringjs.com/es6/" target="_blank" rel="noopener">ES2015</a>/<a href="https://leanpub.com/exploring-es2016-es2017/read" target="_blank" rel="noopener">ES2016</a>/<a href="http://www.2ality.com/2016/02/ecmascript-2017.html" target="_blank" rel="noopener">ES2017</a> 到 ES5，是的，不只 ES6 哦。babel 还有 <a href="http://babeljs.io/docs/plugins/" target="_blank" rel="noopener">其他配置文件</a>。</p><p>光安装了 <code>babel-preset-env</code>，在打包时是不会生效的，需要在 <code>package.json</code> 加入 <code>babel</code> 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;babel&quot;: &#123;</span><br><span class="line">    &quot;presets&quot;: [&quot;env&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包时 babel 会读取 <code>package.json</code> 中 <code>babel</code> 字段的内容，然后执行相应的转换。</p><p><a href="https://github.com/babel/babel-loader" target="_blank" rel="noopener">babel-loader</a> 是 webpack 的插件，我们下面章节再说。</p><h3 id="配置-webpack"><a href="#配置-webpack" class="headerlink" title="配置 webpack"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#配置-webpack" target="_blank" rel="noopener"></a>配置 webpack</h3><p>包都装好了，接下来总算可以进入正题了。我们来创建 webpack 配置文件 <code>webpack.config.js</code>，注意这个文件是在 node.js 中运行的，因此不支持 ES6 的 <code>import</code> 语法。我们来看文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">const history = require(&apos;connect-history-api-fallback&apos;)</span><br><span class="line">const convert = require(&apos;koa-connect&apos;)</span><br><span class="line"></span><br><span class="line">// 使用 WEBPACK_SERVE 环境变量检测当前是否是在 webpack-server 启动的开发环境中</span><br><span class="line">const dev = Boolean(process.env.WEBPACK_SERVE)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  /*</span><br><span class="line">  webpack 执行模式</span><br><span class="line">  development：开发环境，它会在配置文件中插入调试相关的选项，比如 moduleId 使用文件路径方便调试</span><br><span class="line">  production：生产环境，webpack 会将代码做压缩等优化</span><br><span class="line">  */</span><br><span class="line">  mode: dev ? &apos;development&apos; : &apos;production&apos;,</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  配置 source map</span><br><span class="line">  开发模式下使用 cheap-module-eval-source-map, 生成的 source map 能和源码每行对应，方便打断点调试</span><br><span class="line">  生产模式下使用 hidden-source-map, 生成独立的 source map 文件，并且不在 js 文件中插入 source map 路径，用于在 error report 工具中查看 （比如 Sentry)</span><br><span class="line">  */</span><br><span class="line">  devtool: dev ? &apos;cheap-module-eval-source-map&apos; : &apos;hidden-source-map&apos;,</span><br><span class="line"></span><br><span class="line">  // 配置页面入口 js 文件</span><br><span class="line">  entry: &apos;./src/index.js&apos;,</span><br><span class="line"></span><br><span class="line">  // 配置打包输出相关</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 打包输出目录</span><br><span class="line">    path: resolve(__dirname, &apos;dist&apos;),</span><br><span class="line"></span><br><span class="line">    // 入口 js 的打包输出文件名</span><br><span class="line">    filename: &apos;index.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  module: &#123;</span><br><span class="line">    /*</span><br><span class="line">    配置各种类型文件的加载器，称之为 loader</span><br><span class="line">    webpack 当遇到 import ... 时，会调用这里配置的 loader 对引用的文件进行编译</span><br><span class="line">    */</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        /*</span><br><span class="line">        使用 babel 编译 ES6 / ES7 / ES8 为 ES5 代码</span><br><span class="line">        使用正则表达式匹配后缀名为 .js 的文件</span><br><span class="line">        */</span><br><span class="line">        test: /\.js$/,</span><br><span class="line"></span><br><span class="line">        // 排除 node_modules 目录下的文件，npm 安装的包不需要编译</span><br><span class="line">        exclude: /node_modules/,</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        use 指定该文件的 loader, 值可以是字符串或者数组。</span><br><span class="line">        这里先使用 eslint-loader 处理，返回的结果交给 babel-loader 处理。loader 的处理顺序是从最后一个到第一个。</span><br><span class="line">        eslint-loader 用来检查代码，如果有错误，编译的时候会报错。</span><br><span class="line">        babel-loader 用来编译 js 文件。</span><br><span class="line">        */</span><br><span class="line">        use: [&apos;babel-loader&apos;, &apos;eslint-loader&apos;]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        // 匹配 html 文件</span><br><span class="line">        test: /\.html$/,</span><br><span class="line">        /*</span><br><span class="line">        使用 html-loader, 将 html 内容存为 js 字符串，比如当遇到</span><br><span class="line">        import htmlString from &apos;./template.html&apos;;</span><br><span class="line">        template.html 的文件内容会被转成一个 js 字符串，合并到 js 文件里。</span><br><span class="line">        */</span><br><span class="line">        use: &apos;html-loader&apos;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        // 匹配 css 文件</span><br><span class="line">        test: /\.css$/,</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        先使用 css-loader 处理，返回的结果交给 style-loader 处理。</span><br><span class="line">        css-loader 将 css 内容存为 js 字符串，并且会把 background, @font-face 等引用的图片，</span><br><span class="line">        字体文件交给指定的 loader 打包，类似上面的 html-loader, 用什么 loader 同样在 loaders 对象中定义，等会下面就会看到。</span><br><span class="line">        */</span><br><span class="line">        use: [&apos;style-loader&apos;, &apos;css-loader&apos;]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        /*</span><br><span class="line">        匹配各种格式的图片和字体文件</span><br><span class="line">        上面 html-loader 会把 html 中 &lt;img&gt; 标签的图片解析出来，文件名匹配到这里的 test 的正则表达式，</span><br><span class="line">        css-loader 引用的图片和字体同样会匹配到这里的 test 条件</span><br><span class="line">        */</span><br><span class="line">        test: /\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\?.+)?$/,</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        使用 url-loader, 它接受一个 limit 参数，单位为字节(byte)</span><br><span class="line"></span><br><span class="line">        当文件体积小于 limit 时，url-loader 把文件转为 Data URI 的格式内联到引用的地方</span><br><span class="line">        当文件大于 limit 时，url-loader 会调用 file-loader, 把文件储存到输出目录，并把引用的文件路径改写成输出后的路径</span><br><span class="line"></span><br><span class="line">        比如 views/foo/index.html 中</span><br><span class="line">        &lt;img src=&quot;smallpic.png&quot;&gt;</span><br><span class="line">        会被编译成</span><br><span class="line">        &lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAA...&quot;&gt;</span><br><span class="line"></span><br><span class="line">        而</span><br><span class="line">        &lt;img src=&quot;largepic.png&quot;&gt;</span><br><span class="line">        会被编译成</span><br><span class="line">        &lt;img src=&quot;/f78661bef717cf2cc2c2e5158f196384.png&quot;&gt;</span><br><span class="line">        */</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  配置 webpack 插件</span><br><span class="line">  plugin 和 loader 的区别是，loader 是在 import 时根据不同的文件名，匹配不同的 loader 对这个文件做处理，</span><br><span class="line">  而 plugin, 关注的不是文件的格式，而是在编译的各个阶段，会触发不同的事件，让你可以干预每个编译阶段。</span><br><span class="line">  */</span><br><span class="line">  plugins: [</span><br><span class="line">    /*</span><br><span class="line">    html-webpack-plugin 用来打包入口 html 文件</span><br><span class="line">    entry 配置的入口是 js 文件，webpack 以 js 文件为入口，遇到 import, 用配置的 loader 加载引入文件</span><br><span class="line">    但作为浏览器打开的入口 html, 是引用入口 js 的文件，它在整个编译过程的外面，</span><br><span class="line">    所以，我们需要 html-webpack-plugin 来打包作为入口的 html 文件</span><br><span class="line">    */</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      /*</span><br><span class="line">      template 参数指定入口 html 文件路径，插件会把这个文件交给 webpack 去编译，</span><br><span class="line">      webpack 按照正常流程，找到 loaders 中 test 条件匹配的 loader 来编译，那么这里 html-loader 就是匹配的 loader</span><br><span class="line">      html-loader 编译后产生的字符串，会由 html-webpack-plugin 储存为 html 文件到输出目录，默认文件名为 index.html</span><br><span class="line">      可以通过 filename 参数指定输出的文件名</span><br><span class="line">      html-webpack-plugin 也可以不指定 template 参数，它会使用默认的 html 模板。</span><br><span class="line">      */</span><br><span class="line">      template: &apos;./src/index.html&apos;,</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">      因为和 webpack 4 的兼容性问题，chunksSortMode 参数需要设置为 none</span><br><span class="line">      https://github.com/jantimon/html-webpack-plugin/issues/870</span><br><span class="line">      */</span><br><span class="line">      chunksSortMode: &apos;none&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">配置开发时用的服务器，让你可以用 http://127.0.0.1:8080/ 这样的 url 打开页面来调试</span><br><span class="line">并且带有热更新的功能，打代码时保存一下文件，浏览器会自动刷新。比 nginx 方便很多</span><br><span class="line">如果是修改 css, 甚至不需要刷新页面，直接生效。这让像弹框这种需要点击交互后才会出来的东西调试起来方便很多。</span><br><span class="line"></span><br><span class="line">因为 webpack-cli 无法正确识别 serve 选项，使用 webpack-cli 执行打包时会报错。</span><br><span class="line">因此我们在这里判断一下，仅当使用 webpack-serve 时插入 serve 选项。</span><br><span class="line">issue：https://github.com/webpack-contrib/webpack-serve/issues/19</span><br><span class="line">*/</span><br><span class="line">if (dev) &#123;</span><br><span class="line">  module.exports.serve = &#123;</span><br><span class="line">    // 配置监听端口，默认值 8080</span><br><span class="line">    port: 8080,</span><br><span class="line"></span><br><span class="line">    // add: 用来给服务器的 koa 实例注入 middleware 增加功能</span><br><span class="line">    add: app =&gt; &#123;</span><br><span class="line">      /*</span><br><span class="line">      配置 SPA 入口</span><br><span class="line"></span><br><span class="line">      SPA 的入口是一个统一的 html 文件，比如</span><br><span class="line">      http://localhost:8080/foo</span><br><span class="line">      我们要返回给它</span><br><span class="line">      http://localhost:8080/index.html</span><br><span class="line">      这个文件</span><br><span class="line">      */</span><br><span class="line">      app.use(convert(history()))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="走一个"><a href="#走一个" class="headerlink" title="走一个"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#走一个" target="_blank" rel="noopener"></a>走一个</h3><p>配置 OK 了，接下来我们就运行一下吧。我们先试一下开发环境用的 <code>webpack-serve</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/webpack-serve webpack.config.js</span><br></pre></td></tr></table></figure><p>执行时需要指定配置文件。</p><p>上面的命令适用于 Mac / Linux 等 * nix 系统，也适用于 Windows 上的 PowerShell 和 bash/zsh 环境（<a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" target="_blank" rel="noopener">Windows Subsystem for Linux</a>, <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git Bash</a>、<a href="http://babun.github.io/" target="_blank" rel="noopener">Babun</a>、<a href="http://msys2.github.io/" target="_blank" rel="noopener">MSYS2</a> 等）。安利一下 Windows 同学使用 <a href="https://www.microsoft.com/store/p/ubuntu/9nblggh4msv6" target="_blank" rel="noopener">Ubuntu on Windows</a>，可以避免很多跨平台的问题，比如设置环境变量。</p><p>如果使用 Windows 的 cmd.exe，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules\.bin\webpack-serve webpack.config.js</span><br></pre></td></tr></table></figure><p>npm 会把包的可执行文件安装到 <code>./node_modules/.bin/</code> 目录下，所以我们要在这个目录下执行命令。</p><p>命令执行后，控制台显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">｢wdm｣: Compiled successfully。</span><br></pre></td></tr></table></figure><p>这就代表编译成功了，我们可以在浏览器打开 <code>http://localhost:8080/</code> 看看效果。如果有报错，那可能是什么地方没弄对？请自己仔细检查一下～</p><p>我们可以随意更改一下 src 目录下的源代码，保存后，浏览器里的页面应该很快会有相应变化。</p><p>要退出编译，按 <code>ctrl+c</code>。</p><p>开发环境编译试过之后，我们试试看编译生产环境的代码，命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/webpack-cli</span><br></pre></td></tr></table></figure><p>不需要指定配置文件，默认读取 webpack.config.js</p><p>执行脚本的命令有点麻烦，因此，我们可以利用 npm，把命令写在 <code>package.json</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-serve webpack.config.js&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack-cli&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>package.json</code> 中的 <code>scripts</code> 对象，可以用来写一些脚本命令，命令不需要前缀目录 <code>./node_modules/.bin/</code>，npm 会自动寻找该目录下的命令。我们可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>来启动开发环境。</p><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>来打包生产环境的代码。</p><h2 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#进阶配置" target="_blank" rel="noopener"></a>进阶配置</h2><p>上面的项目虽然可以跑起来了，但有几个点我们还没有考虑到：</p><ul><li>设置静态资源的 url 路径前缀</li><li>各个页面分开打包</li><li>第三方库和业务代码分开打包</li><li>输出的 entry 文件加上 hash</li><li>开发环境关闭 performance.hints</li><li>配置 favicon</li><li>开发环境允许其他电脑访问</li><li>打包时自定义部分参数</li><li>webpack-serve 处理路径带后缀名的文件的特殊规则</li><li>代码中插入环境变量</li><li>简化 import 路径</li><li>优化 babel 编译后的代码性能</li><li>使用 webpack 自带的 ES6 模块处理功能</li><li>使用 autoprefixer 自动创建 css 的 vendor prefixes</li></ul><p>那么，让我们在上面的配置的基础上继续完善，下面的代码我们只写出改变的部分。代码在 <a href="https://github.com/fenivana/webpack-and-spa-guide/blob/master/examples/advanced" target="_blank" rel="noopener">examples/advanced</a> 目录。</p><h3 id="设置静态资源的-url-路径前缀"><a href="#设置静态资源的-url-路径前缀" class="headerlink" title="设置静态资源的 url 路径前缀"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#设置静态资源的-url-路径前缀" target="_blank" rel="noopener"></a>设置静态资源的 url 路径前缀</h3><p>现在我们的资源文件的 url 直接在根目录，比如 <code>http://127.0.0.1:8080/index.js</code>， 这样做缓存控制和 CDN 不是很方便，因此我们给资源文件的 url 加一个前缀，比如 <code>http://127.0.0.1:8080/assets/index.js</code>. 我们来修改一下 webpack 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: &apos;/assets/&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>webpack-serve</code> 也需要修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (dev) &#123;</span><br><span class="line">  module.exports.serve = &#123;</span><br><span class="line">    port: 8080,</span><br><span class="line">    host: &apos;0.0.0.0&apos;,</span><br><span class="line">    dev: &#123;</span><br><span class="line">      /*</span><br><span class="line">      指定 webpack-dev-middleware 的 publicpath</span><br><span class="line">      一般情况下与 output.publicPath 保持一致（除非 output.publicPath 使用的是相对路径）</span><br><span class="line">      https://github.com/webpack/webpack-dev-middleware#publicpath</span><br><span class="line">      */</span><br><span class="line">      publicPath: &apos;/assets/&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    add: app =&gt; &#123;</span><br><span class="line">      app.use(convert(history(&#123;</span><br><span class="line">        index: &apos;/assets/&apos; // index.html 文件在 /assets/ 路径下</span><br><span class="line">      &#125;)))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="各个页面分开打包"><a href="#各个页面分开打包" class="headerlink" title="各个页面分开打包"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#各个页面分开打包" target="_blank" rel="noopener"></a>各个页面分开打包</h3><p>这样浏览器只需加载当前页面所需的代码。</p><p>webpack 可以使用异步加载文件的方式引用模块，我们使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">async</a>/ <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener">await</a> 和 <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">dynamic import</a> 来实现：</p><p>src/router.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 将 async/await 转换成 ES5 代码后需要这个运行时库来支持</span><br><span class="line">import &apos;regenerator-runtime/runtime&apos;</span><br><span class="line"></span><br><span class="line">const routes = &#123;</span><br><span class="line">  // import() 返回 promise</span><br><span class="line">  &apos;/foo&apos;: () =&gt; import(&apos;./views/foo&apos;),</span><br><span class="line">  &apos;/bar.do&apos;: () =&gt; import(&apos;./views/bar.do&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Router &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  // 加载 path 路径的页面</span><br><span class="line">  // 使用 async/await 语法</span><br><span class="line">  async load(path) &#123;</span><br><span class="line">    // 首页</span><br><span class="line">    if (path === &apos;/&apos;) path = &apos;/foo&apos;</span><br><span class="line"></span><br><span class="line">    // 动态加载页面</span><br><span class="line">    const View = (await routes[path]()).default</span><br><span class="line"></span><br><span class="line">    // 创建页面实例</span><br><span class="line">    const view = new View()</span><br><span class="line"></span><br><span class="line">    // 调用页面方法，把页面加载到 document.body 中</span><br><span class="line">    view.mount(document.body)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就不需要在开头把所有页面文件都 import 进来了。</p><p><a href="https://github.com/facebook/regenerator/tree/master/packages/regenerator-runtime" target="_blank" rel="noopener">regenerator-runtime</a> 是 <a href="https://github.com/facebook/regenerator" target="_blank" rel="noopener">regenerator</a> 的运行时库。Babel 通过插件 <a href="https://babeljs.io/docs/plugins/transform-regenerator" target="_blank" rel="noopener">transform-regenerator</a> 使用 <code>regenerator</code> 将 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener">generator</a>函数和 async/await 语法转换成 ES5 语法后，需要运行时库才能正确执行。</p><p>另外因为 <code>import()</code> 还没有正式进入标准，需要使用 <a href="https://babeljs.io/docs/plugins/syntax-dynamic-import/" target="_blank" rel="noopener">syntax-dynamic-import</a> 来解析此语法。 我们可以安装 <a href="https://babeljs.io/docs/plugins/preset-stage-2/" target="_blank" rel="noopener">babel-preset-stage-2</a>，它包含了 <code>import()</code> 和其他 stage 2 的语法支持。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install regenerator-runtime babel-preset-stage-2 --save-dev</span><br></pre></td></tr></table></figure><p><code>package.json</code> 改一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;babel&quot;: &#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">      &quot;env&quot;,</span><br><span class="line">      &quot;stage-2&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 webpack 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    /*</span><br><span class="line">    代码中引用的文件（js、css、图片等）会根据配置合并为一个或多个包，我们称一个包为 chunk。</span><br><span class="line">    每个 chunk 包含多个 modules。无论是否是 js，webpack 都将引入的文件视为一个 module。</span><br><span class="line">    chunkFilename 用来配置这个 chunk 输出的文件名。</span><br><span class="line"></span><br><span class="line">    [chunkhash]：这个 chunk 的 hash 值，文件发生变化时该值也会变。使用 [chunkhash] 作为文件名可以防止浏览器读取旧的缓存文件。</span><br><span class="line"></span><br><span class="line">    还有一个占位符 [id]，编译时每个 chunk 会有一个id。</span><br><span class="line">    我们在这里不使用它，因为这个 id 是个递增的数字，增加或减少一个chunk，都可能导致其他 chunk 的 id 发生改变，导致缓存失效。</span><br><span class="line">    */</span><br><span class="line">    chunkFilename: &apos;[chunkhash].js&apos;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三方库和业务代码分开打包"><a href="#第三方库和业务代码分开打包" class="headerlink" title="第三方库和业务代码分开打包"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#第三方库和业务代码分开打包" target="_blank" rel="noopener"></a>第三方库和业务代码分开打包</h3><p>这样更新业务代码时可以借助浏览器缓存，用户不需要重新下载没有发生变化的第三方库。 Webpack 4 最大的改进便是自动拆分 chunk, 如果同时满足下列条件，chunk 就会被拆分：</p><ul><li>新的 chunk 能被复用，或者模块是来自 node_modules 目录</li><li>新的 chunk 大于 30Kb(min+gz 压缩前）</li><li>按需加载 chunk 的并发请求数量小于等于 5 个</li><li>页面初始加载时的并发请求数量小于等于 3 个</li></ul><p>一般情况只需配置这几个参数即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    使用文件路径的 hash 作为 moduleId。</span><br><span class="line">    虽然我们使用 [chunkhash] 作为 chunk 的输出名，但仍然不够。</span><br><span class="line">    因为 chunk 内部的每个 module 都有一个 id，webpack 默认使用递增的数字作为 moduleId。</span><br><span class="line">    如果引入了一个新文件或删掉一个文件，可能会导致其他文件的 moduleId 也发生改变，</span><br><span class="line">    那么受影响的 module 所在的 chunk 的 [chunkhash] 就会发生改变，导致缓存失效。</span><br><span class="line">    因此使用文件路径的 hash 作为 moduleId 来避免这个问题。</span><br><span class="line">    */</span><br><span class="line">    new webpack.HashedModuleIdsPlugin()</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    /*</span><br><span class="line">    上面提到 chunkFilename 指定了 chunk 打包输出的名字，那么文件名存在哪里了呢？</span><br><span class="line">    它就存在引用它的文件中。这意味着一个 chunk 文件名发生改变，会导致引用这个 chunk 文件也发生改变。</span><br><span class="line"></span><br><span class="line">    runtimeChunk 设置为 true, webpack 就会把 chunk 文件名全部存到一个单独的 chunk 中，</span><br><span class="line">    这样更新一个文件只会影响到它所在的 chunk 和 runtimeChunk，避免了引用这个 chunk 的文件也发生改变。</span><br><span class="line">    */</span><br><span class="line">    runtimeChunk: true,</span><br><span class="line"></span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      /*</span><br><span class="line">      默认 entry 的 chunk 不会被拆分</span><br><span class="line">      因为我们使用了 html-webpack-plugin 来动态插入 &lt;script&gt; 标签，entry 被拆成多个 chunk 也能自动被插入到 html 中，</span><br><span class="line">      所以我们可以配置成 all, 把 entry chunk 也拆分了</span><br><span class="line">      */</span><br><span class="line">      chunks: &apos;all&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack 4 支持更多的手动优化，详见： <a href="https://gist.github.com/sokra/1522d586b8e5c0f5072d7565c2bee693" target="_blank" rel="noopener">https://gist.github.com/sokra/1522d586b8e5c0f5072d7565c2bee693</a></p><p>但正如 webpack 文档中所说，默认配置已经足够优化，在没有测试的情况下不要盲目手动优化。</p><h3 id="输出的-entry-文件加上-hash"><a href="#输出的-entry-文件加上-hash" class="headerlink" title="输出的 entry 文件加上 hash"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#输出的-entry-文件加上-hash" target="_blank" rel="noopener"></a>输出的 entry 文件加上 hash</h3><p>上面我们提到了 <code>chunkFilename</code> 使用 <code>[chunkhash]</code> 防止浏览器读取错误缓存，那么 entry 同样需要加上 hash。 但使用 <code>webpack-serve</code> 启动开发环境时，entry 文件是没有 <code>[chunkhash]</code> 的，用了会报错。 因此我们只在执行 <code>webpack-cli</code> 时使用 <code>[chunkhash]</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: dev ? &apos;[name].js&apos; : &apos;[chunkhash].js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用了 <code>[name]</code> 占位符。解释它之前我们先了解一下 <code>entry</code> 的完整定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    NAME: [FILE1, FILE2, ...]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以定义多个 entry 文件，比如你的项目有多个 html 入口文件，每个 html 对应一个或多个 entry 文件。 然后每个 entry 可以定义由多个 module 组成，这些 module 会依次执行。 在 webpack 4 之前，这是很有用的功能，比如之前提到的第三方库和业务代码分开打包，在以前，我们需要这么配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry &#123;</span><br><span class="line">    main: &apos;./src/index.js&apos;,</span><br><span class="line">    vendor: [&apos;jquery&apos;, &apos;lodash&apos;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>entry 引用文件的规则和 <code>import</code> 是一样的，会寻找 <code>node_modules</code> 里的包。然后结合 <code>CommonsChunkPlugin</code> 把 vendor 定义的 module 从业务代码分离出来打包成一个单独的 chunk。 如果 entry 是一个 module，我们可以不使用数组的形式。</p><p>在 simple 项目中，我们配置了 <code>entry: &#39;./src/index.js&#39;</code>，这是最简单的形式，转换成完整的写法就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: [&apos;./src/index.js&apos;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack 会给这个 entry 指定名字为 <code>main</code>。</p><p>看到这应该知道 <code>[name]</code> 的意思了吧？它就是 entry 的名字。</p><p>有人可能注意到官网文档中还有一个 <code>[hash]</code> 占位符，这个 hash 是整个编译过程产生的一个总的 hash 值，而不是单个文件的 hash 值，项目中任何一个文件的改动，都会造成这个 hash 值的改变。<code>[hash]</code> 占位符是始终存在的，但我们不希望修改一个文件导致所有输出的文件 hash 都改变，这样就无法利用浏览器缓存了。因此这个 <code>[hash]</code> 意义不大。</p><h3 id="开发环境关闭-performance-hints"><a href="#开发环境关闭-performance-hints" class="headerlink" title="开发环境关闭 performance.hints"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#开发环境关闭-performancehints" target="_blank" rel="noopener"></a>开发环境关闭 performance.hints</h3><p>我们注意到运行开发环境是命令行会报一段 warning：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING in asset size limit: The following asset(s) exceed the recommended size limit (250 kB).</span><br><span class="line">This can impact web performance.</span><br></pre></td></tr></table></figure><p>这是说建议每个输出的 js 文件的大小不要超过 250k。但开发环境因为包含了 sourcemap 并且代码未压缩所以一般都会超过这个大小，所以我们可以在开发环境把这个 warning 关闭。</p><p>webpack 配置中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  performance: &#123;</span><br><span class="line">    hints: dev ? false : &apos;warning&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置-favicon"><a href="#配置-favicon" class="headerlink" title="配置 favicon"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#配置-favicon" target="_blank" rel="noopener"></a>配置 favicon</h3><p>在 src 目录中放一张 favicon.png，然后 <code>src/index.html</code> 的 <code>&lt;head&gt;</code> 中插入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;favicon.png&quot;&gt;</span><br></pre></td></tr></table></figure><p>修改 webpack 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.html$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;html-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              /*</span><br><span class="line">              html-loader 接受 attrs 参数，表示什么标签的什么属性需要调用 webpack 的 loader 进行打包。</span><br><span class="line">              比如 &lt;img&gt; 标签的 src 属性，webpack 会把 &lt;img&gt; 引用的图片打包，然后 src 的属性值替换为打包后的路径。</span><br><span class="line">              使用什么 loader 代码，同样是在 module.rules 定义中使用匹配的规则。</span><br><span class="line"></span><br><span class="line">              如果 html-loader 不指定 attrs 参数，默认值是 img:src, 意味着会默认打包 &lt;img&gt; 标签的图片。</span><br><span class="line">              这里我们加上 &lt;link&gt; 标签的 href 属性，用来打包入口 index.html 引入的 favicon.png 文件。</span><br><span class="line">              */</span><br><span class="line">              attrs: [&apos;img:src&apos;, &apos;link:href&apos;]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        /*</span><br><span class="line">        匹配 favicon.png</span><br><span class="line">        上面的 html-loader 会把入口 index.html 引用的 favicon.png 图标文件解析出来进行打包</span><br><span class="line">        打包规则就按照这里指定的 loader 执行</span><br><span class="line">        */</span><br><span class="line">        test: /favicon\.png$/,</span><br><span class="line"></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            // 使用 file-loader</span><br><span class="line">            loader: &apos;file-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              /*</span><br><span class="line">              name：指定文件输出名</span><br><span class="line">              [hash] 为源文件的hash值，[ext] 为后缀。</span><br><span class="line">              */</span><br><span class="line">              name: &apos;[hash].[ext]&apos;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      // 图片文件的加载配置增加一个 exclude 参数</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\?.+)?$/,</span><br><span class="line"></span><br><span class="line">        // 排除 favicon.png, 因为它已经由上面的 loader 处理了。如果不排除掉，它会被这个 loader 再处理一遍</span><br><span class="line">        exclude: /favicon\.png$/,</span><br><span class="line"></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 html-webpack-plugin 接受一个 <code>favicon</code> 参数，可以指定 favicon 文件路径，会自动打包插入到 html 文件中。但它有个 <a href="https://github.com/ampedandwired/html-webpack-plugin/issues/364" target="_blank" rel="noopener">bug</a>，打包后的文件名路径不带 hash，就算有 hash，它也是 [hash]，而不是 [chunkhash]。导致修改代码也会改变 favicon 打包输出的文件名。issue 中提到的 favicons-webpack-plugin 倒是可以用，但它依赖 PhantomJS, 非常大。</p><h3 id="开发环境允许其他电脑访问"><a href="#开发环境允许其他电脑访问" class="headerlink" title="开发环境允许其他电脑访问"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#开发环境允许其他电脑访问" target="_blank" rel="noopener"></a>开发环境允许其他电脑访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const internalIp = require(&apos;internal-ip&apos;)</span><br><span class="line"></span><br><span class="line">module.exports.serve = &#123;</span><br><span class="line">  host: &apos;0.0.0.0&apos;,</span><br><span class="line">  hot: &#123;</span><br><span class="line">    host: &#123;</span><br><span class="line">      client: internalIp.v4.sync(),</span><br><span class="line">      server: &apos;0.0.0.0&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打包时自定义部分参数"><a href="#打包时自定义部分参数" class="headerlink" title="打包时自定义部分参数"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#打包时自定义部分参数" target="_blank" rel="noopener"></a>打包时自定义部分参数</h3><p>在多人开发时，每个人可能需要有自己的配置，比如说 webpack-serve 监听的端口号，如果写死在 webpack 配置里，而那个端口号在某个同学的电脑上被其他进程占用了，简单粗暴的修改 <code>webpack.config.js</code> 会导致提交代码后其他同学的端口也被改掉。</p><p>还有一点就是开发环境、测试环境、生产环境的部分 webpack 配置是不同的，比如 <code>publicPath</code> 在生产环境可能要配置一个 CDN 地址。</p><p>我们在根目录建立一个文件夹 <code>config</code>，里面创建 3 个配置文件：</p><ul><li>default.js: 生产环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  publicPath: &apos;http://cdn.example.com/assets/&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>dev.js: 默认开发环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  publicPath: &apos;/assets/&apos;,</span><br><span class="line"></span><br><span class="line">  serve: &#123;</span><br><span class="line">    port: 8090</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>local.js: 个人本地环境，在 dev.js 基础上修改部分参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const config = require(&apos;./dev&apos;)</span><br><span class="line">config.serve.port = 8070</span><br><span class="line">module.exports = config</span><br></pre></td></tr></table></figure><p><code>package.json</code> 修改 <code>scripts</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;local&quot;: &quot;npm run webpack-serve --config=local&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;npm run webpack-serve --config=dev&quot;,</span><br><span class="line">    &quot;webpack-serve&quot;: &quot;webpack-serve webpack.config.js&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack-cli&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack 配置修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">const url = require(&apos;url&apos;)</span><br><span class="line"></span><br><span class="line">const config = require(&apos;./config/&apos; + (process.env.npm_config_config || &apos;default&apos;))</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    // ...</span><br><span class="line">    publicPath: config.publicPath</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (dev) &#123;</span><br><span class="line">  module.exports.serve = &#123;</span><br><span class="line">    host: &apos;0.0.0.0&apos;,</span><br><span class="line">    port: config.serve.port,</span><br><span class="line">    dev: &#123;</span><br><span class="line">      publicPath: config.publicPath</span><br><span class="line">    &#125;,</span><br><span class="line">    add: app =&gt; &#123;</span><br><span class="line">      app.use(convert(history(&#123;</span><br><span class="line">        index: url.parse(config.publicPath).pathname</span><br><span class="line">      &#125;)))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的关键是 <code>npm run</code> 传进来的自定义参数可以通过 <code>process.env.npm_config_*</code> 获得。参数中如果有 <code>-</code> 会被转成 <code>_</code>。</p><p>还有一点，我们不需要把自己个人用的配置文件提交到 git，所以我们在 <code>.gitignore</code> 中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config/*</span><br><span class="line">!config/default.js</span><br><span class="line">!config/dev.js</span><br></pre></td></tr></table></figure><p>把 <code>config</code> 目录排除掉，但是保留生产环境和 dev 默认配置文件。</p><p>可能有同学注意到了 <code>webpack-cli</code> 可以通过 <a href="https://webpack.js.org/api/cli/#environment-options" target="_blank" rel="noopener">–env</a> 的方式从命令行传参给脚本，遗憾的是 <code>webpack-cli</code> <a href="https://github.com/webpack-contrib/webpack-serve#webpack-function-configs" target="_blank" rel="noopener">不支持</a>。</p><h3 id="webpack-serve-处理带后缀名的文件的特殊规则"><a href="#webpack-serve-处理带后缀名的文件的特殊规则" class="headerlink" title="webpack-serve 处理带后缀名的文件的特殊规则"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#webpack-serve-处理带后缀名的文件的特殊规则" target="_blank" rel="noopener"></a>webpack-serve 处理带后缀名的文件的特殊规则</h3><p>当处理带后缀名的请求时，比如 <a href="http://localhost:8080/bar.do" target="_blank" rel="noopener">http://localhost:8080/bar.do</a> ，<code>connect-history-api-fallback</code> 会认为它应该是一个实际存在的文件，就算找不到该文件，也不会 fallback 到 index.html，而是返回 404。但在 SPA 应用中这不是我们希望的。</p><p>幸好有一个配置选项 <code>disableDotRule: true</code> 可以禁用这个规则，使带后缀的文件当不存在时也能 fallback 到 index.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports.serve = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  add: app =&gt; &#123;</span><br><span class="line">    app.use(convert(history(&#123;</span><br><span class="line">      // ...</span><br><span class="line">      disableDotRule: true,</span><br><span class="line">      htmlAcceptHeaders: [&apos;text/html&apos;, &apos;application/xhtml+xml&apos;] // 需要配合 disableDotRule 一起使用</span><br><span class="line">    &#125;)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码中插入环境变量"><a href="#代码中插入环境变量" class="headerlink" title="代码中插入环境变量"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#代码中插入环境变量" target="_blank" rel="noopener"></a>代码中插入环境变量</h3><p>在业务代码中，有些变量在开发环境和生产环境是不同的，比如域名、后台 API 地址等。还有开发环境可能需要打印调试信息等。</p><p>我们可以使用 <a href="https://webpack.js.org/plugins/define-plugin/" target="_blank" rel="noopener">DefinePlugin</a> 插件在打包时往代码中插入需要的环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">const pkgInfo = require(&apos;./package.json&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      DEBUG: dev,</span><br><span class="line">      VERSION: JSON.stringify(pkgInfo.version),</span><br><span class="line">      CONFIG: JSON.stringify(config.runtimeConfig)</span><br><span class="line">    &#125;),</span><br><span class="line">    // ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefinePlugin 插件的原理很简单，如果我们在代码中写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(DEBUG)</span><br></pre></td></tr></table></figure><p>它会做类似这样的处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;console.log(DEBUG)&apos;.replace(&apos;DEBUG&apos;, true)</span><br></pre></td></tr></table></figure><p>最后生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(true)</span><br></pre></td></tr></table></figure><p>这里有一点需要注意，像这里的 <code>VERSION</code>， 如果我们不对 <code>pkgInfo.version</code> 做 <code>JSON.stringify()</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(VERSION)</span><br></pre></td></tr></table></figure><p>然后做替换操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;console.log(VERSION)&apos;.replace(&apos;VERSION&apos;, &apos;1.0.0&apos;)</span><br></pre></td></tr></table></figure><p>最后生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(1.0.0)</span><br></pre></td></tr></table></figure><p>这样语法就错误了。所以，我们需要 <code>JSON.stringify(pkgInfo.version)</code> 转一下变成 <code>&#39;&quot;1.0.0&quot;&#39;</code>，替换的时候才会带引号。</p><p>还有一点，webpack 打包压缩的时候，会把代码进行优化，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (DEBUG) &#123;</span><br><span class="line">  console.log(&apos;debug mode&apos;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&apos;production mode&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被编译成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (false) &#123;</span><br><span class="line">  console.log(&apos;debug mode&apos;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&apos;production mode&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后压缩优化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;production mode&apos;)</span><br></pre></td></tr></table></figure><h3 id="简化-import-路径"><a href="#简化-import-路径" class="headerlink" title="简化 import 路径"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#简化-import-路径" target="_blank" rel="noopener"></a>简化 import 路径</h3><p>文件 a 引入文件 b 时，b 的路径是相对于 a 文件所在目录的。如果 a 和 b 在不同的目录，藏得又深，写起来就会很麻烦：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import b from &apos;../../../components/b&apos;</span><br></pre></td></tr></table></figure><p>为了方便，我们可以定义一个路径别名（alias）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    &apos;~&apos;: resolve(__dirname, &apos;src&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们可以以 <code>src</code> 目录为基础路径来 <code>import</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import b from &apos;~/components/b&apos;</span><br></pre></td></tr></table></figure><p>html 中的 <code>&lt;img&gt;</code> 标签没法使用这个别名功能，但 <code>html-loader</code> 有一个 <code>root</code> 参数，可以使 <code>/</code> 开头的文件相对于 <code>root</code> 目录解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.html$/,</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: &apos;html-loader&apos;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        root: resolve(__dirname, &apos;src&apos;),</span><br><span class="line">        attrs: [&apos;img:src&apos;, &apos;link:href&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，<code>&lt;img src=&quot;/favicon.png&quot;&gt;</code> 就能顺利指向到 src 目录下的 favicon.png 文件，不需要关心当前文件和目标文件的相对路径。</p><p>PS: 在调试 <code>&lt;img&gt;</code> 标签的时候遇到一个坑，<code>html-loader</code> 会解析 <code>&lt;!-- --&gt;</code> 注释中的内容，之前在注释中写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">大于 10kb 的图片，图片会被储存到输出目录，src 会被替换为打包后的路径</span><br><span class="line">&lt;img src=&quot;/assets/f78661bef717cf2cc2c2e5158f196384.png&quot;&gt;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>之前因为没有加 <code>root</code> 参数，所以 <code>/</code> 开头的文件名不会被解析，加了 <code>root</code> 导致编译时报错，找不到该文件。大家记住这一点。</p><h3 id="优化-babel-编译后的代码性能"><a href="#优化-babel-编译后的代码性能" class="headerlink" title="优化 babel 编译后的代码性能"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#优化-babel-编译后的代码性能" target="_blank" rel="noopener"></a>优化 babel 编译后的代码性能</h3><p>babel 编译后的代码一般会造成性能损失，babel 提供了一个 <a href="http://babeljs.io/docs/plugins/preset-env/#optionsloose" target="_blank" rel="noopener">loose</a> 选项，使编译后的代码不需要完全遵循 ES6 规定，简化编译后的代码，提高代码执行效率：</p><p>package.json:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;babel&quot;: &#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">      [</span><br><span class="line">        &quot;env&quot;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;loose&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;stage-2&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这么做会有兼容性的风险，可能会导致 ES6 源码理应的执行结果和编译后的 ES5 代码的实际结果并不一致。如果代码没有遇到实际的效率瓶颈，官方 <a href="http://www.2ality.com/2015/12/babel6-loose-mode.html" target="_blank" rel="noopener">不建议</a> 使用 <code>loose</code> 模式。</p><h3 id="使用-webpack-自带的-ES6-模块处理功能"><a href="#使用-webpack-自带的-ES6-模块处理功能" class="headerlink" title="使用 webpack 自带的 ES6 模块处理功能"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#使用-webpack-自带的-es6-模块处理功能" target="_blank" rel="noopener"></a>使用 webpack 自带的 ES6 模块处理功能</h3><p>我们目前的配置，babel 会把 ES6 模块定义转为 CommonJS 定义，但 webpack 自己可以处理 <code>import</code> 和 <code>export</code>， 而且 webpack 处理 <code>import</code> 时会做代码优化，把没用到的部分代码删除掉。因此我们通过 babel 提供的 <code>modules: false</code> 选项把 ES6 模块转为 CommonJS 模块的功能给关闭掉。</p><p>package.json:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;babel&quot;: &#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">      [</span><br><span class="line">        &quot;env&quot;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;loose&quot;: true,</span><br><span class="line">          &quot;modules&quot;: false</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;stage-2&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-autoprefixer-自动创建-css-的-vendor-prefixes"><a href="#使用-autoprefixer-自动创建-css-的-vendor-prefixes" class="headerlink" title="使用 autoprefixer 自动创建 css 的 vendor prefixes"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#使用-autoprefixer-自动创建-css-的-vendor-prefixes" target="_blank" rel="noopener"></a>使用 autoprefixer 自动创建 css 的 vendor prefixes</h3><p>css 有一个很麻烦的问题就是比较新的 css 属性在各个浏览器里是要加前缀的，我们可以使用 <a href="https://github.com/postcss/autoprefixer" target="_blank" rel="noopener">autoprefixer</a> 工具自动创建这些浏览器规则，那么我们的 css 中只需要写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:fullscreen a &#123;</span><br><span class="line">    display: flex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>autoprefixer 会编译成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">:-webkit-full-screen a &#123;</span><br><span class="line">    display: -webkit-box;</span><br><span class="line">    display: flex</span><br><span class="line">&#125;</span><br><span class="line">:-moz-full-screen a &#123;</span><br><span class="line">    display: flex</span><br><span class="line">&#125;</span><br><span class="line">:-ms-fullscreen a &#123;</span><br><span class="line">    display: -ms-flexbox;</span><br><span class="line">    display: flex</span><br><span class="line">&#125;</span><br><span class="line">:fullscreen a &#123;</span><br><span class="line">    display: -webkit-box;</span><br><span class="line">    display: -ms-flexbox;</span><br><span class="line">    display: flex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们用 npm 安装它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-loader autoprefixer --save-dev</span><br></pre></td></tr></table></figure><p>autoprefixer 是 <a href="http://postcss.org/" target="_blank" rel="noopener">postcss</a> 的一个插件，所以我们也要安装 postcss 的 webpack <a href="https://github.com/postcss/postcss-loader" target="_blank" rel="noopener">loader</a>。</p><p>修改一下 webpack 的 css rule：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.css$/,</span><br><span class="line">  use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;postcss-loader&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建文件 <code>postcss.config.js</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    require(&apos;autoprefixer&apos;)()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-webpack-打包多页面应用（Multiple-Page-Application）"><a href="#使用-webpack-打包多页面应用（Multiple-Page-Application）" class="headerlink" title="使用 webpack 打包多页面应用（Multiple-Page Application）"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#使用-webpack-打包多页面应用multiple-page-application" target="_blank" rel="noopener"></a>使用 webpack 打包多页面应用（Multiple-Page Application）</h2><p>多页面网站同样可以用 webpack 来打包，以便使用 npm 包，<code>import()</code>，<code>code splitting</code> 等好处。</p><p>MPA 意味着并没不是一个单一的 html 入口和 js 入口，而是每个页面对应一个 html 和多个 js。那么我们可以把项目结构设计为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">├── dist</span><br><span class="line">├── package.json</span><br><span class="line">├── node_modules</span><br><span class="line">├── src</span><br><span class="line">│   ├── components</span><br><span class="line">│   ├── shared</span><br><span class="line">|   ├── favicon.png</span><br><span class="line">│   └── pages                 页面放这里</span><br><span class="line">|       ├── foo               编译后生成 http://localhost:8080/foo.html</span><br><span class="line">|       |    ├── index.html</span><br><span class="line">|       |    ├── index.js</span><br><span class="line">|       |    ├── style.css</span><br><span class="line">|       |    └── pic.png</span><br><span class="line">|       └── bar                        http://localhost:8080/bar.html</span><br><span class="line">|           ├── index.html</span><br><span class="line">|           ├── index.js</span><br><span class="line">|           ├── style.css</span><br><span class="line">|           └── baz                    http://localhost:8080/bar/baz.html</span><br><span class="line">|               ├── index.html</span><br><span class="line">|               ├── index.js</span><br><span class="line">|               └── style.css</span><br><span class="line">└── webpack.config.js</span><br></pre></td></tr></table></figure><p>这里每个页面的 <code>index.html</code> 是个完整的从 <code>&lt;!DOCTYPE html&gt;</code> 开头到 <code>&lt;/html&gt;</code> 结束的页面，这些文件都要用 <code>html-webpack-plugin</code> 处理。<code>index.js</code> 是每个页面的业务逻辑，作为每个页面的入口 js 配置到 <code>entry</code> 中。这里我们需要用 <code>glob</code> 库来把这些文件都筛选出来批量操作。为了使用 webpack 4 的 <code>optimization.splitChunks</code> 和 <code>optimization.runtimeChunk</code> 功能，我写了 <a href="https://github.com/fenivana/html-webpack-include-sibling-chunks-plugin" target="_blank" rel="noopener">html-webpack-include-sibling-chunks-plugin</a> 插件来配合使用。还要装几个插件把 css 压缩并放到 <code>&lt;head&gt;</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install glob html-webpack-include-sibling-chunks-plugin uglifyjs-webpack-plugin mini-css-extract-plugin optimize-css-assets-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p><code>webpack.config.js</code> 修改的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;)</span><br><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;)</span><br><span class="line">const OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)</span><br><span class="line">const HtmlWebpackIncludeSiblingChunksPlugin = require(&apos;html-webpack-include-sibling-chunks-plugin&apos;)</span><br><span class="line">const glob = require(&apos;glob&apos;)</span><br><span class="line"></span><br><span class="line">const dev = Boolean(process.env.WEBPACK_SERVE)</span><br><span class="line">const config = require(&apos;./config/&apos; + (process.env.npm_config_config || &apos;default&apos;))</span><br><span class="line"></span><br><span class="line">const entries = glob.sync(&apos;./src/**/index.js&apos;)</span><br><span class="line">const entry = &#123;&#125;</span><br><span class="line">const htmlPlugins = []</span><br><span class="line">for (const path of entries) &#123;</span><br><span class="line">  const template = path.replace(&apos;index.js&apos;, &apos;index.html&apos;)</span><br><span class="line">  const chunkName = path.slice(&apos;./src/pages/&apos;.length, -&apos;/index.js&apos;.length)</span><br><span class="line">  entry[chunkName] = dev ? [path, template] : path</span><br><span class="line">  htmlPlugins.push(new HtmlWebpackPlugin(&#123;</span><br><span class="line">    template,</span><br><span class="line">    filename: chunkName + &apos;.html&apos;,</span><br><span class="line">    chunksSortMode: &apos;none&apos;,</span><br><span class="line">    chunks: [chunkName]</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    // 我们不定义 publicPath，否则访问 html 时需要带上 publicPath 前缀</span><br><span class="line">    filename: dev ? &apos;[name].js&apos; : &apos;[chunkhash].js&apos;,</span><br><span class="line">    chunkFilename: &apos;[chunkhash].js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    runtimeChunk: true,</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: &apos;all&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    minimizer: dev ? [] : [</span><br><span class="line">      new UglifyJsPlugin(&#123;</span><br><span class="line">        cache: true,</span><br><span class="line">        parallel: true,</span><br><span class="line">        sourceMap: true</span><br><span class="line">      &#125;),</span><br><span class="line">      new OptimizeCSSAssetsPlugin()</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      // ...</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [dev ? &apos;style-loader&apos; : MiniCssExtractPlugin.loader, &apos;css-loader&apos;, &apos;postcss-loader&apos;]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      // ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    这里不使用 [chunkhash]</span><br><span class="line">    因为从同一个 chunk 抽离出来的 css 共享同一个 [chunkhash]</span><br><span class="line">    [contenthash] 你可以简单理解为 moduleId + content 生成的 hash</span><br><span class="line">    因此一个 chunk 中的多个 module 有自己的 [contenthash]</span><br><span class="line">    */</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[contenthash].css&apos;,</span><br><span class="line">      chunkFilename: &apos;[contenthash].css&apos;</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    // 必须放在html-webpack-plugin前面</span><br><span class="line">    new HtmlWebpackIncludeSiblingChunksPlugin(),</span><br><span class="line"></span><br><span class="line">    ...htmlPlugins</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>entry</code> 和 <code>htmlPlugins</code> 会通过遍历 pages 目录生成，比如：</p><p>entry:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &apos;bar/baz&apos;: &apos;./src/pages/bar/baz/index.js&apos;,</span><br><span class="line">  bar: &apos;./src/pages/bar/index.js&apos;,</span><br><span class="line">  foo: &apos;./src/pages/foo/index.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发环境中，为了能够修改 html 文件后网页能够自动刷新，我们还需要把 html 文件也加入 entry 中，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: [&apos;./src/pages/foo/index.js&apos;, &apos;./src/pages/foo/index.html&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当 foo 页面的 index.js 或 index.html 文件改动时，都会触发浏览器刷新该页面。虽然把 html 加入 entry 很奇怪，但放心，不会导致错误。记得不要在生产环境这么做，不然导致 chunk 文件包含了无用的 html 片段。</p><p>htmlPlugins:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: &apos;./src/pages/bar/baz/index.html&apos;,</span><br><span class="line">    filename: &apos;bar/baz.html&apos;,</span><br><span class="line">    chunksSortMode: &apos;none&apos;,</span><br><span class="line">    chunks: [&apos;bar/baz&apos;]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: &apos;./src/pages/bar/index.html&apos;,</span><br><span class="line">    filename: &apos;bar.html&apos;,</span><br><span class="line">    chunksSortMode: &apos;none&apos;,</span><br><span class="line">    chunks: [&apos;bar&apos;]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: &apos;./src/pages/foo/index.html&apos;,</span><br><span class="line">    filename: &apos;foo.html&apos;,</span><br><span class="line">    chunksSortMode: &apos;none&apos;,</span><br><span class="line">    chunks: [&apos;foo&apos;]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>代码在 <a href="https://github.com/fenivana/webpack-and-spa-guide/blob/master/examples/mpa" target="_blank" rel="noopener">examples/mpa</a> 目录。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#总结" target="_blank" rel="noopener"></a>总结</h2><p>通过这篇文章，我想大家应该学会了 webpack 的正确打开姿势。虽然我没有提及如何用 webpack 来编译 <a href="https://facebook.github.io/react/" target="_blank" rel="noopener">React</a> 和 <a href="http://vuejs.org/" target="_blank" rel="noopener">vue.js</a>, 但大家可以想到，无非是安装一些 loader 和 plugin 来处理 <a href="https://babeljs.io/docs/plugins/preset-react/" target="_blank" rel="noopener">jsx</a> 和 <a href="http://vue-loader.vuejs.org/" target="_blank" rel="noopener">vue</a> 格式的文件，那时难度就不在于 webpack 了，而是代码架构组织的问题了。具体的大家自己去摸索一下。</p><blockquote><p>文章来源：<a href="https://github.com/wallstreetcn/webpack-and-spa-guide" target="_blank" rel="noopener">https://github.com/wallstreetcn/webpack-and-spa-guide</a><br>作者：wallstreetcn<br>声明：文章著作权归作者所有，如有侵权，请联系小编删除。</p></blockquote><p>关注公众号“web前端导航”，最新的前端教程和学习资料等你来拿！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-65e75c57ef7286c8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;可以说是我目前看到最详细的 webpack 4 入门文章。&lt;br&gt;基本看完这个，基本也算一个合格的初级webpack配置工程师了。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;webpack 更新到了 4.0，官网还没有更新文档。因此把教程更新
      
    
    </summary>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack入门</title>
    <link href="http://yoursite.com/2018/07/19/webpack%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/07/19/webpack入门/</id>
    <published>2018-07-19T12:45:23.000Z</published>
    <updated>2018-10-19T09:35:46.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么使用webpack"><a href="#为什么使用webpack" class="headerlink" title="为什么使用webpack??"></a>为什么使用webpack??</h2><p><strong>一句话 webpack能够提高了我们的开发效率</strong><br>什么是Webpack<br>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>新建一个空的练习文件夹 如：webpackText<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//全局安装</span><br><span class="line">npm install -g webpack</span><br><span class="line">//安装到你的项目目录</span><br><span class="line">npm install --save-dev webpack</span><br><span class="line">//npm install --save-dev webpack@版本号</span><br><span class="line">//可下载对应版本的webpack</span><br></pre></td></tr></table></figure></p><h3 id="正式使用Webpack前的准备"><a href="#正式使用Webpack前的准备" class="headerlink" title="正式使用Webpack前的准备"></a>正式使用Webpack前的准备</h3><ol><li>创建package.json文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></li></ol><p>项目名称和作者等信息回车即可</p><ol start="2"><li><p>package.json文件已经就绪，我们在本项目中安装Webpack作为依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装Webpack</span><br><span class="line">npm install --save-dev webpack</span><br></pre></td></tr></table></figure></li><li><p>创建两个文件夹,app文件夹和public文件夹，app文件夹用来存放原始数据和我们将写的JavaScript模块，public文件夹用来存放之后供浏览器读取的文件（包括使用webpack打包生成的js文件以及一个index.html文件）创建三个文件:</p></li></ol><ul><li><code>index.html</code> –放在public文件夹中;</li><li><code>Greeter.js</code>– 放在app文件夹中;</li><li><code>main.js</code>– 放在app文件夹中;</li></ul><p>此时项目结构如下图所示<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-c977d7d00f7a1ec4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构" title="">                </div>                <div class="image-caption">项目结构</div>            </figure></p><p>我们在<strong>index.html</strong>文件中写入最基础的html代码，它在这里目的在于引入打包后的js文件（这里我们先把之后打包后的js文件命名为<code>bundle.js</code>，之后我们还会详细讲述）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- index.html --&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Webpack Sample Project&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&apos;root&apos;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>我们在Greeter.js中定义一个返回包含问候信息的html元素的函数,并依据CommonJS规范导出这个函数为一个模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Greeter.js</span><br><span class="line">module.exports = function() &#123;</span><br><span class="line">  var greet = document.createElement(&apos;div&apos;);</span><br><span class="line">  greet.textContent = &quot;Hi there and greetings!&quot;;</span><br><span class="line">  return greet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>main.js文件中我们写入下述代码，用以把Greeter模块返回的节点插入页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//main.js </span><br><span class="line">const greeter = require(&apos;./Greeter.js&apos;);</span><br><span class="line">document.querySelector(&quot;#root&quot;).appendChild(greeter());</span><br></pre></td></tr></table></figure></p><p>根目录下新建webpack.config.js，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry:  __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件</span><br><span class="line">  output: &#123;//__dirname 是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</span><br><span class="line">    path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方</span><br><span class="line">    filename: &quot;bundle.js&quot;//打包后输出文件的文件名</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了更方面的打包，在package.json中对scripts对象进行相关设置即可，设置方法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpack-sample-project&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Sample webpack project&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack&quot; // 修改的是这里，JSON文件不支持注释，引用时请清除</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;zhang&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;3.10.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>命令行中输入<code>npm start</code>试试<br>然后浏览器打开public/index.html<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-6493c12b502af61f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WechatIMG2.jpeg" title="">                </div>                <div class="image-caption">WechatIMG2.jpeg</div>            </figure></p><h3 id="使用webpack构建本地服务器"><a href="#使用webpack构建本地服务器" class="headerlink" title="使用webpack构建本地服务器"></a>使用webpack构建本地服务器</h3><ol><li>安装devserver<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure></li></ol><p>注意：webpack3.x的请下载webpack-dev-server2.9，不然会报错</p><ol start="2"><li><p>把这些命令加到webpack的配置文件中，现在的配置文件webpack.config.js如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  devtool: &apos;eval-source-map&apos;,</span><br><span class="line"></span><br><span class="line">  entry:  __dirname + &quot;/app/main.js&quot;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;/public&quot;,</span><br><span class="line">    filename: &quot;bundle.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录</span><br><span class="line">    historyApiFallback: true,//不跳转</span><br><span class="line">    inline: true//实时刷新</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在package.json中的scripts对象中添加如下命令，用以开启本地服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;webpack&quot;,</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ol><p>在终端中输入npm run server即可在本地的8080端口查看结果（实时刷新）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-cb7c29cb6d2e9dff.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WechatIMG3.jpeg" title="">                </div>                <div class="image-caption">WechatIMG3.jpeg</div>            </figure></p><h2 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h2><p>鼎鼎大名的Loaders登场了！<br>Loaders是webpack提供的最激动人心的功能之一了。通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的<br><strong>Loaders可以把React的中用到的JSX文件转换为JS文件</strong><br> Loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，Loaders的配置包括以下几方面：</p><ul><li>test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）</li><li>loader：loader的名称（必须）</li><li>include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；</li><li>query：为loaders提供额外的设置选项（可选）<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3>Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：</li></ul><p>让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持；<br>让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；<br>Babel的安装与配置<br>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-env-preset包和解析JSX的babel-preset-react包）。</p><p>一次性安装这些依赖包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// npm一次性安装多个依赖模块，模块之间用空格隔开</span><br><span class="line">npm install --save-dev babel-core babel-loader babel-preset-env babel-preset-react</span><br></pre></td></tr></table></figure></p><p>Babel其实可以完全在 webpack.config.js 中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方</span><br><span class="line">        filename: &quot;bundle.js&quot;//打包后输出文件的文件名</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &apos;eval-source-map&apos;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录</span><br><span class="line">        historyApiFallback: true,//不跳转</span><br><span class="line">        inline: true//实时刷新</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /(\.jsx|\.js)$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;babel-loader&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                exclude: /node_modules/</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//.babelrc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为webpack4都出来了 我学的这篇是webpack3.5版本的，但是基础的东西都还是一样的，最后放上这个webpack的配置文件，如果每一项都懂的话，入门应该是没问题了。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 一个常见的`webpack`配置文件</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">        entry: __dirname + &quot;/app/main.js&quot;, //已多次提及的唯一入口文件</span><br><span class="line">        output: &#123;</span><br><span class="line">            path: __dirname + &quot;/build&quot;,</span><br><span class="line">            filename: &quot;bundle-[hash].js&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        devtool: &apos;none&apos;,</span><br><span class="line">        devServer: &#123;</span><br><span class="line">            contentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录</span><br><span class="line">            historyApiFallback: true, //不跳转</span><br><span class="line">            inline: true,</span><br><span class="line">            hot: true</span><br><span class="line">        &#125;,</span><br><span class="line">        module: &#123;</span><br><span class="line">            rules: [&#123;</span><br><span class="line">                    test: /(\.jsx|\.js)$/,</span><br><span class="line">                    use: &#123;</span><br><span class="line">                        loader: &quot;babel-loader&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    exclude: /node_modules/</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    test: /\.css$/,</span><br><span class="line">                    use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                        fallback: &quot;style-loader&quot;,</span><br><span class="line">                        use: [&#123;</span><br><span class="line">                            loader: &quot;css-loader&quot;,</span><br><span class="line">                            options: &#123;</span><br><span class="line">                                modules: true,</span><br><span class="line">                                localIdentName: &apos;[name]__[local]--[hash:base64:5]&apos;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, &#123;</span><br><span class="line">                            loader: &quot;postcss-loader&quot;</span><br><span class="line">                        &#125;],</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: __dirname + &quot;/app/index.tmpl.html&quot; //new 一个这个插件的实例，并传入相关的参数</span><br><span class="line">        &#125;),</span><br><span class="line">        new webpack.optimize.OccurrenceOrderPlugin(),</span><br><span class="line">        new webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">        new ExtractTextPlugin(&quot;style.css&quot;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://www.jianshu.com/p/42e11515c10f" target="_blank" rel="noopener">https://www.jianshu.com/p/42e11515c10f</a><br>webpack中文网：<a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">https://www.webpackjs.com/concepts/</a><br>简要理解CommonJS规范：<a href="https://blog.csdn.net/u012443286/article/details/78825917" target="_blank" rel="noopener">https://blog.csdn.net/u012443286/article/details/78825917</a><br>webpack4那点东西：<a href="https://juejin.im/post/5abef5e96fb9a028e33b9035" target="_blank" rel="noopener">https://juejin.im/post/5abef5e96fb9a028e33b9035</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么使用webpack&quot;&gt;&lt;a href=&quot;#为什么使用webpack&quot; class=&quot;headerlink&quot; title=&quot;为什么使用webpack??&quot;&gt;&lt;/a&gt;为什么使用webpack??&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一句话 webpack能够提高了我们
      
    
    </summary>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中基本数据类型和引用数据类型的区别</title>
    <link href="http://yoursite.com/2018/07/19/JavaScript%E4%B8%AD%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/07/19/JavaScript中基本数据类型和引用数据类型的区别/</id>
    <published>2018-07-19T12:45:23.000Z</published>
    <updated>2018-09-02T11:42:23.004Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、基本数据类型和引用数据类型</strong></p><p>　　ECMAScript包括两个不同类型的值：基本数据类型和引用数据类型。</p><p>　　基本数据类型指的是简单的数据段，引用数据类型指的是有多个值构成的对象。</p><p>　　当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值。</p><p><strong>2、常见的基本数据类型：</strong></p><p>　　Number、String 、Boolean、Null和Undefined。基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。示例：</p><p>　　var a = 10;</p><p>　　var b = a;</p><p>　　b = 20;</p><p>　　console.log(a); // 10值</p><p>　　上面，b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值。</p><p>　　<strong>b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。</strong></p><p>下图演示了这种基本数据类型赋值的过程：</p><p><strong>3、引用类型数据：</strong></p><p><strong>也就是对象类型Object type，比如：Object 、Array 、Function 、Data等。</strong> </p><p>javascript的引用数据类型是保存在堆内存中的对象。</p><p>　　与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。</p><p>　　所以，引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。</p><p>　　var obj1 = new Object();</p><p>　　var obj2 = obj1;</p><p>　　obj2.name = “我有名字了”;</p><p>　　console.log(obj1.name); // 我有名字了</p><p>　　说明这两个引用数据类型指向了同一个堆内存对象。obj1赋值给onj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2，</p><p>　　但是实际上他们共同指向了同一个堆内存对象。<strong>实际上改变的是堆内存对象。</strong></p><p>下面我们来演示这个引用数据类型赋值过程：</p><pre><code>[图片上传失败...(image-3d74f7-1531992451590)]</code></pre><p><strong>4、总结区别</strong></p><p><strong>　　a 声明变量时不同的内存分配：　</strong></p><p>　　1）原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在<strong>变量访问的位置</strong>。</p><p>　　　　这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。</p><p>　　2）引用值：存储在堆（heap）中的对象，也就是说，<strong>存储在变量处的值是一个指针（point），指向存储对象的内存地址。</strong></p><p>　　　  这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。</p><p>　　　  地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。</p><p>　　<strong>b</strong> <strong>不同的内存分配机制也带来了不同的访问机制</strong></p><p>　　1）在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，</p><p>　　　　首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的<strong>按引用访问</strong>。</p><p>　　2）而原始类型的值则是可以直接访问到的。</p><p><strong>　　c 复制变量时的不同</strong></p><p>1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，<strong>此后这两个变量是完全独立的，他们只是拥有相同的value而已。</strong></p><p>　　2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，</p><p>　　　　也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。</p><p>　　　　（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。<strong>多了一个指针</strong></p><p>　　<strong>d 参数传递的不同（</strong>把实参复制给形参的过程<strong>）</strong></p><p>　　首先我们应该明确一点：ECMAScript中所有函数的参数都<strong>是按值来传递</strong>的。</p><p>　　但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 　</p><p>　　1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。</p><p>　　2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！</p><p>　　　　因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。</p><p>参考：<a href="https://www.cnblogs.com/cxying93/p/6106469.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxying93/p/6106469.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1、基本数据类型和引用数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　ECMAScript包括两个不同类型的值：基本数据类型和引用数据类型。&lt;/p&gt;
&lt;p&gt;　　基本数据类型指的是简单的数据段，引用数据类型指的是有多个值构成的对象。&lt;/p&gt;
&lt;p&gt;　　当我们把变
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象/原型链</title>
    <link href="http://yoursite.com/2018/07/19/JavaScript%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2018/07/19/JavaScript对象原型链/</id>
    <published>2018-07-19T12:45:23.000Z</published>
    <updated>2018-09-02T11:42:38.085Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对象的原型是什么？"><a href="#对象的原型是什么？" class="headerlink" title="对象的原型是什么？"></a>对象的原型是什么？</h3><p>Object是引用类型，包括：Object 、Array 、Function 、Data等。<br><strong>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。</strong></p><p>当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前（this）对象上查找该属性，如果没有找到，就到其原型对象上找(数组是Array.prototype,function是function。prototype)，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。</p><p>比如创建了一个Array对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3]</span><br></pre></td></tr></table></figure></p><p>其原型链是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr ----&gt; Array.prototype ----&gt; Object.prototype ----&gt; null</span><br></pre></td></tr></table></figure></p><p>Array.prototype定义了indexOf()、shift()等方法，因此你可以在所有的Array对象上直接调用这些方法。甚至你都可以在Array.prototype自定义方法，但是没有必要最后不要这样做。</p><p>当我们创建一个函数时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数也是一个对象 ，他的原型链是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null</span><br></pre></td></tr></table></figure></p><p>由于Function.prototype定义了apply()等方法，因此，所有函数都可以调用apply()方法。</p><h3 id="用构造函数创建对象"><a href="#用构造函数创建对象" class="headerlink" title="用构造函数创建对象"></a>用构造函数创建对象</h3><p>用函数来创建对象比直接用var = {…}创建对象要方面的多，它就是构造函数。<br>构造函数的首字母都应该大写<br>首先先创建一个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Student(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.hello = function () &#123;</span><br><span class="line">        alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以用关键字new来调用这个函数，并返回一个对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var xiaoming = new Student(&apos;小明&apos;);</span><br><span class="line">xiaoming.name; // &apos;小明&apos;</span><br><span class="line">xiaoming.hello(); // Hello, 小明!</span><br></pre></td></tr></table></figure></p><p>注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。</p><p>新创建的xiaoming的原型链是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xiaoming ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null</span><br></pre></td></tr></table></figure></p><p>也就是说，xiaoming的原型指向函数Student的原型。如果你又创建了xiaohong、xiaojun，那么这些对象的原型与xiaoming是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaoming ↘</span><br><span class="line">xiaohong -→ Student.prototype ----&gt; Object.prototype ----&gt; null</span><br><span class="line">xiaojun  ↗</span><br></pre></td></tr></table></figure></p><p>用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(xiaoming.constructor === Student)//true</span><br></pre></td></tr></table></figure></p><p>我们可以用instanceof来检测对象类型；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(xiaohong instanceof Object);//true</span><br><span class="line">console.log(xiaohong instanceof Student);//true</span><br><span class="line">console.log(xiaoming instanceof Object);//true</span><br><span class="line">console.log(xiaoming instanceof Student);//true</span><br></pre></td></tr></table></figure></p><p>这个例子中所创建的对象即是Object的实例 也是Student的实例，因为所有的对象都继承自Object</p><p>参考：js高程第六章<br>参考：<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997235247b53be560ab041a7b10360a567422a78000" target="_blank" rel="noopener">廖雪峰的博客</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对象的原型是什么？&quot;&gt;&lt;a href=&quot;#对象的原型是什么？&quot; class=&quot;headerlink&quot; title=&quot;对象的原型是什么？&quot;&gt;&lt;/a&gt;对象的原型是什么？&lt;/h3&gt;&lt;p&gt;Object是引用类型，包括：Object 、Array 、Function 、Da
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript零散知识整理</title>
    <link href="http://yoursite.com/2018/07/02/js%20%E9%9B%B6%E7%A2%8E/"/>
    <id>http://yoursite.com/2018/07/02/js 零碎/</id>
    <published>2018-07-02T12:45:23.000Z</published>
    <updated>2018-07-02T12:55:06.870Z</updated>
    
    <content type="html"><![CDATA[<p>call() 参考：<a href="https://blog.csdn.net/ywl570717586/article/details/52681392/" target="_blank" rel="noopener">https://blog.csdn.net/ywl570717586/article/details/52681392/</a><br>this解读参考：<a href="https://juejin.im/post/5b3715def265da59af40a630" target="_blank" rel="noopener">https://juejin.im/post/5b3715def265da59af40a630</a><br>函数传入值参考：js高程 p113</p><h3 id="快速删除尾部数组"><a href="#快速删除尾部数组" class="headerlink" title="快速删除尾部数组"></a>快速删除尾部数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,4,5];</span><br><span class="line">arr.length=3;</span><br><span class="line">console.log(arr)//[1,2,3]</span><br></pre></td></tr></table></figure><p>直接改变数组的length的值</p><h3 id="从数组中移除重复元素"><a href="#从数组中移除重复元素" class="headerlink" title="从数组中移除重复元素"></a>从数组中移除重复元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,1,2,2,3,3]</span><br><span class="line">const removeDuplicateltems = arr =&gt; [...new Set(arr)];</span><br><span class="line">console.log(removeDuplicateltems(arr))//[1,2,3]</span><br></pre></td></tr></table></figure><h3 id="函数作为值传入"><a href="#函数作为值传入" class="headerlink" title="函数作为值传入"></a>函数作为值传入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//把函数作为值传入进去</span><br><span class="line">    function callSomeFunction(someFunction,someArgument)&#123;</span><br><span class="line">      return someFunction(someArgument);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最终调用的这个函数 他有两个参数， 第一个参数是一个方法 ， 第二个参数是第一个方法的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add10(num)&#123;</span><br><span class="line">  return num + 10;</span><br><span class="line">&#125;</span><br><span class="line">var result1=callSomeFunction(add10,10);</span><br><span class="line">  console.log(result1);//20</span><br></pre></td></tr></table></figure></p><p>这个例子稍微一看就明白了吧，  传入的10 最终成了add()的参数, 也就是成了num,  所以结果是20<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getGreeting(name)&#123;</span><br><span class="line">  return &quot;holle,&quot; + name;</span><br><span class="line">&#125;</span><br><span class="line">var result2=callSomeFunction(getGreeting, &quot;Nicholas&quot;);</span><br><span class="line">console.log(result2);//holle Nicholas</span><br></pre></td></tr></table></figure></p><p>上面的理解了  这个也就不难了  同理 “ Nicholas” 变成了getGreeting() 的参数 name，所以输出结果是 holle Nicholas</p><h3 id="call-解释"><a href="#call-解释" class="headerlink" title="call() 解释"></a>call() 解释</h3><p>先看看关于call()的官方解释，“调用一个对象的一个方法，以另一个对象替换当前对象。”，看了这样的解释，或许让你更摸不着头脑了。看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x = &quot;我是全局变量&quot;;　　　　//定义全局变量x</span><br><span class="line">function a()&#123;　　　　　　　　　//定义函数类结构a　　</span><br><span class="line">    this.x = &quot;我是在函数类结构a中声明的哦&quot;;    </span><br><span class="line">&#125;</span><br><span class="line">//定义普通函数，弹出当前指针所包含的变量x的值</span><br><span class="line">function f()&#123;       </span><br><span class="line">    alert (this.x);</span><br><span class="line">&#125;</span><br><span class="line">f.call(new a());//返回值为“我是在函数类结构a中声明的哦”</span><br></pre></td></tr></table></figure></p><p>我的理解是，f.call(new a())就是把函数（其实也是对象）f复制到被调用对象“new a()”下面去解析，事实上和下面这段代码的解析结果一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">　　this.x = &quot;我是在函数类结构a中声明的哦&quot;;</span><br><span class="line">　　alert(this.x);    //我是在函数类结构a中声明的哦</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>只不过此时变量X的作用域不同而已，咿…看起来好像有点继承的味道哦，难道不是吗？在上例中,f完全被构造函数a的实力对象继承了，如果说这还不足以说明a.call(b)是一种继承模式，那么再看一个更具有继承味道的用法吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;    </span><br><span class="line">    this.a =&quot;a&quot;;    </span><br><span class="line">    this.b = function()&#123;    </span><br><span class="line">        alert(&quot;b&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function e()&#123;    </span><br><span class="line">    f.call(this);     </span><br><span class="line">&#125;</span><br><span class="line">var c = new e();</span><br><span class="line">alert(c.a);  //弹出a</span><br><span class="line">c.b();    //弹出b</span><br></pre></td></tr></table></figure><p>在这个例子中，只要会使用浏览器的朋友，都能看得出来e完全继承了f的属性和方法，否则是无法解释的，因为在e中并没有定义属性a和b，那么按常理推断在e的实例对象c中，并不会出现这两个属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;call() 参考：&lt;a href=&quot;https://blog.csdn.net/ywl570717586/article/details/52681392/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/ywl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用Echarts.js绘制图表</title>
    <link href="http://yoursite.com/2018/06/30/%E4%BD%BF%E7%94%A8Echarts.js%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/06/30/使用Echarts.js绘制图表/</id>
    <published>2018-06-30T12:45:23.000Z</published>
    <updated>2018-10-19T09:59:34.517Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Echarts.js是基于canvas 图画，可视化数据工具。</strong></p><h2 id="Echarts官方案例"><a href="#Echarts官方案例" class="headerlink" title="Echarts官方案例"></a>Echarts官方案例</h2><p>官网下载<a href="http://echarts.baidu.com/" target="_blank" rel="noopener">Echarts</a><br> 然后引入官网下载Echarts.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;ECharts 入门示例--柱状图&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;../js/echarts.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;</span><br><span class="line">   &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">   &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">       // 基于准备好的dom，初始化echarts实例</span><br><span class="line">       var myChart = echarts.init(document.getElementById(&apos;main&apos;));</span><br><span class="line"></span><br><span class="line">       // 指定图表的配置项和数据</span><br><span class="line">       var option = &#123;</span><br><span class="line">           title: &#123;</span><br><span class="line">               text: &apos;ECharts 入门示例&apos;</span><br><span class="line">               //标题</span><br><span class="line">           &#125;,</span><br><span class="line">   //工具箱</span><br><span class="line">           tooltip: &#123;</span><br><span class="line">       show: true,</span><br><span class="line">   feature:&#123;</span><br><span class="line">       saveAsImage:&#123;</span><br><span class="line">       show: true</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   //图例</span><br><span class="line">           legend: &#123;</span><br><span class="line">               data:[&apos;销量&apos;]</span><br><span class="line">           &#125;,</span><br><span class="line">           //x轴</span><br><span class="line">           xAxis: &#123;</span><br><span class="line">               data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]</span><br><span class="line">           &#125;,</span><br><span class="line">           //Y轴</span><br><span class="line">           yAxis: &#123;&#125;,</span><br><span class="line">   //数据</span><br><span class="line">           series: [&#123;</span><br><span class="line">               name: &apos;销量&apos;,</span><br><span class="line">               type: &apos;bar&apos;,</span><br><span class="line">               data: [5, 20, 36, 10, 10, 20]</span><br><span class="line">           &#125;]</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       // 使用刚指定的配置项和数据显示图表。</span><br><span class="line">       myChart.setOption(option);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>如图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p0bnwspy9.bkt.clouddn.com/Y%29XNBRN8%5DD%25@1W78XTXFA25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>更多的配置可以看官方的<a href="http://echarts.baidu.com/option.html#title" target="_blank" rel="noopener">配置项手册</a>，每一项都有很详细的说明。</p><h2 id="异步读取数据-填充图表"><a href="#异步读取数据-填充图表" class="headerlink" title="异步读取数据 填充图表"></a>异步读取数据 填充图表</h2><p>正常来说我的图表的数据都是异步加载的 不会都是写死的 按照教程的异步加载 我的浏览器是报一个错误 大概意思就是访问的数据应该是以<code>http:</code>开头的 不然读取不到<br>需要开启一个虚拟的服务器才可以读取本地的json数据 我是用node开启了一个本地服务器。<br>参考：<a href="https://www.cnblogs.com/leoxuan/p/6513591.html" target="_blank" rel="noopener">https://www.cnblogs.com/leoxuan/p/6513591.html</a><br>本地创建了dataj.json 文件 用于储存数据,然后异步请求。<br>因为使用jquery的ajax，所以引入了一个jquery。<br>cnd使用的<a href="http://www.bootcdn.cn/" target="_blank" rel="noopener">BootCND</a> 非常好用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;ECharts ajax加载&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.bootcss.com/echarts/4.1.0.rc2/echarts-en.common.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;main&quot; style=&quot;width:600px;height:400px;&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    若在Chrome浏览器下 想要访问本地的data.json文件必须开起一个本地的虚拟服务器以http开头</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;a href=&quot;https://www.cnblogs.com/leoxuan/p/6513591.html&quot;&gt;原文博客地址：https://www.cnblogs.com/leoxuan/p/6513591.html&lt;/a&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    var myChart = echarts.init(document.getElementById(&apos;main&apos;));</span><br><span class="line">// 显示标题，图例和空的坐标轴</span><br><span class="line">myChart.setOption(&#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">        text: &apos;异步数据加载示例&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    tooltip: &#123;&#125;,</span><br><span class="line">    legend: &#123;</span><br><span class="line">        data:[&apos;第一年销量&apos;,&apos;第二年销量&apos;]</span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis: &#123;</span><br><span class="line">        data: []</span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis: &#123;&#125;,</span><br><span class="line">    series: [&#123;</span><br><span class="line">        name: &apos;第一年销量&apos;,</span><br><span class="line">        type: &apos;bar&apos;,</span><br><span class="line">        data: []</span><br><span class="line">    &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: &apos;第二年销量&apos;,</span><br><span class="line">        type: &apos;bar&apos;,</span><br><span class="line">        data: []</span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 异步加载数据</span><br><span class="line">$.get(&apos;http://localhost:8082/example/data.json&apos;).done(function (data) &#123;</span><br><span class="line">    // 填入数据</span><br><span class="line">    myChart.setOption(&#123;</span><br><span class="line">        xAxis: &#123;</span><br><span class="line">            data: data.name</span><br><span class="line">        &#125;,</span><br><span class="line">        series: [&#123;</span><br><span class="line">            // 根据名字对应到相应的系列</span><br><span class="line">            name: &apos;第一年销量&apos;,</span><br><span class="line">            data: data.data1</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">          name: &apos;第二年销量&apos;,</span><br><span class="line">          data: data.data2</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>data.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:[&quot;Android&quot;,&quot;IOS&quot;,&quot;PC&quot;,&quot;Other&quot;],&quot;data1&quot;:[420,200,360,100],&quot;data2&quot;:[460,260,390,200]&#125;</span><br></pre></td></tr></table></figure></p><p>如图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p0bnwspy9.bkt.clouddn.com/15F%5DLE1V8%25%5BRKUWN$Y7S30A.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Echarts.js是基于canvas 图画，可视化数据工具。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Echarts官方案例&quot;&gt;&lt;a href=&quot;#Echarts官方案例&quot; class=&quot;headerlink&quot; title=&quot;Echarts官方案例&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Echarts.js" scheme="http://yoursite.com/tags/Echarts-js/"/>
    
  </entry>
  
  <entry>
    <title>js高程读书笔记（1章-5章）</title>
    <link href="http://yoursite.com/2018/06/22/js%E9%AB%98%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%881-5%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/22/js高程读书笔记（1-5）/</id>
    <published>2018-06-22T14:45:23.000Z</published>
    <updated>2018-10-19T09:07:05.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章，JavaScript简介"><a href="#第一章，JavaScript简介" class="headerlink" title="第一章，JavaScript简介"></a>第一章，JavaScript简介</h2><p>1.JavaScript包含三个部分，ECMAScript，DOM，BOM。<br>ECMAScript是JavaScript的核心，包括语法，类型，语句，关键字，保留字，操作符，对象。</p><p>２.ECMAScript提供核心语言功能。DOM提供访问和操作网页内容的方法和接口。BOM提供与浏览器交互的方法和接口。</p><p>３.DOM包含DOM１、DOM２、DOM３。</p><ul><li>DOM１由两个模块构成DOM核心和DOM HTML；</li><li>DOM２引入了DOM视图、DOM事件、DOM样式、DOM遍历和范围；</li><li>DOM３新增了验证文档的方式，并引入了已统一的方式加载和保存文档的方法。</li></ul><h2 id="第二章，在HTML中使用JavaScript"><a href="#第二章，在HTML中使用JavaScript" class="headerlink" title="第二章，在HTML中使用JavaScript"></a>第二章，在HTML中使用JavaScript</h2><p>在html中内嵌代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;holle world!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;放到body的底部&lt;/p&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      alert(&quot;holle world!&quot;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>外部引用文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;holle world!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;放到body的底部&lt;/p&gt;</span><br><span class="line">    &lt;script src=&quot;xxx.js的路径&quot;&gt;&lt;script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h2 id="第三章，基本概念"><a href="#第三章，基本概念" class="headerlink" title="第三章，基本概念"></a>第三章，基本概念</h2><h3 id="1-ECMAScript数据类型"><a href="#1-ECMAScript数据类型" class="headerlink" title="1.  ECMAScript数据类型"></a>1.  ECMAScript数据类型</h3><p>1.1 有五种基本的数据类型：Undefined，Null，Boolean，Number，String，还有一种复杂的数据类型：Object。typeof可以确定数据类型。[ES6增加新类型：Symbol]</p><p>1.2 使用typeof操作符检测null值时会返回“object”，这是因为从逻辑角度来看null指示一个空对象指针。</p><p>1.3 Boolean类型的字面值true和false是区分大小写的。若想让其他类型的值转换为Boolean，可以调用转型函数Boolean()。</p><p>1.4 Number。八进制第一位必须是0，然后是八进制数字序列（0~7）。十六进制前两位必须是0x，后跟任何十六进制数字（0~9及A~F）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有三个函数可以把非数值转换为数值：Number(),parseInt(),parseFloat();</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>转换八进制</th><th>转换十六进制</th><th>空字符</th><th>字符串</th></tr></thead><tbody><tr><td>Number()</td><td>忽略前导0，理解为十进制</td><td>转换为相同大小的十进制</td><td>转换为0</td><td>不全为数字的字符串会转换为NaN</td></tr><tr><td>parseInt()</td><td>转换为相同大小的十进制(在函数第二位加参数8)</td><td>转换为相同大小的十进制(在函数第二位加参数16)</td><td>转换为NaN</td><td>若遇到的第一个字符是数字字符，会一直解析直到遇到第一个非数字字符为止；若遇到的第一个字符为非数字字符，转化为NaN</td></tr><tr><td>parseFloat()</td><td>忽略前导0，理解为十进制</td><td>忽略前导0x，理解为十进制,转化为0</td><td>同上</td><td>同上</td></tr></tbody></table><p>1.5 String，字符串一旦创建，它的值就不能改变!!!改变的话也只是销毁之后重新创建。</p><p>1.6 将一个值转换为字符串，可以使用toString(),Null和Undefined类型没有这个方法。数值，对象，字符串，布尔值均有这个方法。数值调用toString()方法时，可以加参数2,8,10,16，表示转化为相应进制的字符串。</p><p>1.7 Object，Object的每个实例都具有以下的属性和方法。</p><table><thead><tr><th>属性和方法名</th><th>说明</th></tr></thead><tbody><tr><td>hasOwnProperty(propertyName)</td><td>用于检查给定属性在当前对象实例（而不是实例的原型中）是否存在。eg：o.hasOwnProperty(“name”)</td></tr><tr><td>isPrototypeOf(object)</td><td>用于检查传入的对象是否是传入对象的原型</td></tr><tr><td>propertyIsEnumerable(propertyName)</td><td>用于检查给定的属性是否能够使用for-in语句来枚举</td></tr></tbody></table><h3 id="2-操作符"><a href="#2-操作符" class="headerlink" title="2.操作符"></a>2.操作符</h3><p>2.1 任何操作数与NaN进行关系比较，结果都是false。大写字母的字符编码全部小于小写字母的字符编码。</p><p>2.2 相等和不相等（== ,!=）,强制转换再比较；全等和不全等（===,!==）,仅比较而不转换。</p><p>2.3 由于ECMAScript中不存在块级作用域，因此循环内部定义的变量可以在外部访问到。</p><p>2.4 for-in语句可以用来枚举对象的属性。</p><p>2.5 break和continue，一般情况下，break语句会立即退出循环，强制执行循环后面的语句，而continue语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。但是遇到与labe标签配合使用，一般发生在循环嵌套的情况下，break会退出到label标签的位置，而continue只是会退出内部循环，执行外部循环。</p><p>2.6 可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象来访问参数数组。</p><p>2.7 ECMAScript没有重载。</p><h2 id="第四章-变量，作用域和内存问题"><a href="#第四章-变量，作用域和内存问题" class="headerlink" title="第四章 变量，作用域和内存问题"></a>第四章 变量，作用域和内存问题</h2><h3 id="1-基本类型和引用类型的值"><a href="#1-基本类型和引用类型的值" class="headerlink" title="1. 基本类型和引用类型的值"></a>1. 基本类型和引用类型的值</h3><p>1.1 ECMAScript变量可能包含两种不同类型的值：基本类型值和引用类型值，<strong>基本类型值</strong>指的是一个简单的数据段，五种基本数据类型Undifined,Null,Boolean,String,Number是<strong>按值访问</strong>的,因为可以操作保存在变量中的实际的值。<strong>引用类型</strong>的值是保存在内存中的对象，JS不允许直接访问内存中的位置，所以引用类型的值是按<strong>引用访问</strong>的。只有引用类型值可以动态地添加属性。</p><p>1.2 访问变量有按值和按引用两种方式，而<strong>参数只能按值传递</strong>。</p><p>1.3 <strong>检测类型</strong>，<strong>typeof</strong>,用于确定一个变量是字符串，数值，布尔值，对象还是Undefined的最佳工具。如果一个变量的值是Null或者是Object，则typeof都会返回“Object”。</p><p>1.4 <strong>instanceof</strong>用于确定一个值是哪种引用类型。若使用instanceof操作符检测基本类型值，则该操作符始终会返回false。</p><blockquote><p><code>alert(person instanceof Object);</code><br><code>alert(person instanceof Array);</code><br><code>alert(person instanceof RegExp);</code></p></blockquote><h3 id="2-执行环境及作用域"><a href="#2-执行环境及作用域" class="headerlink" title="2. 执行环境及作用域"></a>2. 执行环境及作用域</h3><p>2.1 在Web浏览器中，全局执行环境被认为是window对象。</p><p>2.2 在try-catch语句的catch块和with语句可以在作用域链的前端临时增加一个变量对象，会延长作用域链。</p><p>2.3 JS没有块级作用域，即在if和for语句中声明的变量，在其语句结束后不会销毁，会依旧存在于循环外部的执行环境中。</p><h3 id="3-垃圾收集"><a href="#3-垃圾收集" class="headerlink" title="3. 垃圾收集"></a>3. 垃圾收集</h3><p>3.1 JS中内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾收集机制的原理是：找出不再使用的变量，然后释放其占用的内存。具体到浏览器，一般有两种实现方法：<strong>标记清除</strong>，<strong>引用计数</strong>。</p><p>3.2 JS中最常用的垃圾收集机制是标记清除。当变量进入环境时，就将这个变量标记为“进入环境”</p><p>3.3 <strong>内存管理</strong>，使用具备垃圾收集机制的语言编写程序，开发人员一般不必担心内存管理的问题。但是分配给Web浏览器的可用内存通常要比分配给桌面应用程序的少。</p><p>3.4 优化内存的最佳方式是：让执行中的代码只保存必要的数据。一旦数据不再使用，最好将其值设置为null来释放其引用。但是，解除一个值的引用并不意味着自动回收该值所占用的内存，<strong>解除引用</strong>的真正作用是让其值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p><h2 id="第五章-引用类型"><a href="#第五章-引用类型" class="headerlink" title="第五章 引用类型"></a>第五章 引用类型</h2><p>引用类型与传统面向对象程序设计中的类类似，但实现不同。</p><h3 id="1-Object类型"><a href="#1-Object类型" class="headerlink" title="1. Object类型"></a>1. Object类型</h3><p>Object是一种基础类型，其他所有类型都从Object继承了基本的行为。</p><h3 id="2-Arrary类型"><a href="#2-Arrary类型" class="headerlink" title="2. Arrary类型"></a>2. Arrary类型</h3><p>2.1 Array类型的每一项可以保存任何类型的数据。数组的大小是可以动态调整的。</p><p>2.2 数组的length属性有个特点——它不是只读的。</p><p>2.3 <strong>检验数组</strong></p><blockquote><p>方法一：<code>value instanceof Array</code><br>方法二：<code>Array.isArray(value)</code></p></blockquote><p>2.4 <strong>转化方法</strong>：toString(),valueOf(),前者返回由数组中的每个值的字符串形式拼接而成的一个已逗号分隔的字符串。而后者还是返回的是一个数组。</p><p>2.5 <strong>栈方法</strong>和<strong>队列方法</strong>见<a href="http://blog.csdn.net/didiaidada/article/details/44243419" target="_blank" rel="noopener">这里</a>。</p><p>2.6 <strong>重排序方法</strong>：reverse()和sort(),前者只是反转数组。后者只是对字符串进行排序。若想比较大下，还得接受一个比较函数作为参数。</p><p>2.7 <strong>操作方法</strong></p><p>2.7.1 concat()方法可以基于当前数组中的所有项创建一个新数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var  colors = [&quot;red&quot;,&quot;green&quot;];</span><br><span class="line">var colors2 = colors.concat(&quot;yellow&quot;,[&quot;black&quot;,&quot;brown&quot;]);</span><br></pre></td></tr></table></figure><p>2.7.2 slice()可以基于当前数组中的一个或多个创建一个新数组。该函数接受一个或者两个参数，即要返回项的起始和结束位置。该方法返回起始和结束位置之间的项，但是不包括结束位置的项。</p><p>2.7.3 splice()的功能很强大，可以实现数组中元素的删除,插入,替换。该方法接收两个或者三个参数，起始项的位置，要删除的个数，待插入的元素。</p><p>2.8 <strong>位置方法</strong>：ECMAScript5为数组实例添加两个位置方法：indeOf()和lastIndex(),前者从数组开头开始向后查找，后者从数组的末尾开始向前查找。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。未找到的话返回-1。</p><p>2.9 <strong>迭代方法</strong></p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">解释(所有方法均运用于数组的每一项)</th></tr></thead><tbody><tr><td style="text-align:left"><code>every()</code></td><td style="text-align:left">若该函数对每一项都返回true，则返回true</td></tr><tr><td style="text-align:left"><code>filter()</code></td><td style="text-align:left">返回该函数会返回true的项组成的数组</td></tr><tr><td style="text-align:left"><code>forEach()</code></td><td style="text-align:left">无返回值</td></tr><tr><td style="text-align:left"><code>map()</code></td><td style="text-align:left">返回每次函数调用的结果组成的数组</td></tr><tr><td style="text-align:left"><code>some()</code></td><td style="text-align:left">若该函数对某一项返回true，则返回true</td></tr></tbody></table><p>2.10 <strong>归并方法</strong>：reduce()和reduceRight(),这两个函数接收四个参数：前一个值，当前值，项的索引和数组对象。</p><h3 id="3-Data类型"><a href="#3-Data类型" class="headerlink" title="3. Data类型"></a>3. Data类型</h3><p>3.1 <code>var now = new Date();</code>新创建的对象会自动获取当前的日期和时间。</p><p>3.2 如果想根据特定的日期和时间创建日期对象，必须传入该日期的毫秒数。Date.parse()和Date.UTC()可以实现。</p><p>3.3 Date.now()返回表示调用这个方法时的日期和时间的毫秒数。</p><p>3.4 <strong>日期格式化方法</strong></p><table><thead><tr><th style="text-align:left">方法</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">toDateString()</td><td>以特定实现的格式显示星期几，月，日和年</td></tr><tr><td style="text-align:left">toTimeString()</td><td>以特定于实现的格式显示时，分，秒和时区</td></tr><tr><td style="text-align:left">toLocaleDateString()</td><td>以特定于地区的格式显示星期几，月，日和年</td></tr><tr><td style="text-align:left">toLocaleTimeString()</td><td>以特定于地区的格式显示时，分，秒和时区</td></tr></tbody></table><h3 id="4-RegExp类型"><a href="#4-RegExp类型" class="headerlink" title="4. RegExp类型"></a>4. RegExp类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var expression = / pattern / flags</span><br></pre></td></tr></table></figure><p>4.1</p><table><thead><tr><th style="text-align:left">flags</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">g</td><td>即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止</td></tr><tr><td style="text-align:left">i</td><td>匹配时忽略模式与字符串的大小写</td></tr><tr><td style="text-align:left">m</td><td>表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项</td></tr></tbody></table><hr><p>4.2 RegExp对象的主要方法是<strong>exec()</strong>,该方法专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组。返回的数组包含两个额外的属性：index和input。index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。</p><p>4.3 RegExp的第二个方法是<strong>text()</strong>,他接受一个字符串参数，在模式与该参数匹配的情况下返回true，否则返回false。</p><h3 id="5-Function类型"><a href="#5-Function类型" class="headerlink" title="5.Function类型"></a>5.Function类型</h3><p>5.1 函数实际也是对象，每个函数都是Function类型的实例。<strong>函数是对象，函数名是指针。</strong></p><p>5.2 <strong>JavaScript的函数没有重载</strong></p><p>5.3 JS中即使声明函数的代码在调用它的代码后面，JS也能把函数声明提升到顶部。</p><p>5.4 在函数内部，有两个特殊的对象：arguments和this。arguments的主要用途是保存函数的参数，但是它还有一个属性名叫<strong>callee</strong>，该属性是一个指针，指向拥有该arguments对象的函数。<strong>this引用的是函数据以执行的环境对象</strong></p><p>5.5 函数的对象的属性<strong>caller</strong>这个属性保存着调用当前函数的函数的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function outer()&#123;</span><br><span class="line">    inner();</span><br><span class="line">    &#125;</span><br><span class="line">function inner()&#123;</span><br><span class="line">    alert(inner.caller);//也可以是alert(arguments.callee.caller)</span><br><span class="line">    &#125;</span><br><span class="line">outer();//会弹出outer()函数的源代码</span><br></pre></td></tr></table></figure><p>5.6 每个函数都包含两个属性：length和prototype。其中length属性表示函数希望接收的命名参数的个数。<strong>prototype是保存函数所有实例方法（toString(),valueOf()）的真正所在</strong>。</p><p>5.7 每个函数都包含两个非继承而来的方法：<strong>apply()和call(),这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this的值</strong>，实际上，传递参数并非apply()和call()真正的用武之地，它们真正的强大的地方是能够扩充函数赖以运行的作用域。详细用例请点击<a href="http://blog.csdn.net/didiaidada/article/details/45558793" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.color = &apos;red&apos;;</span><br><span class="line">var o = &#123; colar: &apos;blue&apos; &#125;;</span><br><span class="line"></span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">sayColor();                //red</span><br><span class="line">sayColor.call(this);       //red</span><br><span class="line">sayColor.call(window);     //red</span><br><span class="line">sayColor.call(o);          //blue</span><br></pre></td></tr></table></figure><p><strong><em>使用call()或者apply()的最大好处是：对象不需要和方法有任何耦合关系。</em></strong></p><p>5.8 ECMAScript还定义了一个方法：bind(),这个方法会创建一个函数实例，其this的值会被绑定到传给bind()函数的参数值。</p><h3 id="6-基本包装类型"><a href="#6-基本包装类型" class="headerlink" title="6. 基本包装类型"></a>6. 基本包装类型</h3><blockquote><p>为了便于操作基本类型值，ECMAScript还提供了三个特殊引用类型：Boolean，Number和String。<br>引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这就意味着我们不能再运行时为基本类型添加属性和方法。</p></blockquote><p>6.1 使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var val = &apos;25&apos;;</span><br><span class="line">var val1 = Number(val);</span><br><span class="line">alert(typeof val1);          //number</span><br><span class="line"></span><br><span class="line">var val2 = new Number(val);</span><br><span class="line">alert(typeof val2);          //object  val2中保存的是Number的实例。</span><br></pre></td></tr></table></figure><p>6.2 <strong>字符串大小写转换方法</strong>，toLowerCase(),toLocalLowerCase(),toUpperCase(),toLocalUpperCase();</p><hr><p>2015年8月28号回家，今天9月6号，昨天到学校，刚刚写了好多，但是不小心按了backspace,全删了！！！消失的部分以后有心情再写吧</p><hr><p>6.3 <code>indexOf()</code>和<code>lastIndexOf()</code>返回待查找字符在字符串中的位置。</p><p>6.4 <code>trim()</code>方法会创建一个字符串副本，删除前置及后缀的所有空格，然后返回结果。</p><p>6.5 <strong>字符串模式匹配方法</strong></p><table><thead><tr><th style="text-align:left">方法名</th><th>参数</th><th>返回值</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>match()</code></td><td>一个，正则表达式或者RegExp对象</td><td>匹配的结果构成的数组</td><td></td></tr><tr><td style="text-align:left"><code>search()</code></td><td>同上</td><td>返回字符串中第一个匹配项的索引</td><td></td></tr><tr><td style="text-align:left"><code>replace()</code></td><td>两个，第一个参数和上面的参数一样（也可以是字符串），第二参数是代替换的字符串（也可以是函数）</td><td>返回替换后的字符串</td><td></td></tr><tr><td style="text-align:left"><strong><code>split()</code></strong></td><td>两个，第一个参数可以是字符串，也可以是RegExp对象，是指定的分隔符。第二个参数用于指定数组的大小</td><td>通过字符串内包含的指定的分隔符，将字符串分割个多个子字符串，将结果返回在一个数组中</td><td>可以想象为将铅笔遮住字符串中所以与第一个参数匹配的字符，剩下没有被遮住的部分分别作为数组的每一项返回（可能包括字符串前后的空格）</td></tr><tr><td style="text-align:left"><code>localeCompare()</code></td><td>一个字符串</td><td>1（字符串参数在字母表中排在调用函数的字符串前面）；0（相等）；-1</td><td></td></tr><tr><td style="text-align:left"><code>fromCharCode()</code></td><td>一个或多个字符编码</td><td>返回对应的字符或字符串</td><td>—</td></tr></tbody></table><h3 id="7-单体内置对象"><a href="#7-单体内置对象" class="headerlink" title="7.单体内置对象"></a>7.单体内置对象</h3><p>7.1 <strong>内置对象</strong>：不必显示地实例化内置对象，因为他们已经实例化了。例如Object，Arrary，String。</p><p>7.2 <strong>单体内置对象</strong>：Globle，Math。</p><p>7.3 <strong>Globle对象</strong>：从某种意义上作为一个终极的“兜底儿对象”，事实上，没有全局变量和全局对象，所有在全局中定义的属性和方法，都是Globle对象的属性。</p><blockquote><p>URL编码方法</p><ol><li>encodeURL()和encodeURLComponent()方法可以对URL进行编码，以便发送给浏览器，有效的URL中不能包含某些字符，例如，空格。这两个方法用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。</li><li>两个方法中前者用于整个URL（一般只处理空格），后者用于URL的一段（处理所有非字母数字字符）</li><li>两个对应的解码分别为decodeURL()和decodeURLComponent()。</li></ol></blockquote><blockquote><p>eval()方法</p><p>eval()方法就像一个完整的ECMAScript解析器。</p></blockquote><blockquote><p>ECMAScript没有指出如何访问Globle()对象，但web浏览器都是将这个全局对象作为window对象的一部分加以实现。因此在全局作用域中声明的所有变量和函数，就都成了window对象的属性。</p></blockquote><p>7.4 <strong>Math()对象</strong></p><blockquote><p>Math对象的属性大都是数学计算中可能用到一些特殊值，例如：Math.PI</p></blockquote><blockquote><p>min()和max()</p><p>eg: <code>var max = Math.max(3,14,2,14);</code></p><p>eg: <code>var values = [1,2,3,4,5,6,7,8,9]; var max = Math.max.apply(Math, values); //Math作为第一个参数，从而正确的设置this的值</code></p></blockquote><blockquote><p>舍入方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;         alert(Math.ceil(25.9));</span><br><span class="line">&gt;         alert(Math.ceil(25.5));</span><br><span class="line">&gt;         alert(Math.ceil(25.1));</span><br><span class="line">&gt;         //以上均输出26</span><br><span class="line">&gt;         alert(Math.floor(25.9));</span><br><span class="line">&gt;         alert(Math.floor(25.5));</span><br><span class="line">&gt;         alert(Math.floor(25.1));</span><br><span class="line">&gt;         //以上均输出25</span><br><span class="line">&gt;         alert(Math.round(25.9));</span><br><span class="line">&gt;         alert(Math.round(25.5));</span><br><span class="line">&gt;         alert(Math.round(25.1));</span><br><span class="line">&gt;         //前两项输出26，最后一项输出25，遵循四舍五入</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Math.random()方法：返回一个大于0小于1的随机数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; function selectFrom(lowValue, upperValue)&#123;</span><br><span class="line">&gt;             var choice = upperValue - lowValue + 1;</span><br><span class="line">&gt;             return Math.floor(Math.random()*choice + lowValue);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>以上的这个 selectFrom(lowValue, upperValue)可以生成两个参数之间的任意一个随机整数。也可以用于返回数组中的任意一项。</p></blockquote><blockquote><p>其他方法<br>eg：Math.abs(num) 返回num的绝对值。</p></blockquote><p>内容出处: <a href="https://blog.csdn.net/didiaidada/article/details/48007449" target="_blank" rel="noopener">https://blog.csdn.net/didiaidada/article/details/48007449</a></p><p>因为最近也在读js高程 看了觉得总结的很好 自己也修改补充了一部分。可以没事的时候多看看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章，JavaScript简介&quot;&gt;&lt;a href=&quot;#第一章，JavaScript简介&quot; class=&quot;headerlink&quot; title=&quot;第一章，JavaScript简介&quot;&gt;&lt;/a&gt;第一章，JavaScript简介&lt;/h2&gt;&lt;p&gt;1.JavaScript包含
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>双向数据绑定的原理</title>
    <link href="http://yoursite.com/2018/06/09/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/06/09/双向数据绑定的原理/</id>
    <published>2018-06-09T08:10:33.000Z</published>
    <updated>2018-10-19T09:41:36.873Z</updated>
    
    <content type="html"><![CDATA[<h3 id="双向数据绑定的原理"><a href="#双向数据绑定的原理" class="headerlink" title="双向数据绑定的原理"></a>双向数据绑定的原理</h3><p>在学习Vue和Angular过程中都有一个双向数据绑定的一个东西，Vue中是v-model ,Angular中是ng-model,那他们是怎么实现的，<br>先说是怎么实现的吧，自己也网上找了一下实现的方法，找到了一个比较简洁的实现方法(可能不是vue或者angular源码的实现方法)，仅自己理解的实现方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">     &lt;input type=&quot;text&quot; id=&quot;model&quot;&gt;</span><br><span class="line">     &lt;span id=&quot;bind&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>js代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        model=document.getElementById(&quot;model&quot;);</span><br><span class="line">        bind=document.getElementById(&quot;bind&quot;);</span><br><span class="line">        </span><br><span class="line">        window.onload=function()&#123;</span><br><span class="line">            model.oninput=function()&#123;</span><br><span class="line">                bind.innerHTML=model.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>定义和用法<br>oninput 事件在用户输入时触发。<br>该事件在 <code>&lt;input&gt;</code>或 <code>&lt;textarea&gt;</code>元素的值发生改变时触发。<br>提示： 该事件类似于 onchange 事件。不同之处在于 oninput 事件在元素值发生变化是立即触发， onchange 在元素失去焦点时触发。另外一点不同是 onchange 事件也可以作用于 <code>&lt;keygen&gt;</code> 和 <code>&lt;select&gt;</code> 元素。</p></blockquote><p><strong>逻辑就是使用oninput事件获取每次输入input的value的值，然后使用innerHTML赋给span</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;双向数据绑定的原理&quot;&gt;&lt;a href=&quot;#双向数据绑定的原理&quot; class=&quot;headerlink&quot; title=&quot;双向数据绑定的原理&quot;&gt;&lt;/a&gt;双向数据绑定的原理&lt;/h3&gt;&lt;p&gt;在学习Vue和Angular过程中都有一个双向数据绑定的一个东西，Vue中是v-mo
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="Vue.js" scheme="http://yoursite.com/tags/Vue-js/"/>
    
      <category term="AngularJS" scheme="http://yoursite.com/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>在小程序中调用API</title>
    <link href="http://yoursite.com/2018/05/21/%E5%9C%A8%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%B0%83%E7%94%A8API/"/>
    <id>http://yoursite.com/2018/05/21/在小程序中调用API/</id>
    <published>2018-05-21T09:20:14.000Z</published>
    <updated>2018-10-19T09:17:06.412Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在小程序中调用一言API"><a href="#在小程序中调用一言API" class="headerlink" title="在小程序中调用一言API"></a>在小程序中调用一言API</h3><p>某一次在csdn看博客，看到了一个功能，就是可以随机显示一句话，都是特别经典的句子，后来便发挥了厚面皮的精神，就去私信问是怎么做的，二话没说那兄弟发给我一个网站，</p><p><a href="https://hitokoto.cn/" target="_blank" rel="noopener">一言</a></p><blockquote><p>这个网站是干什么的？<br>一言网(Hitokoto.cn)创立于2016年，隶属于萌创Team，目前网站主要提供一句话服务。<br>动漫也好、小说也好、网络也好，不论在哪里，我们总会看到有那么一两个句子能穿透你的心。我们把这些句子汇聚起来，形成一言网络，以传递更多的感动。如果可以，我们希望我们没有停止服务的那一天。<br>简单来说，一言指的就是一句话，可以是动漫中的台词，也可以是网络上的各种小段子。<br>或是感动，或是开心，有或是单纯的回忆。来到这里，留下你所喜欢的那一句句话，与大家分享，这就是一言存在的目的。<em></em>:本段文本源自hitokoto.us.</p></blockquote><p>在<strong><a href="https://hitokoto.cn/" target="_blank" rel="noopener">一言网</a></strong>上提供了可调用的API</p><p><a href="https://hitokoto.cn/api" target="_blank" rel="noopener">一言API接口说明</a><br>按照他给的参数和返回json数据，成功的在网页中调用了出来<br><a href="http://zhangningle.gitee.io/javascript-demo/%E4%B8%80%E8%A8%80.html" target="_blank" rel="noopener">我的一言deom</a><br>代码展示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;一言&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">      width: 500px;</span><br><span class="line">      margin: auto;</span><br><span class="line">      text-align: center;</span><br><span class="line">    &#125;</span><br><span class="line">    #hitokoto&#123;</span><br><span class="line">      font-size: 27px;</span><br><span class="line">    &#125;</span><br><span class="line">    p &#123;</span><br><span class="line">      font-size: 20px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #btn &#123;</span><br><span class="line">      padding: 15px 50px;</span><br><span class="line">      border: 0;</span><br><span class="line">      background: #00caeb;</span><br><span class="line">      color: #fff;</span><br><span class="line">      font-size: 22px;</span><br><span class="line">      border-radius: 5px;</span><br><span class="line">      cursor: pointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .cc&#123;</span><br><span class="line">      display: block;</span><br><span class="line">      text-align: right;</span><br><span class="line">      padding-right: 20px;</span><br><span class="line">      font-size: 25px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p id=&quot;hitokoto&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p class=&quot;cc&quot;&gt;『</span><br><span class="line">      &lt;span id=&quot;from&quot;&gt;&lt;/span&gt;』&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button id=&quot;btn&quot; onclick=&quot;window.location.reload();&quot;&gt;</span><br><span class="line">      换一换</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;!-- 以下写法，选取一种即可 --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 现代写法，推荐 --&gt;</span><br><span class="line">  &lt;!-- 兼容低版本浏览器 (包括 IE)，可移除 --&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;!--End--&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    fetch(&apos;https://v1.hitokoto.cn&apos;)</span><br><span class="line">      .then(function (res) &#123;</span><br><span class="line">        return res.json();</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(function (data) &#123;</span><br><span class="line">        var hitokoto = document.getElementById(&apos;hitokoto&apos;);</span><br><span class="line">        hitokoto.innerText = data.hitokoto;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(function (err) &#123;</span><br><span class="line">        console.error(err);</span><br><span class="line">      &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 老式写法，兼容性最忧 --&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    </span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&apos;get&apos;, &apos;https://v1.hitokoto.cn&apos;);</span><br><span class="line">    xhr.onreadystatechange = function () &#123;</span><br><span class="line">      if (xhr.readyState === 4) &#123;</span><br><span class="line">        var data = JSON.parse(xhr.responseText);</span><br><span class="line">        var hitokoto = document.getElementById(&apos;hitokoto&apos;);</span><br><span class="line">        var from = document.getElementById(&apos;from&apos;);</span><br><span class="line">        hitokoto.innerText = data.hitokoto;</span><br><span class="line">        from.innerText = data.from;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 新 API 方法， 十分简洁 --&gt;</span><br><span class="line">  &lt;script src=&quot;https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto&quot; defer&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>正好最近也在开发小程序，就心里痒痒。<br>想试试小程序中可不可以调用这个api，<br>小程序中</p><blockquote><p>url：这个是要请求的接口地址<br>data：一个入参<br>method：请求方式，如果是POST请求必须按上面写，默认是get请求，不用处理。<br>complete：页面请求完成后的方法，通过that.setData将数据传递给WXML页面。<br>success：页面加载成功后的执行方法。</p></blockquote><p>如图：<br><img src="http://p0bnwspy9.bkt.clouddn.com/yiyxcv.gif"><br>js代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 生命周期函数--监听页面加载</span><br><span class="line">   */</span><br><span class="line">  onLoad: function () &#123;</span><br><span class="line">    var that=this</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: &apos;https://v1.hitokoto.cn&apos;,</span><br><span class="line">      header:&#123;</span><br><span class="line">        &apos;content-type&apos;: &apos;application/json&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      success: function (res)&#123;</span><br><span class="line">        console.log(res.data)</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">          list: res.data</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>看完这个代码，你会想，根据微信小程序的绑定原理，这里边的代码哪里调用了onLoad（）这个函数，不用多想，微信小程序给你省略了这些步骤。直接调用list这个数组就行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;在小程序中调用一言API&quot;&gt;&lt;a href=&quot;#在小程序中调用一言API&quot; class=&quot;headerlink&quot; title=&quot;在小程序中调用一言API&quot;&gt;&lt;/a&gt;在小程序中调用一言API&lt;/h3&gt;&lt;p&gt;某一次在csdn看博客，看到了一个功能，就是可以随机显示一句
      
    
    </summary>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
      <category term="JSON" scheme="http://yoursite.com/tags/JSON/"/>
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="http://yoursite.com/2018/05/17/Vue%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2018/05/17/Vue知识/</id>
    <published>2018-05-17T02:04:55.000Z</published>
    <updated>2018-11-10T08:26:47.507Z</updated>
    
    <content type="html"><![CDATA[<p>vue</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vue&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Vue.js" scheme="http://yoursite.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>jQuery.Ajax调用的接口</title>
    <link href="http://yoursite.com/2018/05/14/jQuery.Ajax%E8%B0%83%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/05/14/jQuery.Ajax调用的接口/</id>
    <published>2018-05-14T09:20:14.000Z</published>
    <updated>2018-10-19T09:16:27.341Z</updated>
    
    <content type="html"><![CDATA[<h3 id="jQuery-json调用接口"><a href="#jQuery-json调用接口" class="headerlink" title="jQuery-json调用接口"></a>jQuery-json调用接口</h3><p>回顾一次面试经历，有一次面试人家问我会不会使用后端的接口（API）<br>因为当时学的都是写的静态页面 所以自然不知了，虽然那次面试很糟糕，但是收获也是很多的。<br>面试官后来告诉我一个网站就是这个网站：<a href="https://www.showapi.com/" target="_blank" rel="noopener">showAPI</a>;<br>上面有很多的免费的API接口可以试着调用 ，很感谢那位面试我的大佬。<br>今天有时间就顺便试了一下，调用了一个API “历史上的今天”<br>使用的jQuery解析的发送的ajax请求，然后他的服务器会返回一个json数据，使用  <code>$.each</code>在循环解析到页面中，虽然很小的一个小练习，但是对前后端数据交互有个更深的理解，<br>可能对于大家来说还是挺lou的 ，但对我自己来说确实很大的进步了。不喜勿喷。</p><p>先放预览地址吧：<a href="http://zhangningle.gitee.io/javascript-demo/%E5%8E%86%E5%8F%B2%E4%B8%8A%E7%9A%84%E4%BB%8A%E5%A4%A9.html" target="_blank" rel="noopener">历史上的今天</a></p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function Jdeta() &#123;</span><br><span class="line">           //alert(typeof dataNum)</span><br><span class="line">           $.ajax(&#123;</span><br><span class="line">               type: &apos;post&apos;,</span><br><span class="line">               url: &apos;http://route.showapi.com/119-42&apos;,</span><br><span class="line">               dataType: &apos;json&apos;,</span><br><span class="line">               data: &#123;</span><br><span class="line">                   &quot;showapi_timestamp&quot;: formatterDateTime(),</span><br><span class="line">                   &quot;showapi_appid&quot;: &apos;61967&apos;, //这里需要改成自己的appid</span><br><span class="line">                   &quot;showapi_sign&quot;: &apos;efc7d95dafb14c9dabf3867072d12b28&apos;,  //这里需要改成自己的应用的密钥secret</span><br><span class="line">                   &quot;date&quot;: &quot;&quot;</span><br><span class="line">               &#125;,</span><br><span class="line">               error: function (XmlHttpRequest, textStatus, errorThrown) &#123;</span><br><span class="line">                   alert(&quot;操作失败!&quot;);</span><br><span class="line">               &#125;,</span><br><span class="line">               success: function (result) &#123;</span><br><span class="line">                   console.log(result) //console变量在ie低版本下不能用</span><br><span class="line">                   //alert(result.showapi_res_code + &quot;调用成功&quot;)</span><br><span class="line">                   var title = document.getElementById(&quot;title&quot;);</span><br><span class="line">                   title.innerHTML = result.showapi_res_body.list[0].title;</span><br><span class="line">                   var img = document.getElementById(&quot;img&quot;);</span><br><span class="line">                   img.src = result.showapi_res_body.list[0].img;</span><br><span class="line">                   var day = document.getElementById(&quot;day&quot;);</span><br><span class="line">                   day.innerHTML = result.showapi_res_body.list[0].day;</span><br><span class="line">                   var month = document.getElementById(&quot;month&quot;);</span><br><span class="line">                   month.innerHTML = result.showapi_res_body.list[0].month;</span><br><span class="line">                   var year = document.getElementById(&quot;year&quot;);</span><br><span class="line">                   year.innerHTML = result.showapi_res_body.list[0].year;</span><br><span class="line">                   var json = eval(result.showapi_res_body.list); //数组     </span><br><span class="line">                   var result = &quot;&quot;;</span><br><span class="line">                   $.each(json, function (index) &#123;</span><br><span class="line">                       //循环获取数据    </span><br><span class="line">                       var title = json[index].title;</span><br><span class="line">                       var year = json[index].year;</span><br><span class="line">                       var month = json[index].month;</span><br><span class="line">                       var day = json[index].day;</span><br><span class="line">                       var img = json[index].img</span><br><span class="line">                       result += &quot;标题：&quot;+title +&quot;&lt;br/&gt;时间：&quot;+ year + &quot;年-&quot; + month + &quot;月-&quot; + day + &quot;日&lt;br/&gt;&lt;img src=&quot;+img+&quot; alt/&gt;&quot;+&quot;&lt;br&gt;&lt;br&gt;&quot;;</span><br><span class="line">                   &#125;);</span><br><span class="line">                   $(&quot;#list&quot;).html(&apos;&apos;);</span><br><span class="line">                   $(&quot;#list&quot;).html(result);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;jQuery-json调用接口&quot;&gt;&lt;a href=&quot;#jQuery-json调用接口&quot; class=&quot;headerlink&quot; title=&quot;jQuery-json调用接口&quot;&gt;&lt;/a&gt;jQuery-json调用接口&lt;/h3&gt;&lt;p&gt;回顾一次面试经历，有一次面试人家问我
      
    
    </summary>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
      <category term="JSON" scheme="http://yoursite.com/tags/JSON/"/>
    
  </entry>
  
</feed>
