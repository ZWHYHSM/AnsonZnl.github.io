<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anson&#39;s Blog</title>
  
  <subtitle>种一棵树最好的时间在十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-17T03:40:46.105Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>张宁乐</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小程序-蒙版弹出窗</title>
    <link href="http://yoursite.com/2019/09/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%AE%9E%E7%8E%B0%E8%92%99%E7%89%88%E5%BC%B9%E5%87%BA%E7%AA%97/"/>
    <id>http://yoursite.com/2019/09/17/小程序-实现蒙版弹出窗/</id>
    <published>2019-09-17T02:39:03.000Z</published>
    <updated>2019-09-17T03:40:46.105Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-2d3ed1a6fc6ce8da.gif?imageMogr2/auto-orient/strip" alt="蒙版弹出窗.gif" title="">                </div>                <div class="image-caption">蒙版弹出窗.gif</div>            </figure><p>话不多说 上代码。<br>wxml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;page&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;button bindtap=&quot;showMask&quot;&gt; 弹出 &lt;/button&gt;</span><br><span class="line">  &lt;view catchtouchmove=&quot;preventTouchMove&quot; class=&quot;alert-mask&quot; wx:if=&quot;&#123;&#123;showModal&#125;&#125;&quot;&gt;&lt;/view&gt;</span><br><span class="line">  &lt;view class=&quot;modalDlg&quot; wx:if=&quot;&#123;&#123;showModal&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;view class=&quot;modelTitle&quot;&gt;我是标题&lt;/view&gt;</span><br><span class="line">    &lt;view class=&quot;modeContent&quot;&gt;</span><br><span class="line">      我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容我是内容</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">    &lt;image class=&quot;hide-btn&quot; bindtap=&quot;hideMask&quot; src=&quot;./../images/tripDetailAlertHide.png&quot;&gt;&lt;/image&gt;  </span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p><p>wxss:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/* 弹窗蒙版 start */</span><br><span class="line">.alert-mask &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  background: #000;</span><br><span class="line">  z-index: 9000;</span><br><span class="line">  opacity: 0.7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.modalDlg &#123;</span><br><span class="line">  width: 80%;</span><br><span class="line">  height: 55%;</span><br><span class="line">  position: fixed;</span><br><span class="line">  top: 45%;</span><br><span class="line">  left: -1%;</span><br><span class="line">  z-index: 9999;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  padding: 25rpx;</span><br><span class="line">  margin: -370rpx 85rpx;</span><br><span class="line">  background-color: #fff;</span><br><span class="line">  border-radius: 18rpx;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.modelTitle&#123;</span><br><span class="line">  font-size: 38rpx;</span><br><span class="line">  margin-bottom: 20rpx;</span><br><span class="line">&#125;</span><br><span class="line">.hide-btn &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 10rpx;</span><br><span class="line">  right: 10rpx;</span><br><span class="line">  width: 50rpx;</span><br><span class="line">  height: 50rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 弹窗蒙版 end*/</span><br></pre></td></tr></table></figure></p><p>js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    showModal: false</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad(o) &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">    showMask: function () &#123;</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      showModal: true</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  hideMask: function () &#123;</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      showModal: false</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序中图片点击全屏-可滑动</title>
    <link href="http://yoursite.com/2019/08/27/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%9B%BE%E7%89%87%E7%82%B9%E5%87%BB%E5%85%A8%E5%B1%8F-%E5%8F%AF%E6%BB%91%E5%8A%A8/"/>
    <id>http://yoursite.com/2019/08/27/小程序中图片点击全屏-可滑动/</id>
    <published>2019-08-27T07:21:55.000Z</published>
    <updated>2019-08-27T07:32:27.509Z</updated>
    
    <content type="html"><![CDATA[<p>在小程序中，如果页面中有多张图片，那么用户可能会习惯向在朋友圈中一样打开图片，这里微信也提供了类似的api，可以直接拿来实现这个效果。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-7fc5e2b1a2180d76.gif?imageMogr2/auto-orient/strip" alt="小程序图片点击全屏.gif" title="">                </div>                <div class="image-caption">小程序图片点击全屏.gif</div>            </figure><p>wxml:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;block wx:for=&quot;&#123;&#123;arrImg&#125;&#125;&quot; wx:key=&quot;&#123;&#123;key&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;image </span><br><span class="line">    src=&quot;&#123;&#123;item&#125;&#125;&quot; </span><br><span class="line">    bindtap=&apos;previewimgs&apos; </span><br><span class="line">    data-img=&quot;&#123;&#123;item&#125;&#125;&quot; </span><br><span class="line">    mode=&quot;aspectFill&quot;</span><br><span class="line">    &gt;&lt;/image&gt;</span><br><span class="line">  &lt;/block&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p><p>wxss:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* perviewimg/perviewimg.wxss */</span><br><span class="line">view&#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">image&#123;</span><br><span class="line">  width: 200rpx;</span><br><span class="line">  height: 200rpx;</span><br><span class="line">  margin: 10rpx;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// perviewimg/perviewimg.js</span><br><span class="line">Page(&#123;</span><br><span class="line">  /**</span><br><span class="line">   * 页面的初始数据</span><br><span class="line">   */</span><br><span class="line">  data: &#123;</span><br><span class="line">    arrImg: [&apos;http://images.cdn.huiur.com/files/track/2019-07-16/img/img_5d2d47e38d473.jpeg-smimage&apos;,</span><br><span class="line">      &apos;http://images.cdn.huiur.com/files/track/2019-07-16/img/img_5d2d47e38d826.jpeg-smimage&apos;,</span><br><span class="line">      &apos;http://images.cdn.huiur.com/files/track/2019-07-16/img/img_5d2d47e38e924.jpeg-smimage&apos;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  previewimgs: function(e) &#123;</span><br><span class="line">    var currentImg = e.currentTarget.dataset.img;</span><br><span class="line">    console.log(currentImg);</span><br><span class="line">    wx.previewImage(&#123;</span><br><span class="line">      current: currentImg, // 当前显示图片的http链接 String</span><br><span class="line">      urls: this.data.arrImg // 需要预览的图片http链接列表 Array</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>微信官方文档链接：<a href="https://developers.weixin.qq.com/miniprogram/dev/api/media/image/wx.previewImage.html" target="_blank" rel="noopener">在新页面中全屏预览图片</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在小程序中，如果页面中有多张图片，那么用户可能会习惯向在朋友圈中一样打开图片，这里微信也提供了类似的api，可以直接拿来实现这个效果。&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lig
      
    
    </summary>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序之iPhone x适配</title>
    <link href="http://yoursite.com/2019/08/27/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8BiPhone%20x%E9%80%82%E9%85%8D/"/>
    <id>http://yoursite.com/2019/08/27/小程序之iPhone x适配/</id>
    <published>2019-08-27T07:21:55.000Z</published>
    <updated>2019-08-27T07:34:04.153Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.imooc.com/article/details/id/33529" target="_blank" rel="noopener">参考小程序iPhone X 视适配</a></p><p>在开发小程序时，可能需要适配iPhone x 的时候，你会发现底部的横线会出现遮挡，这时候就要处理下：</p><p>在app.js中添加一个检测当前设备是否是iPhoneX的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">globalData: &#123;</span><br><span class="line">  userInfo: null,</span><br><span class="line">  isIphoneX: false//判断是否是iPhoneX</span><br><span class="line">&#125;,</span><br><span class="line">onShow: function() &#123;</span><br><span class="line">  var that = this;</span><br><span class="line">  wx.getSystemInfo(&#123;</span><br><span class="line">    success: function(res) &#123;</span><br><span class="line">      // console.log(&apos;手机信息res&apos;+res.model)  </span><br><span class="line">      let modelmes = res.model;</span><br><span class="line">      if (modelmes.search(&apos;iPhone X&apos;) != -1) &#123;</span><br><span class="line">        that.globalData.isIphoneX = true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在需要做兼容的xxx.js中引入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var app= getApp();</span><br><span class="line">Page(&#123;</span><br><span class="line">data: &#123;</span><br><span class="line">  isIphoneX: false</span><br><span class="line">&#125;,</span><br><span class="line">onLoad: function()&#123;</span><br><span class="line">      // 判断是否为iPhoneX</span><br><span class="line">    var isIphoneX = app.globalData.isIphoneX;</span><br><span class="line">    console.log(isIphoneX ? &apos;是iPhoneX&apos; : &apos;不是iPhoneX&apos;)</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      isIphoneX: isIphoneX</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然后在xx.wxml中对需要做兼容的元素做判断 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;&#123;&#123;isIphoneX ? &apos;width30&apos; : &apos;width10&apos;&#125;&#125;&quot;&gt;&lt;/view&gt;</span><br></pre></td></tr></table></figure></p><p>然后在对应的wxss里设置好对应的类名就ok 了，比较简单方便。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.imooc.com/article/details/id/33529&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考小程序iPhone X 视适配&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在开发小程序时，可能需要适配iPhone
      
    
    </summary>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序速记[基础]</title>
    <link href="http://yoursite.com/2019/08/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%9F%E6%9F%A5/"/>
    <id>http://yoursite.com/2019/08/16/小程序速查/</id>
    <published>2019-08-16T06:49:03.000Z</published>
    <updated>2019-08-27T07:49:13.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="小程序基础"><a href="#小程序基础" class="headerlink" title="小程序基础"></a>小程序基础</h1><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul><li>project.config.json: 项目配置文件 app.json: 全局配置文件 page.json: 项目配置文件</li><li>app.json 配置相对应页面的路由（全局配置），window窗口配置：，各页面配置：，tab标签配置</li><li>每个页面对应的page.json 也可以配置window 信息，如与app.json相同则覆盖app.json配置</li></ul><h2 id="WXML"><a href="#WXML" class="headerlink" title="WXML"></a>WXML</h2><ul><li>模板语法 在wxml 中使用双大括号，在双引号中使用有效。</li><li><p>for 循环<br>其中有两个值，item 代表每一项，index 代表当前项的索引，并且小程序推荐的使用wx:for 的元素上使用<br>当页面发生改变重新渲染时，框架会效验key ，并重新排序，而非重新渲染，极大的提升了性能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wx:for = &quot;&#123;&#123; value &#125;&#125;&quot; </span><br><span class="line">wx:key =&quot; &#123;&#123; index &#125;&#125;&quot;</span><br></pre></td></tr></table></figure></li><li><p>block 标签 用于一个渲染一个包含多节点的结构块，可以在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;block wx:for=&quot;&#123;&#123;arr or obj&#125;&#125;&quot;&gt;</span><br><span class="line"> &lt;view&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure></li></ul><p>里的内容会渲染，block不会被循环，</p><ul><li>wx: if &amp; wx:elif &amp; wx:else 表示显示隐藏元素，true渲染元素，false不渲染元素</li><li>wx: hidden 接受一个布尔值，true隐藏，false显示，使用的是display 的black &amp; none 控制</li><li>data-*元素只能设置小写字母，就算设置成大写最后取值也是小写</li></ul><h2 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h2><ul><li>app.wxss:可写全局样式</li><li>rpx: 小程序中的响应式单位，在iPhone6下，1px = 2rpx ，所以设计稿可以使用iPhone6作为标准设计</li><li>import : 使用@import ‘../common.wxss’ 可以导入其他样式表</li></ul><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ul><li>setData: 当改变data的值时，需要用到setData，<a href="https://blog.csdn.net/qq_42817227/article/details/84834210" target="_blank" rel="noopener">参考链接</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.setData(&#123;</span><br><span class="line">    count: this.data.count+1,//改变string &amp; numbert</span><br><span class="line">    &apos;arr[0].name&apos;: &apos;张宁乐&apos;,//改变数组</span><br><span class="line">    &apos;obj.name&apos;: &apos;我已经改变&apos;//改变对象</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><ul><li><code>bind</code>绑定事件会冒泡，<code>catch</code> 绑定的事件不会冒泡</li><li>当组件在元素上触发时，会向绑定的函数传递一个“事件对象”<code>event</code>，通过它可以获得该组件的相关的信息（比如自定义数据等）</li><li>使用<code>input</code>时需要绑定<code>bindinput</code>事件，向M层的同步数据。</li></ul><h1 id="小程序云开发（ServerLess）"><a href="#小程序云开发（ServerLess）" class="headerlink" title="小程序云开发（ServerLess）"></a>小程序云开发（ServerLess）</h1><p>云开发  三大基础能力支持</p><ul><li>云函数：获取appid、获取openid 生成分享图、调用腾讯云sdk、数据库的操作</li><li>云数据库：对数据的增删改查</li><li>云存储： 管理文件 上传文件 下载文件 分享文件  可视化操作</li></ul><h2 id="云数据库"><a href="#云数据库" class="headerlink" title="云数据库"></a>云数据库</h2><blockquote><p>NoSql 数据库，类似mongoDB，存储json格式数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const db = wx.cloud.database();//获取数据库引用</span><br><span class="line">const todos = db.collection(&apos;todos&apos;);//获取集合引用</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>标识，最好是_id，{}为全部， 元素，操作的元素key:value，默认{} 为全部</strong></p><ul><li>增<code>todos.add({data:{...}}).then(..).catch(..)</code></li><li>删<code>todos.doc({.标识.}).remove({data{.元素.}}).then(. .).catch(..)</code></li><li>改<code>todos.doc({.标识.}).updata({data{.元素.}}).then(..).catch(..)</code></li><li>查<code>todos.doc({.标识.}).updata({data{.元素.}}).then(..).catch(..)</code></li></ul><h2 id="云函数"><a href="#云函数" class="headerlink" title="云函数"></a>云函数</h2><blockquote><p>类似Node.js 相当于后端</p></blockquote><h2 id="云储存"><a href="#云储存" class="headerlink" title="云储存"></a>云储存</h2><blockquote><p>存储文件，视频 音频等</p></blockquote><h2 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h2><p>小程序不支持 i++<br>在wxss中设置背景图片，图片的路径只能是https开头的网络图片</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener">小程序开发文档</a></p></li><li><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener">慕课网小程序入门</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;小程序基础&quot;&gt;&lt;a href=&quot;#小程序基础&quot; class=&quot;headerlink&quot; title=&quot;小程序基础&quot;&gt;&lt;/a&gt;小程序基础&lt;/h1&gt;&lt;h2 id=&quot;JSON&quot;&gt;&lt;a href=&quot;#JSON&quot; class=&quot;headerlink&quot; title=&quot;JSON&quot;
      
    
    </summary>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>深浅拷贝</title>
    <link href="http://yoursite.com/2019/06/26/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2019/06/26/深浅拷贝/</id>
    <published>2019-06-26T02:04:55.000Z</published>
    <updated>2019-06-26T02:30:08.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要进行拷贝"><a href="#为什么要进行拷贝" class="headerlink" title="为什么要进行拷贝"></a>为什么要进行拷贝</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj1=&#123;</span><br><span class="line">    value: &apos;a&apos;</span><br><span class="line">&#125;</span><br><span class="line">var obj2 = obj1;</span><br><span class="line">obj2.value=&apos;b&apos;;</span><br><span class="line">console.log(obj1);//&#123; value: &apos;b&apos; &#125;</span><br></pre></td></tr></table></figure><p> 因为对象是引用类型，所以赋值时的操作仅是赋予相同的地址，当对其中一个对象进行操作时，就会影响其他的对象。解决这个问题就需要拷贝了。</p><h2 id="浅拷贝："><a href="#浅拷贝：" class="headerlink" title="浅拷贝："></a>浅拷贝：</h2><p>使用原生的<code>Object.assign()</code>方法就可以实现浅拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj1=&#123;</span><br><span class="line">    value: &apos;a&apos;</span><br><span class="line">&#125;</span><br><span class="line">var obj2 = Object.assign(&#123;&#125;,obj1);</span><br><span class="line">obj2.value=&apos;b&apos;;</span><br><span class="line">console.log(obj1);//&#123; value: &apos;a&apos; &#125;</span><br></pre></td></tr></table></figure><p>但是如果拷贝的源对象当中包含对象时，<code>OBject.assign()</code>方法只会拷贝对象的引用地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj1=&#123;</span><br><span class="line">    value: &apos;a&apos;,</span><br><span class="line">    obj3:&#123;</span><br><span class="line">        value2: &apos;c&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var obj2 = Object.assign(&#123;&#125;,obj1);</span><br><span class="line">obj2.obj3.value2=&apos;b&apos;;</span><br><span class="line">console.log(obj1);//&#123; value: &apos;a&apos;, obj3:&#123; value2: &apos;b&apos; &#125; &#125;</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>如果要拷贝的对象中包含对象，就需要深拷贝了，一般使用原生的方法<code>JSON.parse(JSON.stringify(obj))</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">j1=&#123;</span><br><span class="line">    value: &apos;a&apos;,</span><br><span class="line">    obj3:&#123;</span><br><span class="line">        value2: &apos;c&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    arr:[1,2,3]</span><br><span class="line">&#125;</span><br><span class="line">var obj2 = JSON.parse(JSON.stringify(obj1));</span><br><span class="line">obj2.obj3.value2=&apos;b&apos;;</span><br><span class="line">obj2.arr[0]= &quot;a&quot;;</span><br><span class="line">console.log(obj2);//&#123; value: &apos;a&apos;, obj3:&#123; value2: &apos;b&apos; &#125;, arr:[&apos;a&apos;,2,3] &#125;</span><br><span class="line">console.log(obj1);//&#123; value: &apos;a&apos;, obj3:&#123; value2: &apos;c&apos; &#125;, arr:[1,2,3] &#125; 没有发生改变</span><br></pre></td></tr></table></figure><h2 id="实现一个对数组和对象的深拷贝的方法"><a href="#实现一个对数组和对象的深拷贝的方法" class="headerlink" title="实现一个对数组和对象的深拷贝的方法"></a>实现一个对数组和对象的深拷贝的方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;</span><br><span class="line">    name: &apos;znl&apos;,</span><br><span class="line">    age: 18,</span><br><span class="line">    friend:&#123;</span><br><span class="line">        name: &apos;borys&apos;,</span><br><span class="line">        age: 20</span><br><span class="line">    &#125;,</span><br><span class="line">    arr:[1,2,[3,4]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function copy(obj)&#123;</span><br><span class="line">    var type=Object.prototype.toString.call(obj);</span><br><span class="line">    if(!(type == &apos;[object Array]&apos; || type == &apos;[object Object]&apos;))&#123;</span><br><span class="line">        return &apos;Type Error!&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    return JSON.parse(JSON.stringify(obj));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2= copy(obj);</span><br><span class="line">console.log(obj.friend === obj2.friend)//false</span><br><span class="line">console.log(obj.arr === obj2.arr)//false</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">MDN Object.assign</a></li><li><a href="https://yuchengkai.cn/docs/frontend/#%E6%B5%85%E6%8B%B7%E8%B4%9D" target="_blank" rel="noopener">深拷贝</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要进行拷贝&quot;&gt;&lt;a href=&quot;#为什么要进行拷贝&quot; class=&quot;headerlink&quot; title=&quot;为什么要进行拷贝&quot;&gt;&lt;/a&gt;为什么要进行拷贝&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>创建对象的几种方法及优缺点</title>
    <link href="http://yoursite.com/2019/06/04/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <id>http://yoursite.com/2019/06/04/创建对象的几种方法及优缺点/</id>
    <published>2019-06-04T02:04:55.000Z</published>
    <updated>2019-06-05T01:45:39.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="new-Object"><a href="#new-Object" class="headerlink" title="new Object()"></a>new Object()</h2><p>直接通过构造函数创建一个新对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object()</span><br><span class="line">//等同于 var obj = &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>使用字面量的方式更简单，其实他俩是一样的。<br>优点是足够简单，缺点是每个对象都是独立的。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createObj(name,age)&#123;</span><br><span class="line">    var obj = &#123;&#125;;</span><br><span class="line">    obj.name=name;</span><br><span class="line">    obj.age=age;</span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br><span class="line">var Anson = createObj(&apos;Anson&apos;, 18)</span><br><span class="line">console.log(Anson)</span><br><span class="line">//&#123;name: &quot;Anson&quot;, age: 18&#125;</span><br></pre></td></tr></table></figure><p>优点是 可以解决创建多个相似对象的问题，缺点是 无法识别对象的类型。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">    this.name =name;</span><br><span class="line">    this.age=age;</span><br><span class="line">    this.sayName =function ()&#123; alert(this.name) &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(&apos;小明&apos;,13);</span><br><span class="line">console.log(person);</span><br><span class="line">//Person &#123;name: &quot;小明&quot;, age: 13, sayName: ƒ&#125;</span><br></pre></td></tr></table></figure><p>优点是 可以创建特定类型的对象，缺点是 多个实例重复创建方法</p><h2 id="（构造函数-原型）组合模式"><a href="#（构造函数-原型）组合模式" class="headerlink" title="（构造函数+原型）组合模式"></a>（构造函数+原型）组合模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    Person.prototype.sayName = function ()&#123; alert(this.name) &#125;</span><br><span class="line"> &#125;</span><br><span class="line">var person = new Person(&apos;小白&apos;,18)</span><br><span class="line">console.log(person);</span><br><span class="line">//Person &#123;name: &quot;小白&quot;, age: 18&#125; __proto__ -&gt; sayName: ƒ ()</span><br></pre></td></tr></table></figure><p>优点 多个实例引用一个原型上的方法 比较常用</p><h2 id="动态原型"><a href="#动态原型" class="headerlink" title="动态原型"></a>动态原型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">    this.name=name</span><br><span class="line">    this.age =age</span><br><span class="line">    if(typeof this.sayName != &apos;function&apos;)&#123;</span><br><span class="line">        Person.prototype.sayName = function()&#123; alert(this.name) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(&apos;小红&apos;,15)</span><br><span class="line">console.log(person);</span><br><span class="line">//Person &#123;name: &quot;小红&quot;, age: 15&#125; 动态创建sayName: ƒ ()</span><br></pre></td></tr></table></figure><p>优点 可以判断某个方法是否有效，来决定是否需要初始化原型，if只会在仅在碰到第一个实例调用方法<br>时会执行，此后所有实例共享此方法，需要注意的一点是，不能重新原型对象。</p><h2 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job)&#123;</span><br><span class="line">    var o=new Object();</span><br><span class="line">    o.name=name;</span><br><span class="line">    o.age=age;</span><br><span class="line">    o.job=job;</span><br><span class="line">    o.sayName=function()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var friend=new Person(&quot;her&quot;,18,&quot;Front-end Engineer&quot;);</span><br><span class="line">friend.sayName();</span><br><span class="line">//her</span><br></pre></td></tr></table></figure><p>除了使用<code>new</code>操作符，其他的和工厂函数一样，可以为对象创建构造函数。</p><h2 id="稳妥模式"><a href="#稳妥模式" class="headerlink" title="稳妥模式"></a>稳妥模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age)&#123;</span><br><span class="line">    var o=&#123;&#125;;</span><br><span class="line">    o.sayName=function()&#123; alert(name) &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">var person = (&apos;小亮&apos;，24);</span><br><span class="line">person.sayName();//’小亮‘</span><br></pre></td></tr></table></figure><p>除了使用<code>person.sayName()</code>之外 ，没有办法在访问到name的值，适合在某些安全执行环景下使用。</p><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  isHuman: false,</span><br><span class="line">  printIntroduction: function () &#123;</span><br><span class="line">    console.log(`My name is $&#123;this.name&#125;. Am I human? $&#123;this.isHuman&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const me = Object.create(person);</span><br><span class="line"></span><br><span class="line">me.name = &quot;Matthew&quot;; // &quot;name&quot; is a property set on &quot;me&quot;, but not on &quot;person&quot;</span><br><span class="line">me.isHuman = true; // inherited properties can be overwritten</span><br><span class="line"></span><br><span class="line">me.printIntroduction();</span><br><span class="line">// expected output: &quot;My name is Matthew. Am I human? true&quot;</span><br></pre></td></tr></table></figure><p>传入一个原型对象，创建一个新对象，使用现有的对象来提供新创建的对象的<strong>proto</strong>，实现继承。 </p><p><strong>参考：</strong>《JavaScript高级程序设计第三版》、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">MDN</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;new-Object&quot;&gt;&lt;a href=&quot;#new-Object&quot; class=&quot;headerlink&quot; title=&quot;new Object()&quot;&gt;&lt;/a&gt;new Object()&lt;/h2&gt;&lt;p&gt;直接通过构造函数创建一个新对象。&lt;br&gt;&lt;figure class=
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于跨域</title>
    <link href="http://yoursite.com/2019/03/15/%E5%85%B3%E4%BA%8E%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/03/15/关于跨域/</id>
    <published>2019-03-15T12:04:55.000Z</published>
    <updated>2019-03-15T12:32:26.666Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Vue搭建的一个后端管理系统中，我使用axios请求本地的Node环境下的接口，但是请求失败，然后我错误信息是：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2019/3/15/169808e13bfe3533?w=1159&h=38&f=jpeg&s=12458" alt="331552554043_.pic.jpg" title="">                </div>                <div class="image-caption">331552554043_.pic.jpg</div>            </figure><br>大概意思就是不能访问<code>http://localhost:8080</code><br>我的Vue项目端口是<code>http://localhost:8081</code>，Node服务端运行在<code>http://localhost:8080</code>端口上，也就是说因为请求端口和响应端口不一致，所以请求失败。<br>我也在网上查看了一些关于跨域出现的原因及解决的方法，并记录下来。</p><h2 id="为什么会有跨域"><a href="#为什么会有跨域" class="headerlink" title="为什么会有跨域"></a>为什么会有跨域</h2><blockquote><p>跨域一句话的理解就是：服务端和请求端的地址不一样。 </p></blockquote><h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h3><p> Ajax 的便利性大家都清楚，可以在不向服务器提交完整的页面的情况下，实现局部更新页面。但是浏览器处于对安全方面的考虑，不允许跨域调用其他页面的对象。<br>其实这个也不能怪浏览器，假设谁都可以随随便便向你发送请求，那样有很大的安全隐患。<br>根据浏览器的同源策略, 只有当协议，域名，端口相同的时候才算是同源, 反之则均视为是一个跨域的请求.<br>也就是说我刚刚的Vue端口是<code>8081</code>，服务端端口是<code>8080</code>，端口不一样，因为同源策略的存在 ，所有我的请求会失败。    </p><blockquote><p>一个问题，当找到了原因，这个问题就解决了一半了。</p></blockquote><h2 id="怎么解决跨域"><a href="#怎么解决跨域" class="headerlink" title="怎么解决跨域"></a>怎么解决跨域</h2><p>下面就先介绍三种跨全域的方法：</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>应该是最常见解决跨域的方法了，<br>他为什么能解决跨域呢，是因为Web 页面上调用 js 文件不受浏览器同源策略的影响，所以通过 Script 便签可以进行跨域的请求：</p><ol><li>首先前端先设置好回调函数，并将其作为 url 的参数。</li><li>服务端接收到请求后，通过该参数获得回调函数名，并将数据放在参数中将其返回</li><li>收到结果后因为是 script 标签，所以浏览器会当做是3脚本进行运行，从而达到跨域获取数据的目的。<br>我的前端是<code>index.html</code>，后端是<code>server.js</code><br>后端逻辑：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//server.js</span><br><span class="line">const url = require(&apos;url&apos;);</span><br><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">http.createServer((req, res)=&gt;&#123;</span><br><span class="line">const data = &#123;</span><br><span class="line">    x: 10//返回的数据</span><br><span class="line">&#125;;</span><br><span class="line">const callback = url.parse(req.url, true).query.callback;</span><br><span class="line">res.writeHead(200);</span><br><span class="line">res.end(`$&#123;callback&#125;($&#123;JSON.stringify(data)&#125;)`);</span><br><span class="line">//执行回调函数，返回data</span><br><span class="line">&#125;).listen(3000, &apos;localhost&apos;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;启动服务，监听 localhost:3000&apos;);</span><br></pre></td></tr></table></figure></li></ol><p>然后使用<code>node server.js</code>运行<br>前端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//index.html</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">function jsonpCallback(data) &#123;</span><br><span class="line">    console.log(&apos;获得 X 数据:&apos; + data.x);</span><br><span class="line">&#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;http://localhost:3000?callback=jsonpCallback&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>之后打开index.html;就可以在控制台看到返回的数据了：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2019/3/15/169808e13be099dc?w=207&h=85&f=jpeg&s=4222" alt="341552556856_.pic.jpg" title="">                </div>                <div class="image-caption">341552556856_.pic.jpg</div>            </figure></p><p>至此，通过 JSONP 跨域获取数据已经成功了，jsonp这种方法跨域，他的兼容性很好，可以在古老的浏览器中国使用，因为这种方法是利用了<code>&lt;script&gt;</code>标签的特殊性，所有只支持GET请求。</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 ajax 只能同源使用的限制。</p><p>CORS 需要浏览器和服务器同时支持才可以生效，对于开发者来说，CORS 通信与同源的 ajax 通信没有差别，代码完全一样。浏览器一旦发现 ajax 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p><p>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。</p><p>前端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&quot;http://127.0.0.1:3000&quot;,</span><br><span class="line">    success:function(res)&#123;</span><br><span class="line">        var res = JSON.parse(res);</span><br><span class="line">        $(&apos;body&apos;).text(res.data);</span><br><span class="line">        console.log(res.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>这次前端启动需要使用<code>node-server</code>来启动，使用<code>npm install node-server</code>下载，然后当前目录下使用<code>node-server</code>就可以了<br>后端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">http.createServer((req, res)=&gt;&#123;</span><br><span class="line">const data = &#123;</span><br><span class="line">    &apos;data&apos;: &apos;Hello world&apos;//返回的数据</span><br><span class="line">&#125;;</span><br><span class="line">res.writeHead(200, &#123;&apos;Access-Control-Allow-Origin&apos;: &apos;http://127.0.0.1:8080&apos;&#125;);</span><br><span class="line">//设置的头部信息需要和前端请求的地址一致</span><br><span class="line">res.end(JSON.stringify(data));</span><br><span class="line">//返回data</span><br><span class="line">&#125;).listen(3000, &apos;127.0.0.1&apos;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;启动服务，监听 127.0.0.1:3000&apos;);</span><br></pre></td></tr></table></figure></p><p>使用命令<code>node server.js</code>启动；<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2019/3/15/169808e13bc07597?w=1240&h=792&f=jpeg&s=63249" alt="211552638161_.pic_hd.jpg" title="">                </div>                <div class="image-caption">211552638161_.pic_hd.jpg</div>            </figure></p><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p><p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p><h3 id="Server-Proxy"><a href="#Server-Proxy" class="headerlink" title="Server Proxy"></a>Server Proxy</h3><p>服务器代理，顾名思义，当你需要有跨域的请求操作时发送请求给后端，让后端帮你代为请求，然后最后将获取的结果发送给你。</p><p>假设有这样的一个场景，你的页面需要获取 <a href="http://link.zhihu.com/?target=https%3A//cnodejs.org/api" target="_blank" rel="noopener">CNode：Node.js专业中文社区</a> 论坛上一些数据，如通过 <a href="https://cnodejs.org/api/v1/topics" target="_blank" rel="noopener">https://cnodejs.org/api/v1/topics</a>，当时因为不同域，所以你可以将请求后端，让其对该请求代为转发。</p><p>后端代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const url = require(&apos;url&apos;);</span><br><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const https = require(&apos;https&apos;);</span><br><span class="line"></span><br><span class="line">http.createServer((req, res)=&gt;&#123;</span><br><span class="line">const path = url.parse(req.url).path.slice(1);</span><br><span class="line">//核对请求路由是否一致</span><br><span class="line">if(path === &apos;topics&apos;)&#123;</span><br><span class="line">    https.get(&apos;https://cnodejs.org/api/v1/topics&apos;, (resp)=&gt;&#123;</span><br><span class="line">        //https代发请求</span><br><span class="line">        let data=&apos;&apos;;</span><br><span class="line">        resp.on(&apos;data&apos;, chunk=&gt;&#123;</span><br><span class="line">            data+= chunk</span><br><span class="line">        &#125;);</span><br><span class="line">        resp.on(&apos;end&apos;, ()=&gt;&#123;</span><br><span class="line">            res.writeHead(</span><br><span class="line">                200,</span><br><span class="line">                &#123;&apos;Content-Type&apos;: &apos;application/json; charset=utf-8&apos;&#125;</span><br><span class="line">            );</span><br><span class="line">            res.end(data);</span><br><span class="line">            //返回数据</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;).listen(3000, &apos;127.0.0.1&apos;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;启动服务，监听 127.0.0.1:3000&apos;);</span><br></pre></td></tr></table></figure></p><p>前端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&quot;https://cnodejs.org/api/v1/topics&quot;,</span><br><span class="line">    success:function(res)&#123;</span><br><span class="line">        $(&apos;body&apos;).text(JSON.stringify(res));</span><br><span class="line">        console.log(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>这样就成功了<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2019/3/15/169808e13bdda705?w=1111&h=815&f=jpeg&s=297478" alt="221552639459_.pic_hd.jpg" title="">                </div>                <div class="image-caption">221552639459_.pic_hd.jpg</div>            </figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>常用的跨域方式基本就是这三种：</p><ol><li>JSONP<br>优点是可以兼容老浏览器，缺点是只能发送GET请求</li><li>CORS<br>优点简单方便，支持post请求，缺点是需要后端的配合,不支持老版浏览器。。</li><li>Server Proxy<br>优点是前端正常发送ajax请求，缺点是后端会二次请求。</li></ol><p>其他的跨域方式还有：<code>location.hash</code>、<code>window.name</code>、<code>postMessage</code>等方式，有时间也可以了解一下。</p><p>参考资料：</p><ul><li>跨域资源共享 CORS 详解[阮一峰的博客]：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></li><li>关于跨域，你想知道的全在这里：<a href="https://zhuanlan.zhihu.com/p/25778815" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25778815</a></li><li>不要再问我跨域的问题了[sf]：<a href="https://segmentfault.com/a/1190000015597029" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015597029</a></li><li>关于跨域,以及跨域的几种方式[cnblog]：<a href="https://www.cnblogs.com/chenshishuo/p/4919224.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenshishuo/p/4919224.html</a></li><li>浏览器的同源策略[MDN]:<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用Vue搭建的一个后端管理系统中，我使用axios请求本地的Node环境下的接口，但是请求失败，然后我错误信息是：&lt;br&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
 
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>Vue中的验证登录状态</title>
    <link href="http://yoursite.com/2019/03/09/Vue%E4%B8%AD%E7%9A%84%E9%AA%8C%E8%AF%81%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2019/03/09/Vue中的验证登录状态/</id>
    <published>2019-03-09T14:21:55.000Z</published>
    <updated>2019-03-09T10:33:19.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue项目中实现用户登录及token验证"><a href="#Vue项目中实现用户登录及token验证" class="headerlink" title="Vue项目中实现用户登录及token验证"></a>Vue项目中实现用户登录及token验证</h2><p>先说一下我的实现步骤： </p><ol><li>使用<code>easy-mock</code>新建登录接口，模拟用户数据</li><li>使用<code>axios</code>请求登录接口，匹配账号和密码</li><li>账号密码验证后， 拿到<code>token</code>，将token存储到<code>sessionStorage</code>中，并跳转到首页</li><li>前端每次跳转时，就使用导航守卫(vue-router.beforeEach)判断 <code>sessionStorage</code> 中有无 <code>token</code>，没有就跳转到登录页面，有则跳转到对应路由页面。</li><li>注销后，就清除<code>sessionStorage</code>里的<code>token</code>信息并跳转到登录页面</li></ol><h2 id="使用easy-mock模拟用户数据"><a href="#使用easy-mock模拟用户数据" class="headerlink" title="使用easy-mock模拟用户数据"></a>使用easy-mock模拟用户数据</h2><p>我用的是<a href="https://easy-mock.com/" target="_blank" rel="noopener">easy-mock</a>,新建了一个接口，用于模拟用户数据:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"error_code"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">"data"</span>: [&#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="string">'1'</span>,</span><br><span class="line">      <span class="string">"usertitle"</span>: <span class="string">"管理员"</span>,</span><br><span class="line">      <span class="string">"username"</span>: <span class="string">"admin"</span>,</span><br><span class="line">      <span class="string">"password"</span>: <span class="string">"123456"</span>,</span><br><span class="line">      <span class="string">"token"</span>: <span class="string">"@date(T)"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="string">'2'</span>,</span><br><span class="line">      <span class="string">"usertitle"</span>: <span class="string">"超级管理员"</span>,</span><br><span class="line">      <span class="string">"username"</span>: <span class="string">"root"</span>,</span><br><span class="line">      <span class="string">"password"</span>: <span class="string">"root"</span>,</span><br><span class="line">      <span class="string">"token"</span>: <span class="string">"@date(T)"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>login.vue中写好登陆框：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;用户名：&lt;input type=&apos;text&apos; v-model=&quot;userName&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;密码：&lt;input type=&apos;text&apos; v-model=&quot;passWord&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;login()&quot;&gt;登录&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          userName:&apos;root&apos;,</span><br><span class="line">          passWord:&apos;root&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>然后下载axios：<code>npm install axios --save</code>,用来请求刚刚定义好的easy-mock接口：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">login()&#123;</span><br><span class="line">       <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">       axios.get(<span class="string">'https://easy-mock.com/mock/5c7cd0f89d0184e94358d/museum/login'</span>).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">         <span class="keyword">var</span> res =response.data.data,</span><br><span class="line">             len = res.length,</span><br><span class="line">             userNameArr= [],</span><br><span class="line">             passWordArr= [],</span><br><span class="line">             ses= <span class="built_in">window</span>.sessionStorage; </span><br><span class="line">         <span class="comment">// 拿到所有的username</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">           userNameArr.push(res[i].username);</span><br><span class="line">           passWordArr.push(res[i].password);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">console</span>.log(userNameArr, passWordArr);</span><br><span class="line">         <span class="keyword">if</span>(userNameArr.indexOf(<span class="keyword">this</span>.userName) === <span class="number">-1</span>)&#123;</span><br><span class="line">             alert(<span class="string">'账号不存在！'</span>);</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">var</span> index = userNameArr.indexOf(<span class="keyword">this</span>.userName);</span><br><span class="line">           <span class="keyword">if</span>(passWordArr[index] === <span class="keyword">this</span>.passWord)&#123;</span><br><span class="line">             <span class="comment">// 把token放在sessionStorage中</span></span><br><span class="line">             ses.setItem(<span class="string">'data'</span>, res[index].token);</span><br><span class="line">             <span class="keyword">this</span>.$parent.$data.userTitle = res[index].usertitle;</span><br><span class="line">             <span class="comment">//验证成功进入首页</span></span><br><span class="line">             <span class="keyword">this</span>.startHacking (<span class="string">'登录成功！'</span>);</span><br><span class="line">             <span class="comment">//跳转到首页</span></span><br><span class="line">             <span class="keyword">this</span>.$router.push(<span class="string">'/index'</span>);</span><br><span class="line">             <span class="comment">// console.log(this.$router);</span></span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             alert(<span class="string">'密码错误！'</span>)</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'连接数据库失败！'</span>)</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><p>这一步最重要的是当账号密码正确时，把请求回来的<code>token</code>放在<code>sessionStorage</code>中，</p><h2 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h2><p>然后配置路由新加一个meta属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/'</span>,</span><br><span class="line">  name: <span class="string">'login'</span>,</span><br><span class="line">  component: login,</span><br><span class="line">  meta:&#123;</span><br><span class="line">    needLogin: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/index'</span>,</span><br><span class="line">  name: <span class="string">'index'</span>,</span><br><span class="line">  component: index,</span><br><span class="line">  meta:&#123;</span><br><span class="line">    needLogin: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>判断每次路由跳转的链接是否需要登录，</p><h2 id="导航卫士"><a href="#导航卫士" class="headerlink" title="导航卫士"></a>导航卫士</h2><p>在<code>main.js</code>中配置一个全局前置钩子函数：<code>router.beforeEach（）</code>，他的作用就是在每次路由切换的时候调用<br>这个钩子方法会接收三个参数：to、from、next。<br><code>to</code>：Route：即将要进入的目标的路由对象，<br><code>from</code>：Route：当前导航正要离开的路由，<br><code>next</code>：Function：个人理解这个方法就是函数结束后执行什么，先看官方解释<br>1.<code>next()</code>：进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是confirmed（确认的），<br>2.<code>next(false)</code>：中断当前的导航。如果浏览器的url改变了（可能是用户手动或浏览器后退按钮），那么url地址会重置到from路由对应的地址。<br>3.<code>next(&#39;/&#39;)</code>或<code>next({path:&#39;/&#39;})</code>：跳转到一个不同的地址。当前导航被中断，进入一个新的导航。</p><h2 id="用sessionStorage存储用户token"><a href="#用sessionStorage存储用户token" class="headerlink" title="用sessionStorage存储用户token"></a>用sessionStorage存储用户token</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路由守卫</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//路由中设置的needLogin字段就在to当中 </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.sessionStorage.data)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">window</span>.sessionStorage);</span><br><span class="line">      <span class="comment">// console.log(to.path) //每次跳转的路径</span></span><br><span class="line">      <span class="keyword">if</span>(to.path === <span class="string">'/'</span>)&#123;</span><br><span class="line">        <span class="comment">//登录状态下 访问login.vue页面 会跳到index.vue</span></span><br><span class="line">        next(&#123;<span class="attr">path</span>: <span class="string">'/index'</span>&#125;);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// 如果没有session ,访问任何页面。都会进入到 登录页</span></span><br><span class="line">      <span class="keyword">if</span> (to.path === <span class="string">'/'</span>) &#123; <span class="comment">// 如果是登录页面的话，直接next() --&gt;解决注销后的循环执行bug</span></span><br><span class="line">        next();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则 跳转到登录页面</span></span><br><span class="line">        next(&#123; <span class="attr">path</span>: <span class="string">'/'</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里用了<code>router.beforeEach</code> <a href="https://router.vuejs.org/zh/guide/advanced/" target="_blank" rel="noopener">vue-router导航守卫</a><br>每次跳转时都会判断<code>sessionStorage</code>中是否有<code>token</code>值，如果有则能正常跳转，如果没有那么就返回登录页面。</p><h2 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h2><p>至此就完成了一个简单的登录状态了，浏览器关闭后<code>sessionStorage</code>会清空的，所以当用户关闭浏览器再打开是需要重新登录的</p><p>当然也可以手动清除<code>sessionStorage</code>，清除动作可以做成注销登录，这个就简单了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">loginOut()&#123;</span><br><span class="line"><span class="comment">// 注销后 清除session信息 ，并返回登录页</span></span><br><span class="line"><span class="built_in">window</span>.sessionStorage.removeItem(<span class="string">'data'</span>);</span><br><span class="line"><span class="keyword">this</span>.common.startHacking(<span class="keyword">this</span>, <span class="string">'success'</span>, <span class="string">'注销成功！'</span>);</span><br><span class="line"><span class="keyword">this</span>.$router.push(<span class="string">'/index'</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>写一个清除<code>sessionStorag</code>的方法。<br>一个简单的保存登录状态的小Demo。</p><hr><p>参考：<br><a href="https://cloud.tencent.com/developer/article/1199255" target="_blank" rel="noopener">腾讯云社区-Vue+SessionStorage实现简单的登录</a><br> <a href="https://segmentfault.com/a/1190000016084468" target="_blank" rel="noopener">SF-从前后端分别学习——注册/登录流程2</a><br><a href="https://segmentfault.com/a/1190000009086403" target="_blank" rel="noopener">Vue-router实现单页面应用在没有登录情况下，自动跳转到登录页面</a><br><a href="https://segmentfault.com/a/1190000015201803" target="_blank" rel="noopener">vue+axios新手实践实现登陆</a><br><a href="https://segmentfault.com/a/1190000015637039" target="_blank" rel="noopener">Vue实战(四)登录/注册页的实现</a><br><a href="https://segmentfault.com/a/1190000016047911" target="_blank" rel="noopener">vue页面控制权限,vuex刷新保存状态、登录状态保存</a><br><a href="https://segmentfault.com/a/1190000016047911" target="_blank" rel="noopener">vue页面控制权限,vuex刷新保存状态、登录状态保存</a><br><a href="http://www.codes51.com/itwd/4114969.html" target="_blank" rel="noopener">(vue.js)前后端分离的单页应用如何来判断当前用户的登录状态？</a><br><a href="https://segmentfault.com/a/1190000016040068" target="_blank" rel="noopener">Vue登录注册，并保持登录状态</a><br><a href="https://www.cnblogs.com/hcxy/p/7993724.html" target="_blank" rel="noopener">vue登录注册及token验证</a><br><a href="https://www.cnblogs.com/web-record/p/9876916.html" target="_blank" rel="noopener">Vue项目中实现用户登录及token验证</a></p><p>vue-router守卫导航官方文档：<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB" target="_blank" rel="noopener">vue-router导航守卫</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue项目中实现用户登录及token验证&quot;&gt;&lt;a href=&quot;#Vue项目中实现用户登录及token验证&quot; class=&quot;headerlink&quot; title=&quot;Vue项目中实现用户登录及token验证&quot;&gt;&lt;/a&gt;Vue项目中实现用户登录及token验证&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="Vue.js" scheme="http://yoursite.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>我对JavaScript中this的一些理解</title>
    <link href="http://yoursite.com/2019/02/21/%E6%88%91%E5%AF%B9JavaScript%E4%B8%ADthis%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/02/21/我对JavaScript中this的一些理解/</id>
    <published>2019-02-21T10:34:03.000Z</published>
    <updated>2019-02-21T12:38:31.483Z</updated>
    
    <content type="html"><![CDATA[<p>因为日常工作中经常使用到<code>this</code>，而且在JavaScript中<code>this</code>的指向问题也很容易让人混淆一部分知识。<br>这段时间翻阅了一些书籍也查阅了网上一些资料然后结合自己的经验，为了能让自己更好的理解<code>this</code>，进而总结一篇文章。</p><h2 id="this-是什么"><a href="#this-是什么" class="headerlink" title="this 是什么"></a>this 是什么</h2><p><code>this</code>是 JavaScript 语言的一个关键字。它是函数运行时，在函数体内部自动生成的一个对象，只能在函数体内部使用。<br>实际是在函数被调用时才发生的绑定，也就是说<code>this</code>具体指向什么，取决于你是怎么调用的函数。</p><h2 id="this-指向的四种情况"><a href="#this-指向的四种情况" class="headerlink" title="this 指向的四种情况"></a>this 指向的四种情况</h2><p>这四种情况基本涵盖了JavaScript中常见的<code>this</code>指向问题</p><h3 id="1-全局的函数调用，this指向window"><a href="#1-全局的函数调用，this指向window" class="headerlink" title="1. 全局的函数调用，this指向window"></a>1. 全局的函数调用，this指向window</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">function fn() &#123;</span><br><span class="line">   console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">fn();  // 1</span><br></pre></td></tr></table></figure><p>这种 情况下的<code>this</code>其实就是<code>window</code>对象，这个很好理解。<br>但是还有一种情况，就是匿名函数的<code>this</code>也会指向<code>window</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a= &apos;window&apos;;</span><br><span class="line">var obj=&#123;a: &apos;object&apos;&#125;</span><br><span class="line">obj.fn=function()&#123;</span><br><span class="line">console.log(this.a);//Object</span><br><span class="line">+function()&#123;</span><br><span class="line">console.log(this.a)//window</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">obj.fn()</span><br></pre></td></tr></table></figure></p><p>匿名函数的执行环境具有全局性，因此它的<code>this</code>对象通常指向windows。<br>如果对此有疑惑，可以看知乎上的答案：<a href="https://www.zhihu.com/question/21958425" target="_blank" rel="noopener">知乎 - 匿名函数的this指向为什么是window?</a></p><h3 id="2-作为对象方法的调用，this指向该对象"><a href="#2-作为对象方法的调用，this指向该对象" class="headerlink" title="2. 作为对象方法的调用，this指向该对象"></a>2. 作为对象方法的调用，this指向该对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a =&apos;window&apos;</span><br><span class="line">var obj=&#123;</span><br><span class="line">  a: &apos;object&apos;,</span><br><span class="line">  fn: function()&#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.fn(); // object</span><br></pre></td></tr></table></figure><p>当函数作为某个对象的方法调用时，<code>this</code>就指这个函数所在的对象。</p><h3 id="3-作为构造函数调用，this指向实例"><a href="#3-作为构造函数调用，this指向实例" class="headerlink" title="3. 作为构造函数调用，this指向实例"></a>3. 作为构造函数调用，this指向实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">　this.x = 1;</span><br><span class="line">&#125;</span><br><span class="line">var obj = new fn();</span><br><span class="line">console.log(obj.x) // 1</span><br></pre></td></tr></table></figure><p>构造函数中的<code>this</code>，在通过<code>new</code>之后会生成一个新对象，this就指这个新对象。<br>对<code>new</code>有疑问的话，可以看 <a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">冴羽的博客 JavaScript深入之new的模拟实现 </a></p><h3 id="4-使用call-apply-bind调用-this指向第一个参数"><a href="#4-使用call-apply-bind调用-this指向第一个参数" class="headerlink" title="4. 使用call/apply/bind调用, this指向第一个参数"></a>4. 使用call/apply/bind调用, this指向第一个参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var obj1=&#123;</span><br><span class="line">  a: &apos;boj1&apos;</span><br><span class="line">&#125;</span><br><span class="line">var obj2=&#123;</span><br><span class="line">  a: &apos;obj2&apos;</span><br><span class="line">&#125;</span><br><span class="line">var obj3=&#123;</span><br><span class="line">  a: &apos;obj3&apos;</span><br><span class="line">&#125;</span><br><span class="line">function fn()&#123;</span><br><span class="line">  console.log(this.a);</span><br><span class="line">&#125;</span><br><span class="line">// apply</span><br><span class="line">fn.apply(obj1);// &apos;obj1&apos;</span><br><span class="line">// call</span><br><span class="line">fn.call(obj2);// &apos;obj2&apos;</span><br><span class="line">// bind</span><br><span class="line">var fnBind= fn.bind(obj3);</span><br><span class="line">fnBind();// &apos;obj3&apos;</span><br></pre></td></tr></table></figure><p><code>call/ apply / bind</code>都有一个共同的特点，就是改变<code>this</code>的指向，使用这种方法可以把别人的方法拿过来用到自己身上。</p><p>第一个参数为 <code>null</code> 的时候，视为指向 <code>window</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a=&apos;window&apos;</span><br><span class="line">var obj=&#123;</span><br><span class="line">  a: &apos;boj&apos;,</span><br><span class="line">  fn: function ()&#123;</span><br><span class="line">    console.log(this.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn.call(null);// &apos;window&apos;</span><br></pre></td></tr></table></figure></p><p>在这里如果是<code>obj.fn()</code>调用的<code>fn()</code>方法，<code>this</code>应该指向<code>obj</code>没错。<br>但是因为<code>call(null)</code>的存在，改变了指向，所以<code>this</code>指向了<code>window</code>。</p><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><p>正因为比较难理解，所以<code>this</code>指向也是面试时最容易遇到的问题，比如下面这道我曾遇到的一个面试题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var length = 10;</span><br><span class="line">function fn()&#123;</span><br><span class="line">  console.log(this.length);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  length: 5,</span><br><span class="line">  method: function(fn)&#123;</span><br><span class="line">    fn();//10</span><br><span class="line">    arguments[0]();//2 这里的this指向的arguments，所以获取的是arguments.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.method(fn, 1);</span><br></pre></td></tr></table></figure></p><p>在这道题里，不仅考察了对<code>this</code>熟悉程度，还考察了函数的传参形式、作用域、以及<code>arguments</code>这种特殊的数组的理解。<br>只有真正理解了这些才能正确的判断<code>this</code>究竟指向了谁。<br>所以，只有对<code>JavaScript</code>中的各项知识点深入理解，才会对<code>this</code>的概念越加清晰。</p><p>参考：<br><a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="noopener">阮一峰 - Javascript 的 this 用法</a><br><a href="http://caibaojian.com/deep-in-javascript-this.html" target="_blank" rel="noopener">前端开发博客 - 深入理解JavaScript this</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为日常工作中经常使用到&lt;code&gt;this&lt;/code&gt;，而且在JavaScript中&lt;code&gt;this&lt;/code&gt;的指向问题也很容易让人混淆一部分知识。&lt;br&gt;这段时间翻阅了一些书籍也查阅了网上一些资料然后结合自己的经验，为了能让自己更好的理解&lt;code&gt;this&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>理解JS 原型链</title>
    <link href="http://yoursite.com/2019/01/18/%E7%90%86%E8%A7%A3JS%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2019/01/18/理解JS原型链/</id>
    <published>2019-01-18T14:21:55.000Z</published>
    <updated>2019-01-18T15:08:50.007Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来对于JavaScript 的原型链的概念，始终有些东西有一种模糊感，最近刚好有时间就塌下心认真的把《JavaScript高级程序设计》中相关内容认真读了一遍，也查看了很多网上很多资料，以前很多不明白的地方也渐渐明白了起来。<br>写一篇文章记录一下最近学习的感悟。</p><h3 id="字面量创建对象"><a href="#字面量创建对象" class="headerlink" title="字面量创建对象"></a>字面量创建对象</h3><p>我们通常创建一个对象无非就两种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. var obj= new Object();//new 一个Object的实例</span><br><span class="line">2. var obj= &#123;&#125;;//对象字面量</span><br></pre></td></tr></table></figure></p><p>使用对象字面量 和使用new的方式是一样的。<br>为了简便，一般推荐使用使用字面量：<code>var o= {};</code></p><h3 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h3><p>当我们想要创建自定义的对象时，需要用到构造函数。<br>构造函数和普通函数有两个区别：    </p><pre><code>1. 便于和普通函数区分，函数名首字母大写。    2. 使用 `new` 操作符调用，返回一个实例对象。    </code></pre><p>除此之外和普通函数一摸一样。<br>我们使用构造函数<code>Person</code>来创建两个实例对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.sayName= function ()&#123; alert(this.name) &#125;</span><br><span class="line"> &#125;</span><br><span class="line">var person1 = new Person(&apos;小明&apos;);</span><br><span class="line">var person2 = new Person(&apos;小红&apos;);</span><br><span class="line">console.log(person1);//&#123;name: &quot;小明&quot;, sayName: fun&#125;</span><br><span class="line">console.log(person2);//&#123;name: &quot;小红&quot;, sayName: fun&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子不难理解，虽然这两个实例对象都有<code>sayName</code>方法，而且他们两个的作用也是一样的，但却是两个方法，只是名字和作用一样。    </p><p>画个图表示一下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-e6a1cb2af9592327?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="131547802804_.pic.jpg" title="">                </div>                <div class="image-caption">131547802804_.pic.jpg</div>            </figure></p><p>如果还不明白，我在打个比喻：<br>就像A街上有一间麦当劳，在B街上也开了一间麦当劳，它们都叫麦当劳，作用也是一样的。但是你总不能说他们是一间麦当劳吧？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.sayName === person2.sayName;<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>如果这样的话，我们每构造出来一个对象，都要单独为这个对象创建出一个专属于它自己使用的<code>sayName</code>，这是很占用内存的。  </p><p>那我们能不能让所有的实例对象都共同使用一个<code>sayName</code>方法，来节省内存，提升效率呢？这需要我们先理解原型对象的概念。</p><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>我们先了解原型对象的概念。</p><blockquote><p>每个对象都有原型对象（null除外），我们用<code>__proto__</code>表示，每个函数都有<code>prototype</code>属性，指向实例的原型对象。</p></blockquote><p>对照这句话，按照我们上面的例子，也就是说<code>Person.prototype</code>指向<code>person1</code>的原型对象(<code>__proto__</code>),<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype === person1.__proto__; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>为了便于理解，来看一张图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-f2e5ab0014367d09?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="71547797523_.pic.jpg" title="">                </div>                <div class="image-caption">71547797523_.pic.jpg</div>            </figure><p>恩~他们的关系大概就是这样。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型链简单用一句话概括就是：</p><blockquote><p>原型链就是 对象的<code>__proto__</code>所连接的链状结构</p></blockquote><p>为了方便我们理解原型链，举一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function F()&#123;</span><br><span class="line">    this.a = 1;</span><br><span class="line">    this.b = 2;</span><br><span class="line">&#125;</span><br><span class="line">F.prototype.b = 3;</span><br><span class="line">F.prototype.c = 4;</span><br><span class="line">var o = new F();// &#123;a: 1, b: 2&#125;</span><br><span class="line">//原型链：</span><br><span class="line">//o --&gt; o.__proto__ --&gt; o.__proto__.__proto__ --&gt; null</span><br><span class="line">// 其中的 --&gt; 就表示 __proto__ 也就是原型链</span><br><span class="line">console.log(o.a); // 1</span><br><span class="line">// o上有a这个属性吗？有的，该属性的值为1</span><br><span class="line"></span><br><span class="line">console.log(o.b); // 2</span><br><span class="line">// o上有b这个属性吗？有的，该属性的值为2</span><br><span class="line">// 原型上也有一个&apos;b&apos;属性,但是它不会被访问到.这种情况称为&quot;属性遮蔽 &quot;</span><br><span class="line"></span><br><span class="line">console.log(o.c); // 4</span><br><span class="line">// o上有c这个属性吗？没有，那看看原型上有没有</span><br><span class="line">// o.__proto__上有c这个属性吗？有的，该属性的值为4</span><br><span class="line"></span><br><span class="line">console.log(o.d); // undefined</span><br><span class="line">// o上有d这个属性吗？没有,那看看原型上有没有</span><br><span class="line">// o.__proto__ 上有d这个属性吗？没有，那看看它的原型上有没有</span><br><span class="line">// o.__proto__.__proto__ 为 null，停止搜索</span><br><span class="line">// 没有找到d属性，返回undefined。</span><br></pre></td></tr></table></figure></p><p>我们画张图来表示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-95ee1c64fb5b51e0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="91547800262_.pic_hd.jpg" title="">                </div>                <div class="image-caption">91547800262_.pic_hd.jpg</div>            </figure><p>图中这条红色的线就是原型链。<br>由此可见，<strong>实例对象可访问自己原型对象上的属性和方法</strong>，额..准确来说是:</p><ol><li>当一个对象 查找属性或方法时，自己有，停止查找，返回结果。</li><li>自己没有，顺着<code>__proto__</code>一直向上查找，如找到，停止查找，返回结果。</li><li>如果一直找到了原型链的最顶端(null)，还没有找到，返回<code>undefined</code>。</li></ol><p>我们先回顾一下那个<code>sayName</code>的问题：<br><strong>怎么让所有的实例对象都是用一个<code>sayName</code>方法呢</strong>。<br>现在我们可以使用原型对象来解决这个问题了。<br>我们把<code>sayName</code>方法放到实例的原型对象上面，也就是<code>Person.prototype</code>上面来供所有实例使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line"> &#125;</span><br><span class="line">Person.prototype.sayName=function ()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&apos;小明&apos;);</span><br><span class="line">var person2 = new Person(&apos;小红&apos;);</span><br><span class="line">person1.sayName === person2.sayName;//true</span><br></pre></td></tr></table></figure></p><p>用图表示：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-f4d5c032a9b2b20f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="101547801223_.pic.jpg" title="">                </div>                <div class="image-caption">101547801223_.pic.jpg</div>            </figure></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong>constructor</strong><br>说一下我的经历，一开始理解原型链时，一直在<code>prototype</code>、<code>__proto__</code>、<code>constructor</code>在这个三个属性中绕来绕去。</p><p>为了便于理解，我把<code>constructor</code>放在最后了。<br><code>constructor</code>字面意思就很容易理解，构造函数的意思。<br>一句话解释:</p><blockquote><p>每个原型对象都有一个 constructor 属性指向 关联的构造函数。</p></blockquote><p>还是上面那个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Person.prototype.constructor);//Person()&#123; fun &#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的一点是，实例对象上没有<code>constructor</code>属性。<br>但是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(person1.constructor) ;//Person()&#123; fun &#125;</span><br></pre></td></tr></table></figure></p><p>得出这个结果很简单:<br>实例上查找不到<code>constructor</code>属性 –&gt; 顺着<code>__proto__</code>在原型对象上找 –&gt; 找到并返回。</p><p><strong>Object.prototype</strong><br>刚才我们说了创建对象的两种方式：字面量创建对象和使用<code>new</code>操作符创建对象。<br>这两种方式创建出来的对象都会继承<code>Object.prototyoe</code>上的方法。<br>比如，我们使用字面量新创建一个对象<code>o</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;value: 1&#125;;</span><br><span class="line">o.toString();//&quot;[object Object]&quot;</span><br><span class="line">//查找过程： o --&gt; o.__proto__ 找到返回</span><br><span class="line">o.__proto__ === Object.prototype;//true</span><br></pre></td></tr></table></figure></p><p><code>o</code>这个的对象本身并没有<code>toString</code>这个方法，但它却可以使用<code>toString</code>方法。<br>因为它继承了<code>Object.prototyoe</code>上的<code>toString</code>的方法。</p><p><strong>null</strong><br>既然对象都会继承自<code>Object.prototype</code>上面的方法，那它自己的原型又是什么呢。答案是<code>null</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.__prototype__ === null;//true</span><br></pre></td></tr></table></figure></p><p>以上仅自己学习所得，如有不当之处 望指出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直以来对于JavaScript 的原型链的概念，始终有些东西有一种模糊感，最近刚好有时间就塌下心认真的把《JavaScript高级程序设计》中相关内容认真读了一遍，也查看了很多网上很多资料，以前很多不明白的地方也渐渐明白了起来。&lt;br&gt;写一篇文章记录一下最近学习的感悟。&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用Express搭建一个简单的服务器</title>
    <link href="http://yoursite.com/2019/01/04/%E4%BD%BF%E7%94%A8Express%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2019/01/04/使用Express搭建一个简单的服务器/</id>
    <published>2019-01-04T14:21:55.000Z</published>
    <updated>2019-01-04T15:27:50.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Express框架"><a href="#Express框架" class="headerlink" title="Express框架"></a>Express框架</h2><h3 id="Web-应用程序"><a href="#Web-应用程序" class="headerlink" title="Web 应用程序"></a>Web 应用程序</h3><p>Express 是一个保持最小规模的灵活的 Node.js Web 应用程序开发框架，为 Web 和移动应用程序提供一组强大的功能。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>使用您所选择的各种 HTTP 实用工具和中间件，快速方便地创建强大的 API。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>Express 提供精简的基本 Web 应用程序功能，而不会隐藏您了解和青睐的 Node.js 功能。</p><h2 id="Express-路由基本使用"><a href="#Express-路由基本使用" class="headerlink" title="Express-路由基本使用"></a>Express-路由基本使用</h2><p>下载：<code>npm install express --save</code></p><h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><p>新建一个<code>server.js</code>文件，然后输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const app= express();</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res)=&gt;&#123;</span><br><span class="line">    req.send(&apos;Hello world&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(8083, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;Server is running at http://localhost:8083&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然后运行：<code>node server.js</code><br>打开：<a href="http://localhost:8083/" target="_blank" rel="noopener">http://localhost:8083/</a><br>就出现：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-b7ae26b3cdafc65a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11546413582_.pic.jpg" title="">                </div>                <div class="image-caption">11546413582_.pic.jpg</div>            </figure></p><h3 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h3><p>Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(&apos;/&apos;, function (request, response) &#123;</span><br><span class="line">   // --</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>request 和 response 对象的具体介绍：</p><h3 id="Request-对象"><a href="#Request-对象" class="headerlink" title="Request 对象"></a>Request 对象</h3><blockquote><p>request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有：</p></blockquote><p>req.app：当callback为外部文件时，用req.app访问express的实例<br>req.baseUrl：获取路由当前安装的URL路径<br>req.body / req.cookies：获得「请求主体」/ Cookies<br>req.fresh / req.stale：判断请求是否还「新鲜」<br>req.hostname / req.ip：获取主机名和IP地址<br>req.originalUrl：获取原始请求URL<br>req.params：获取路由的parameters<br>req.path：获取请求路径<br>req.protocol：获取协议类型<br>req.query：获取URL的查询参数串<br>req.route：获取当前匹配的路由<br>req.subdomains：获取子域名<br>req.accepts()：检查可接受的请求的文档类型<br>req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages：返回指定字符集的第一个可接受字符编码<br>req.get()：获取指定的HTTP请求头<br>req.is()：判断请求头Content-Type的MIME类型</p><h3 id="Response-对象"><a href="#Response-对象" class="headerlink" title="Response 对象"></a>Response 对象</h3><blockquote><p>response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有：</p></blockquote><p>res.app：同req.app一样<br>res.append()：追加指定HTTP头<br>res.set()在res.append()后将重置之前设置的头<br>res.cookie(name，value [，option])：设置Cookie<br>opition: domain / expires / httpOnly / maxAge / path / secure / signed<br>res.clearCookie()：清除Cookie<br>res.download()：传送指定路径的文件<br>res.get()：返回指定的HTTP头<br>res.json()：传送JSON响应<br>res.jsonp()：传送JSONP响应<br>res.location()：只设置响应的Location HTTP头，不设置状态码或者close response<br>res.redirect()：设置响应的Location HTTP头，并且设置状态码302<br>res.render(view,[locals],callback)：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的页面，这样就不会自动输出了。<br>res.send()：传送HTTP响应<br>res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定Content-Type<br>res.set()：设置HTTP头，传入object可以一次设置多个头<br>res.status()：设置HTTP状态码<br>res.type()：设置Content-Type的MIME类型</p><h2 id="Express-路由"><a href="#Express-路由" class="headerlink" title="Express-路由"></a>Express-路由</h2><blockquote><p>我们已经了解了 HTTP 请求的基本应用，而路由决定了由谁(指定脚本)去响应客户端请求。<br>在HTTP请求中，我们可以通过路由提取出请求的URL以及GET/POST参数。</p></blockquote><p>路由的基本形式：<br><code>app.METHOD(PATH, HANDLER)</code></p><ol><li><code>app</code> 表示的是一个Express的实例</li><li><code>METHOD</code> 是http请求的方法（get, psot..）</li><li><code>PATH</code> 服务器上的路径</li><li><code>HANDLER</code>请求之后的执行函数</li></ol><p>下面的示例说明了如何定义路由：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 对/news 页面进行get请求</span><br><span class="line">app.get(&apos;news&apos;, (req, res)=&gt;&#123;</span><br><span class="line">    res.send(&apos;Hello news&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">// 对/about 页面进行post请求</span><br><span class="line">app.post(&apos;about&apos;, (req, res)=&gt;&#123;</span><br><span class="line">    res.send(&apos;Hello about&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">// 对/list* 可匹配 /list+任意字符</span><br><span class="line">app.get(&apos;/list*&apos;, (req, res)=&gt;&#123;</span><br><span class="line">    res.send(&apos;Hello list pages&apos;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然后运行：<code>node server.js</code><br>打开：<a href="http://localhost:8083/" target="_blank" rel="noopener">http://localhost:8083/</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-b8692b839960c7cf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="21546417068_.pic.jpg" title="">                </div>                <div class="image-caption">21546417068_.pic.jpg</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-688f54ceb329ceb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="31546417103_.pic.jpg" title="">                </div>                <div class="image-caption">31546417103_.pic.jpg</div>            </figure><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-e0af0827093b7ac1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="41546417120_.pic.jpg" title="">                </div>                <div class="image-caption">41546417120_.pic.jpg</div>            </figure></p><h2 id="Express-搭建静态资源库"><a href="#Express-搭建静态资源库" class="headerlink" title="Express-搭建静态资源库"></a>Express-搭建静态资源库</h2><blockquote><p>Express 提供了内置的中间件 express.static 来设置静态文件如：图片， CSS, JavaScript 等。</p></blockquote><p>你可以使用 express.static 中间件来设置静态文件路径。例如，如果你将图片， CSS, JavaScript 文件放在 public 目录下，你可以这么写：<br><code>app.use(express.static(&#39;public&#39;));</code></p><p>现在，你就可以访问 public 目录中的所有文件了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public/index.html</span><br><span class="line">public/images</span><br><span class="line">public/images/bg.jpeg</span><br><span class="line">public/css</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>如果要使用多个静态资源目录，请多次调用 express.static 中间件函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(express.static(&apos;public&apos;))</span><br><span class="line">app.use(express.static(&apos;files&apos;))</span><br></pre></td></tr></table></figure></p><p> Express 在静态目录查找文件，因此，存放静态文件的目录名不会出现在 URL 中。<br>但是您可以给静态目录添加一个路由：<br><code>app.use(&#39;/static&#39;, express.static(path.join(__dirname, &#39;public&#39;)))</code><br>设置<code>/static</code>为<code>/public</code>目录的路由。<br>现在，你就可以通过带有 /static 前缀地址来访问 public 目录中的文件了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8083/static/css</span><br><span class="line">http://localhost:8083/static/css/index.css</span><br><span class="line">http://localhost:8083/static/image</span><br><span class="line">http://localhost:8083/static/images/bg.jpeg</span><br><span class="line">http://localhost:8083/static/index.html</span><br></pre></td></tr></table></figure></p><p>为了安全，最好使用绝对路由：<br><code>app.use(&#39;/static&#39;, express.static(path.join(__dirname, &#39;public&#39;)))</code><br>然后运行：<code>node server.js</code><br>打开：<a href="http://localhost:8083/static" target="_blank" rel="noopener">http://localhost:8083/static</a><br>就可以访问public下的所有文件，如图：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-8d727856b5ec84a3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="61546420083_.pic_hd.jpg" title="">                </div>                <div class="image-caption">61546420083_.pic_hd.jpg</div>            </figure></p><h2 id="Express-模板引擎之EJS"><a href="#Express-模板引擎之EJS" class="headerlink" title="Express-模板引擎之EJS"></a>Express-模板引擎之EJS</h2><blockquote><p>EJS 是一套简单的模板语言，帮你利用普通的 JavaScript 代码生成 HTML 页面。</p></blockquote><p>下载Ejs: <code>npm install ejs --save</code><br>同目录下新建<code>myejs.js</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const express= require(&apos;express&apos;);</span><br><span class="line">const app = express();</span><br><span class="line">//设置模板文件的目录,并且新建一个viwes的目录</span><br><span class="line">app.set(&apos;views&apos;, &apos;./views&apos;);</span><br><span class="line">//注册模板引擎</span><br><span class="line">app.set(&apos;view engine&apos;, &apos;ejs&apos;);</span><br><span class="line">//使用res.render()来渲染一个视图并将呈现的HTML字符串发送给客户端；</span><br><span class="line">app.get(&apos;/&apos;, function(req, res,) &#123;</span><br><span class="line">    res.render(&apos;index&apos;, &#123; title: &apos;测试&apos; &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">//监听8083端口</span><br><span class="line">app.listen(8083, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;Server is running at http://localhost:8083&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在新建views目录中新建index.ejs:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><p>然后运行：<code>node myejs.js</code><br>打开：<a href="http://localhost:8083" target="_blank" rel="noopener">http://localhost:8083</a><br>即可看到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-b333856ae590d4e1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>当然，也可以返回一个json文件来渲染视图：<br>在同目录下新建一个data.json:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;list&quot;: [</span><br><span class="line">    &#123; &quot;name&quot;:&quot;小明&quot; , &quot;age&quot;:&quot;6&quot;, &quot;sex&quot;: &quot;男&quot;&#125;,</span><br><span class="line">    &#123; &quot;name&quot;:&quot;小红&quot; , &quot;age&quot;:&quot;4&quot; ,&quot;sex&quot;: &quot;女&quot;&#125;,</span><br><span class="line">    &#123; &quot;name&quot;:&quot;小亮&quot; , &quot;age&quot;:&quot;5&quot; ,&quot;sex&quot;: &quot;男&quot;&#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;source&quot;:&quot;神奇二班&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后更改myejs.js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const express= require(&apos;express&apos;);</span><br><span class="line">const fs= require(&apos;fs&apos;);</span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">//设置模板文件的目录,并且新建一个viwes的目录</span><br><span class="line">app.set(&apos;views&apos;, &apos;./views&apos;);</span><br><span class="line">//注册模板引擎</span><br><span class="line">app.set(&apos;view engine&apos;, &apos;ejs&apos;);</span><br><span class="line">//使用res.render()来渲染一个视图并将呈现的HTML字符串发送给客户端；</span><br><span class="line">app.get(&apos;/&apos;, function(req, res,) &#123;</span><br><span class="line">    getDataJson((dataJson)=&gt;&#123;</span><br><span class="line">        console.log(dataJson);</span><br><span class="line">        res.render(&apos;index&apos;, dataJson);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line">//访问data.json 拿到数据解析并返回</span><br><span class="line">const getDataJson=(callBack)=&gt;&#123;</span><br><span class="line">    fs.readFile(&apos;./data.json&apos;, (err, data)=&gt;&#123;</span><br><span class="line">        if(!err)&#123;</span><br><span class="line">            let jsonData= JSON.parse(data);</span><br><span class="line">            callBack(jsonData);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            throw err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">//监听8083端口</span><br><span class="line">app.listen(8083, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;Server is running at http://localhost:8083&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然后更改index.ejs:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;h4&gt;&lt;%=source %&gt;&lt;/h4&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;% for(var i=0; i&lt;list.length; i++)&#123; %&gt;</span><br><span class="line">        &lt;li&gt;&lt;%= list[i].name %&gt; | &lt;%= list[i].age %&gt; | &lt;%= list[i].sex %&gt;&lt;/li&gt;</span><br><span class="line">    &lt;% &#125; %&gt;    </span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>然后在运行：<br>然后运行：<code>node myejs.js</code><br>打开：<a href="http://localhost:8083/" target="_blank" rel="noopener">http://localhost:8083</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-62bf6f8073433d15.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>参考：<br><a href="https://github.com/AnsonZnl/StudyNodeJS/tree/master/demo/expressDemo" target="_blank" rel="noopener">GitHub源码</a><br><a href="http://www.expressjs.com.cn/" target="_blank" rel="noopener">Express官方文档</a><br><a href="https://ejs.bootcss.com/" target="_blank" rel="noopener">EJS 模板引擎</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Express框架&quot;&gt;&lt;a href=&quot;#Express框架&quot; class=&quot;headerlink&quot; title=&quot;Express框架&quot;&gt;&lt;/a&gt;Express框架&lt;/h2&gt;&lt;h3 id=&quot;Web-应用程序&quot;&gt;&lt;a href=&quot;#Web-应用程序&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>使用NodeJS 搭建静态服务器</title>
    <link href="http://yoursite.com/2018/12/21/%E4%BD%BF%E7%94%A8Node.js%20%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2018/12/21/使用Node.js 搭建静态服务器/</id>
    <published>2018-12-21T08:21:55.000Z</published>
    <updated>2018-12-21T08:22:28.256Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们可以使用Node设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。</p></blockquote><p>解析URL需要用到Node.js提供的url模块，它使用起来非常简单，通过parse()将一个字符串解析为一个Url对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var url= require(&apos;url&apos;);</span><br><span class="line">console.log(url.parse(&apos;http://user:pass@host.com:8080/path/to/file?query=string#hash&apos;));</span><br></pre></td></tr></table></figure></p><p>解析之后是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Url &#123;</span><br><span class="line">    protocol: &apos;http:&apos;,</span><br><span class="line">    slashes: true,</span><br><span class="line">    auth: &apos;user:pass&apos;,</span><br><span class="line">    host: &apos;host.com:8080&apos;,</span><br><span class="line">    port: &apos;8080&apos;,</span><br><span class="line">    hostname: &apos;host.com&apos;,</span><br><span class="line">    hash: &apos;#hash&apos;,</span><br><span class="line">    search: &apos;?query=string&apos;,</span><br><span class="line">    query: &apos;query=string&apos;,</span><br><span class="line">    pathname: &apos;/path/to/file&apos;,</span><br><span class="line">    path: &apos;/path/to/file?query=string&apos;,</span><br><span class="line">    href:</span><br><span class="line">     &apos;http://user:pass@host.com:8080/path/to/file?query=string#hash&apos; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>处理本地文件目录需要使用Node.js提供的path模块，它可以方便地构造目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">// 解析当前目录:</span><br><span class="line">console.log(path(__dirname));</span><br><span class="line">//__dirname 表示当前所在目录  &apos;/Users&apos;</span><br><span class="line"></span><br><span class="line">// 组合完整的文件路径:当前目录+&apos;pub&apos;+&apos;index.html&apos;:</span><br><span class="line">var filePath = path.join(__dirname, &apos;fileServer&apos;, &apos;index.html&apos;);</span><br><span class="line">// &apos;/Users/fileServer/index.html&apos;</span><br></pre></td></tr></table></figure></p><p>使用path模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于<code>C:\Users\fileServer\index.html</code>，这样，我们就不关心怎么拼接路径了。</p><p>最后，我们实现一个文件服务器file_server.js：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var </span><br><span class="line">    http= require(&apos;http&apos;),</span><br><span class="line">    fs= require(&apos;fs&apos;),</span><br><span class="line">    url= require(&apos;url&apos;),</span><br><span class="line">    path= require(&apos;path&apos;);</span><br><span class="line">    </span><br><span class="line">// 从命令行参数获取root目录，默认是当前目录:</span><br><span class="line">var root= path.join(__dirname, &apos;static&apos;, &apos;index.html&apos;);</span><br><span class="line"></span><br><span class="line">//创建服务器</span><br><span class="line">var server= http.createServer(function(request, response)&#123;</span><br><span class="line">    //获得ur的path 类似&apos;/css/index.css&apos;</span><br><span class="line">    var pathName= url.parse(request.url).pathname;</span><br><span class="line">    //获得对应的本地文件路径 类似’static/css/index.css‘</span><br><span class="line">    var filePath= path.join(root);</span><br><span class="line">    //获取文件状态</span><br><span class="line">    console.log(filePath);</span><br><span class="line">    fs.stat(filePath, function (err, stats) &#123;</span><br><span class="line">        if (!err &amp;&amp; stats.isFile()) &#123;</span><br><span class="line">            // 没有出错并且文件存在:</span><br><span class="line">            console.log(&apos;200 &apos; + request.url);</span><br><span class="line">            // 发送200响应:</span><br><span class="line">            response.writeHead(200);</span><br><span class="line">            // 将文件流导向response:</span><br><span class="line">            fs.createReadStream(filePath).pipe(response);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 出错了或者文件不存在:</span><br><span class="line">            console.log(&apos;404 &apos; + request.url);</span><br><span class="line">            // 发送404响应:</span><br><span class="line">            response.writeHead(404);</span><br><span class="line">            response.end(&apos;404 Not Found&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(8080);</span><br><span class="line">console.log(&apos;Server is running at http://127.0.0.1:8080/&apos;);</span><br></pre></td></tr></table></figure></p><p>当你的html文件是这样的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Road&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src=&quot;/images/bg.jpeg&quot; alt=&quot;11&quot;&gt;</span><br><span class="line">    &lt;h1&gt;书山有路勤为径,学海无涯苦做舟。&lt;/h1&gt;</span><br><span class="line">    &lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>然后请求<code>http://127.0.0.1:8080/index.html</code>就会打印出：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-5c918eec1e59e4ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="101544689152_.pic.jpg" title="">                </div>                <div class="image-caption">101544689152_.pic.jpg</div>            </figure></p><p>当然他只能发起请求，想要请求到并且正确返回还需要设置文件的ContentType属性。<br>我们可以使用<code>path.extname</code>获取请求文件的后缀：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let extname = path.extname(&apos;css/index.css&apos;);</span><br><span class="line">// .css</span><br></pre></td></tr></table></figure></p><p>我们获取到后缀之后就可以根据后缀来设置它的ContentType，这里需要用到一个mime.json文件，然后使用一个函数去匹配:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//mime 读取mime.json 里面存储了常见的文件的ContentType 为请求的对应的文件设置对应的 ContentType 属性</span><br><span class="line">function getContentType(extName, callBack)&#123;</span><br><span class="line">                //      文件后缀   回调函数</span><br><span class="line">    //读取mime.json</span><br><span class="line">    fs.readFile(&apos;./mime.json&apos;, (err, data)=&gt;&#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">        //读取失败 抛出错误</span><br><span class="line">            throw err;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 读取成功</span><br><span class="line">        let mimeJson = JSON.parse(data);</span><br><span class="line">        //转码 将json字符串转化成对象</span><br><span class="line">        let contentType = mimeJson[extName] || &apos;text/plain&apos;;</span><br><span class="line">        //取出对应json中 对应的 请求的后缀的相匹配的 ContentType 属性</span><br><span class="line">        callBack(contentType);</span><br><span class="line">        //执行这个回调函数 并传参contentType</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>搭建静态服务器的步骤应该是：</p><ol><li>先拿到请求文件的后缀名(extname)</li><li>引入mime.json 文件并读取-&gt;转码</li><li>匹配和后缀对应的ContentType</li><li>使用回调函数 所有请求的文件 都会拿到后缀 然后自动匹配相应的ContentType</li><li>执行getContentType函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getContentType(extname, (contentType)=&gt;&#123;</span><br><span class="line">    res.writeHead(200, &#123;&quot;Content-Type&quot;: contentType + &apos;;charset=UTF-8&apos;&#125;)</span><br><span class="line">    res.end(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/kuangshp128/article/details/75207984" target="_blank" rel="noopener">常见文件的mime类型</a><br><a href="https://github.com/AnsonZnl/StudyNodeJS/blob/master/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AF%BE%E6%97%B666-%E8%AF%BE%E6%97%B671%E7%AC%94%E8%AE%B0.md" target="_blank" rel="noopener">GitHub-Node 学习笔记</a><br><a href="https://www.cnblogs.com/xxchi/p/6382892.html" target="_blank" rel="noopener">参考-Node path模块相关方法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我们可以使用Node设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解析URL需要用到N
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>使用NodeJS写一个简单的api接口</title>
    <link href="http://yoursite.com/2018/12/15/%E4%BD%BF%E7%94%A8Node.js%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84api%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/12/15/使用Node.js写一个简单的api接口/</id>
    <published>2018-12-15T03:55:55.000Z</published>
    <updated>2018-12-21T08:22:22.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入Http模块"><a href="#引入Http模块" class="headerlink" title="引入Http模块"></a>引入Http模块</h2><p>默认你已经安装了<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a><br>Node当中内置了Http模块；<br>可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var http= require(&quot;http&quot;);</span><br></pre></td></tr></table></figure></p><p>引入http模块；</p><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p>用Node.js实现一个HTTP服务器程序非常简单。我们实现一个最简单的Web程序，<br>它对于所有请求，都返回Hello world!，新建一个文件夹<code>apiDemo</code> 在里面新建一个<code>server.js</code>写入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 导入http模块:</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">// 创建http server，并传入回调函数:</span><br><span class="line">var server = http.createServer(function (request, response) &#123;</span><br><span class="line">    // 回调函数接收request和response对象,</span><br><span class="line">    // 获得HTTP请求的method和url:</span><br><span class="line">    console.log(request.method + &apos;: &apos; + request.url);</span><br><span class="line">    // 将HTTP响应200写入response, 同时设置Content-Type: text/html:</span><br><span class="line">    response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/html&apos;&#125;);</span><br><span class="line">    // 将HTTP响应的HTML内容写入response:</span><br><span class="line">    response.end(&apos;Hello world!&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 让服务器监听8080端口:</span><br><span class="line">server.listen(8080);</span><br><span class="line"></span><br><span class="line">console.log(&apos;Server is running at http://127.0.0.1:8080/&apos;);</span><br></pre></td></tr></table></figure></p><p>然后在当前目录命令提示符下(cmd等)运行， 输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node server.js</span><br></pre></td></tr></table></figure></p><p>然后打开浏览器输入：<code>http://127.0.0.1:8080/</code> 就可以看到：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2018/12/14/167abd49988fb8f2?w=310&h=193&f=jpeg&s=7500" alt="91544605447_.pic.jpg" title="">                </div>                <div class="image-caption">91544605447_.pic.jpg</div>            </figure></p><p>同时可以看到命令行中有打印的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET: /</span><br><span class="line">GET: /favicon.ico</span><br></pre></td></tr></table></figure></p><p>主要需要了解的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.createServer(function(request, response)&#123;&#125;)</span><br></pre></td></tr></table></figure></p><p>它的作用是创建一个http服务，里面传一个回调函数，函数中包含两个参数分别是（request，response）。<br>其中request是请求对象，response是响应对象。<br>可以根据<code>request</code>对象拿到请求头的一些信息，如: <code>request.url</code>–返回请求路径<br>响应成功后：<br><code>response.writeHead()</code>————发送一个响应头给请求<br><code>response.end(&#39;xxx&#39;)</code>————响应成功 返回xxx<br><a href="http://nodejs.cn/api/http.html" target="_blank" rel="noopener">参考 Nodez中文网-HTTP</a></p><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>我们是想当访问<code>http://127.0.0.1:8080/</code>的时候返回当前目录的index.html。<br>也就是说当<code>request.url === &#39;/&#39;</code>是<code>true</code>时就可以确定当前请求的是根目录了，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var url = request.url;</span><br><span class="line">console.log(url);</span><br><span class="line">// &apos;/&apos;</span><br></pre></td></tr></table></figure></p><p>我们能创建一个服务，并且能使用<code>response.end(&#39;Hello world!&#39;);</code>返回“Hello world!”。如果想返回一个文件则需要用到Node.js的一个模块了——<strong>fs 文件系统</strong>。<br>它是Node当中处理文件的模块，首先引入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var fs= require(&apos;fs&apos;);</span><br></pre></td></tr></table></figure></p><p>可以使用<code>fs.readFile()</code>来读取文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(&apos;./index.html&apos;, function(err, data)  &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(data);</span><br><span class="line">// &lt;Buffer 3c 21 44 4f 4...&gt;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>回调函数 有两个参数 (err, data)，其中 data 是文件的内容，以二进制形式返回。</p><p>然后我们就可以编写代码了，当访问根目录时，返回index.html文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var http= require(&apos;http&apos;);</span><br><span class="line">var fs= require(&apos;fs&apos;);</span><br><span class="line">var server= http.createServer(function(request, response)&#123;</span><br><span class="line">    var url = request.url;</span><br><span class="line">    if(url === &apos;/&apos;)&#123;</span><br><span class="line">        fs.readFile(&apos;./index.html&apos;, function(err, data)&#123;</span><br><span class="line">          if(!err)&#123;</span><br><span class="line">            response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/html;charset=UTF-8&quot;&#125;);</span><br><span class="line">            response.end(data)</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">              throw err;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(&quot;错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(8080, &apos;127.0.0.1&apos;);</span><br></pre></td></tr></table></figure></p><p>然后在当前目录下新建<code>index.html</code>，在这里我们可以写一个ajax请求，一会我们点击按钮来实现ajax请求一组数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;box&quot;&gt;看不到看不到&lt;/div&gt;</span><br><span class="line">   &lt;button onclick=&quot;success()&quot;&gt;我是按钮&lt;/button&gt;</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">   function success()&#123;</span><br><span class="line">       var http= new XMLHttpRequest();</span><br><span class="line">       http.onreadystatechange= function()&#123;</span><br><span class="line">           if(http.status == 200 &amp;&amp; http.readyState == 4)&#123;</span><br><span class="line">               var msg= http.responseText;</span><br><span class="line">               var box= document.getElementById(&apos;box&apos;);</span><br><span class="line">               box.innerHTML= JSON.parse(msg).name;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //发送请求</span><br><span class="line">       http.open(&apos;GET&apos;, &apos;/data&apos;);</span><br><span class="line">       http.send();</span><br><span class="line">   &#125;</span><br><span class="line">   &lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>这段代码是点击按钮的时候 会向<code>/data</code>发起一个ajsx请求,</p><h2 id="实现简单的API接口"><a href="#实现简单的API接口" class="headerlink" title="实现简单的API接口"></a>实现简单的API接口</h2><p>既然能访问根目录时可以返回html文件，那我们可以自己设定一个url，当请求这个url是我们就给它返回一组json数据。正常来讲这些数据应该是从数据库读取的，在这里只模拟一组json数据，在当前目录新建一个<code>data.json</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;: &quot;尼古拉丁 * 赵四&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>所以当前的目录结构是：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://user-gold-cdn.xitu.io/2018/12/14/167abd4998736425?w=402&h=170&f=jpeg&s=4634" alt="41544775041_.pic.jpg" title="">                </div>                <div class="image-caption">41544775041_.pic.jpg</div>            </figure></p><p>然后我们可以在server.js中判断一下，当请求的url是<code>/data</code>时，则返回data.json：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(url === &apos;/data&apos;)&#123;</span><br><span class="line">        fs.readFile(&apos;./data.json&apos;, function(err, data)&#123;</span><br><span class="line">            if(!err)&#123;</span><br><span class="line">                response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;application/json&quot;&#125;);</span><br><span class="line">                response.end(data);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                throw err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>然后打开浏览器 <code>http://127.0.0.1:8080</code> 后，就会出现index.html页面，点击出现的按钮就会触发一个对 <code>/data</code>的ajax请求，当server.js接受到请求后，就会判断<code>url === &#39;/data&#39;</code>，然后它就会吧  <code>data.json</code>返回给我们。</p><p>最后的实现是点击按钮出现<strong>尼古拉丁 * 赵四</strong>，<br>GItHub源码：<a href="https://github.com/AnsonZnl/StudyNodeJS/tree/master/%E8%AF%BE%E7%A8%8B%E8%AF%BE%E4%BB%B6%E5%8F%8A%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81/apiDemo" target="_blank" rel="noopener">node-apiDemo</a><br>参考：<br><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345015296018cac40c198b543fead5c549865b9bd4a000" target="_blank" rel="noopener">廖雪峰-http详解</a><br><a href="http://nodejs.cn/api/fs.html" target="_blank" rel="noopener">Node-fs</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引入Http模块&quot;&gt;&lt;a href=&quot;#引入Http模块&quot; class=&quot;headerlink&quot; title=&quot;引入Http模块&quot;&gt;&lt;/a&gt;引入Http模块&lt;/h2&gt;&lt;p&gt;默认你已经安装了&lt;a href=&quot;https://nodejs.org/en/&quot; targe
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的预编译过程分析</title>
    <link href="http://yoursite.com/2018/12/11/JavaScript%E7%9A%84%E9%A2%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/11/JavaScript的预编译过程分析/</id>
    <published>2018-12-11T08:05:55.000Z</published>
    <updated>2018-12-11T08:43:37.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JavaScript概念"><a href="#一、JavaScript概念" class="headerlink" title="一、JavaScript概念"></a>一、JavaScript概念</h2><p>JavaScript ( JS ) 是一个单线程、解释型的编程语言。</p><h2 id="二、JavaScript语言特点"><a href="#二、JavaScript语言特点" class="headerlink" title="二、JavaScript语言特点"></a>二、JavaScript语言特点</h2><h3 id="2-1-单线程"><a href="#2-1-单线程" class="headerlink" title="2.1 单线程"></a>2.1 单线程</h3><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。</p><h3 id="2-2-解释型语言"><a href="#2-2-解释型语言" class="headerlink" title="2.2 解释型语言"></a>2.2 解释型语言</h3><p>自上而下，解释一行，执行一行；不会通篇编译为一个文件再执行。</p><h2 id="三、-JavaScript执行过程"><a href="#三、-JavaScript执行过程" class="headerlink" title="三、 JavaScript执行过程"></a>三、 JavaScript执行过程</h2><h3 id="3-1-语法分析"><a href="#3-1-语法分析" class="headerlink" title="3.1 语法分析"></a>3.1 语法分析</h3><p>  顾名思义 就是检查一遍js代码内有没有出现语法错误（比如少些个分号，多写个括号等）；语法分析期间不会执行代码</p><h3 id="3-2-预编译"><a href="#3-2-预编译" class="headerlink" title="3.2 预编译"></a>3.2 预编译</h3><p><strong>预编译发生在函数执行的前一刻</strong><br><strong>全局下：</strong><br>全局的变量声明和函数声明则会存放在全局对象内（Global Object 简称GO，它是window的一部分，你可以直接把他理解成window对象）中<br><strong>函数体内：</strong><br>预编译会提前把函数里的变量声明和函数声明依据规则存放在该活动对象内（Activation Object，简称AO），</p><p>预编译简单理解就是在内存中开辟一些空间，存放一些变量与函数 。</p><p>预编译大致可分为4步：</p><ol><li>创建AO(GO)对象</li><li>找形参和变量声明，将形参和变量名作为AO(GO)属性名，值为undefined</li><li>将实参值和形参统一</li><li>在函数体里面找函数声明，值赋予函数体。</li></ol><p>所以如果遇到下面这种情况，当函数声明和变量声明名称相同时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(a); </span><br><span class="line">var a= 1;</span><br><span class="line">function a()&#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>编译后的代码其实是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">function a()&#123;&#125;;</span><br><span class="line">console.log(a);</span><br><span class="line">a= 1;</span><br></pre></td></tr></table></figure></p><p>所以最后输出的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function a() &#123;&#125;</span><br></pre></td></tr></table></figure></p><h4 id="预编译小节"><a href="#预编译小节" class="headerlink" title="预编译小节"></a>预编译小节</h4><p><strong>预编译两个小规则</strong></p><ol><li>函数声明整体提升—(具体点说，无论函数调用和声明的位置是前是后，系统总会把函数声明移到调用前面） </li><li>变量 声明提升—(具体点说，无论变量调用和声明的位置是前是后，系统总会把声明移到调用前，注意仅仅只是声明，所以值是undefined），只有在解释执行阶段才会进行变量初始化，匿名函数不参与预编译。</li></ol><p><strong>预编译前奏</strong></p><ol><li>imply global 即任何变量，如果未经声明就赋值，则此变量就位全局变量所有(全局域就是window) 。</li><li>一切声明的全局变量，全是window的属性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var a=2; </span><br><span class="line">  console.log(window.a);//2</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-3-解释执行"><a href="#3-3-解释执行" class="headerlink" title="3.3 解释执行"></a>3.3 解释执行</h3><p>预编译完毕之后，JavaScript 脚本开始执行，执行顺序按照从上到下的顺序执行。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>JavaScript执行顺序</strong></p><ol><li>语法分析</li><li>预编译<br>2.1. 创建AO(GO)对象<br>2.2. 找形参和变量声明，将形参和变量名作为AO(GO)属性名，值为undefined<br>2.3. 将实参值和形参统一<br>2.4. 在函数体里面找函数声明，值赋予函数体。  </li><li>解释执行</li></ol><p>练习：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function a(a)&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    a= 2;</span><br><span class="line">    console.log(b);</span><br><span class="line">    var b= 3;</span><br><span class="line">    console.log(a);</span><br><span class="line">&#125;</span><br><span class="line">a(1);</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure></p><p>你可以先试想一下结果，然后复制代码到控制台去验证你的答案是否正确。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、JavaScript概念&quot;&gt;&lt;a href=&quot;#一、JavaScript概念&quot; class=&quot;headerlink&quot; title=&quot;一、JavaScript概念&quot;&gt;&lt;/a&gt;一、JavaScript概念&lt;/h2&gt;&lt;p&gt;JavaScript ( JS ) 是一个单
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>初试MongoDB学习之Mongoose的使用</title>
    <link href="http://yoursite.com/2018/11/23/MongoDB%E5%AD%A6%E4%B9%A0%E4%B9%8BMongoose%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/11/23/MongoDB学习之Mongoose的使用/</id>
    <published>2018-11-23T09:28:55.000Z</published>
    <updated>2018-12-21T08:20:27.716Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mongoose简介"><a href="#mongoose简介" class="headerlink" title="mongoose简介"></a>mongoose简介</h3><p>mongoose官网：<a href="https://mongoosejs.com/" target="_blank" rel="noopener">https://mongoosejs.com/</a></p><h4 id="为什么要用Mongoose"><a href="#为什么要用Mongoose" class="headerlink" title="为什么要用Mongoose"></a>为什么要用Mongoose</h4><blockquote><p>Mongoose就是一个让我们可以通过Node来操作MongoDB的一个模块。<br>Mongoose本质是一个对象文档模型（ODM）库，<br>他对Node原生的MongoDB模块进行了一部优化封装，并且提供了更多的功能。</p></blockquote><h4 id="Mongoose的优势"><a href="#Mongoose的优势" class="headerlink" title="Mongoose的优势"></a>Mongoose的优势</h4><ol><li>可以像操作对象一样操作数据库</li><li>可以为文档创建一个模式结构（Schema）</li><li>可以对模型中的文档/文档进行验证</li><li>数据可以通过类型转换为对象模型</li><li>可以使用中间件来应用业务逻辑挂钩</li><li>比Node原生的MongoDB驱动更容易</li></ol><h4 id="使用Mongoose"><a href="#使用Mongoose" class="headerlink" title="使用Mongoose"></a>使用Mongoose</h4><ol><li><p>下载安装mongoose模块<br><code>cnpm install mongoose --save</code></p></li><li><p>引用mongoose：<br><code>var mongoose =require(&quot;mongoose&quot;);</code></p></li><li>使用”mongoose”连接数据库：<br><code>var db =mongoose.connect(&quot;mongodb://user:pass@localhost:port/database&quot;);</code></li><li>执行下面代码检查默认数据库test，是否可以正常连接成功?<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var mongoose =require(&quot;mongoose&quot;);</span><br><span class="line">var db =mongoose.connect(&quot;mongodb://localhost/m_data&quot;);</span><br><span class="line">db.connection.on(&quot;error&quot;,function (error) &#123;</span><br><span class="line">   console.log(&quot;数据库连接失败：&quot; + error);</span><br><span class="line">&#125;);</span><br><span class="line">db.connection.on(&quot;open&quot;,function () &#123;</span><br><span class="line">   console.log(&quot;数据库连接成功！&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">db.connection.once(&apos;close&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;连接已经断开成功！&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="mongoose基本使用"><a href="#mongoose基本使用" class="headerlink" title="mongoose基本使用"></a>mongoose基本使用</h3><h4 id="mongoose的几个新的对象"><a href="#mongoose的几个新的对象" class="headerlink" title="mongoose的几个新的对象"></a>mongoose的几个新的对象</h4><p>在MongoDB中，多个Document可以组成Collection(以下简称集合)，多个集合又可以组成数据库。我们想要操作MongoDB数据，那就得先要具备上面所说的包含数据的“文档”，文档又是什么意思呢，请看如下介绍。</p><ol><li><strong>文档</strong> —— 是MongoDB的核心概念，是键值对的一个有序集，在JavaScript里文档被表示成对象。同时它也是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行，但更具表现力。</li><li><strong>集合</strong> —— 由一组文档组成，如果将MongoDB中的一个文档比喻成关系型数据库中的一行，那么一个集合就相当于一张表。</li><li><strong>Schema</strong>—— 一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅只是<strong>定义数据的类型</strong>，可以说是数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架。<br><strong>mongoose中任何任何事物都是从Schema开始的</strong>。每一个Schema对应MongoDB中的一个集合(collection)。Schema中定义了集合中文档(document)的样式。<h4 id="定义一个Schema（表-模式对象）"><a href="#定义一个Schema（表-模式对象）" class="headerlink" title="定义一个Schema（表/ 模式对象）"></a>定义一个Schema（表/ 模式对象）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//新建Schema 定义规则/字段的规则</span><br><span class="line">let Schema= mongoose.Schema;</span><br><span class="line">//定义personSchema的字段（规则）需要new一下 有点像构造函数的样子</span><br><span class="line">let personSchema= new Schema(&#123;</span><br><span class="line">    name: String,</span><br><span class="line">    sex: String,</span><br><span class="line">    age: Number</span><br><span class="line">&#125;);</span><br><span class="line">`</span><br></pre></td></tr></table></figure></li></ol><p><strong>基本属性类型有</strong>： </p><ul><li>String</li><li>Number</li><li>Date</li><li>Boolean</li><li>Buffer</li><li>ObjectId</li><li>Mixed</li><li>Array</li></ul><p><strong>Model</strong>—— 由Schema构造生成的模型，根据Schema定义的数据类型规则，可操作具体的符合改规则的数据。</p><h4 id="创建model（集合）"><a href="#创建model（集合）" class="headerlink" title="创建model（集合）"></a>创建model（集合）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let personModel= mongoose.model(&apos;person&apos;, personSchema);</span><br></pre></td></tr></table></figure><p>  person：数据库中的集合名称,当我们对其添加数据时如果person已经存在，则会保存到其目录下，如果未存在，则会创建person集合，然后在保存数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//4. 插入文档</span><br><span class="line">personModel.create(&#123;</span><br><span class="line">    name: &apos;张宁乐&apos;,</span><br><span class="line">    sex: &apos;男&apos;,</span><br><span class="line">    age: 18</span><br><span class="line">&#125;, (err)=&gt;&#123;</span><br><span class="line">   if(!err)&#123;</span><br><span class="line">       console.log(&apos;插入成功！&apos;)</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       throw err;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="mongoose-插入和查询"><a href="#mongoose-插入和查询" class="headerlink" title="mongoose 插入和查询"></a>mongoose 插入和查询</h3><p>mongoose查找数据的一些方法：<br><a href="https://mongoosejs.com/docs/api.html#model_Model.find" target="_blank" rel="noopener">https://mongoosejs.com/docs/api.html#model_Model.find</a></p><h4 id="插入多条数据"><a href="#插入多条数据" class="headerlink" title="插入多条数据"></a>插入多条数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">personModel.create([</span><br><span class="line">    &#123;name:&apos;张逗逗&apos;,age: 2,sex: &apos;男&apos;&#125;,</span><br><span class="line">    &#123;name:&apos;牛嘻嘻&apos;,age: 2,sex: &apos;女&apos;&#125;</span><br><span class="line">], (err)=&gt;&#123;</span><br><span class="line">   if(!err)&#123;</span><br><span class="line">       console.log(&apos;插入成功！&apos;)</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       throw err;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><ul><li>Model.find() <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">personModel.find(&#123;name: &apos;张宁乐&apos;&#125;, (err, data)=&gt;&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h4><ul><li>Model.find({}, callback) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">personModel.find(&#123;&#125;, (err, data)=&gt;&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>也可以选择查找数据的条件（0隐藏 1显示 id默认显示） 和MongoDB在命令行中的使用方法一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查询时只显示name </span><br><span class="line">personModel.find(&#123;&#125;, &#123;name: 1, _id: 0&#125;, (err,data)=&gt;&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>在<code>find()</code>中  <code>skip</code>（查询开始的位置）和<code>limit</code>（增加的条数）也可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">personModel.find(&#123;&#125;, &#123;name: 1, _id: 0, age: 1&#125;, &#123;skip: 0, limit: 2&#125;, (err, data)=&gt;&#123;</span><br><span class="line">    //只显示name 和 age   从第1开始 每次查询2条 </span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>MongoDB的find()、findOne() 等命令在 mongoose里都可以使用</strong><br>具体可参考 ：<a href="https://mongoosejs.com/docs/api.html#model_Model.find" target="_blank" rel="noopener">https://mongoosejs.com/docs/api.html#model_Model.find</a></p><h3 id="mongoose-修改和删除"><a href="#mongoose-修改和删除" class="headerlink" title="mongoose 修改和删除"></a>mongoose 修改和删除</h3><p>参考： <a href="https://mongoosejs.com/docs/api.html#model_Model.update" target="_blank" rel="noopener">https://mongoosejs.com/docs/api.html#model_Model.update</a></p><h4 id="修改方法："><a href="#修改方法：" class="headerlink" title="修改方法："></a>修改方法：</h4><ul><li>Model.update()</li><li>Model.updateMany()</li><li>Model.updateOne()</li><li>Model.watch()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">personModel.update(&#123;name: &apos;张宁乐&apos;&#125;, &#123;$set: &#123;age: 20&#125;&#125;, (err, data)=&gt;&#123;</span><br><span class="line">   if(!err)&#123;</span><br><span class="line">       console.log(&apos;修改成功！&apos;)</span><br><span class="line">       console.log(data)</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       throw err;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-22be72d3058566fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4a9f49d480f66c5a64cb9a833459fdd.png" title="">                </div>                <div class="image-caption">4a9f49d480f66c5a64cb9a833459fdd.png</div>            </figure><h4 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h4><ul><li>Model.remove()</li><li>Model.deleteMany()</li><li>Model.deleteOne()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">personModel.remove(&#123;name:&apos;牛嘻嘻&apos;&#125;, (err)=&gt;&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(&apos;删除成功！&apos;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="统计文档条数"><a href="#统计文档条数" class="headerlink" title="统计文档条数"></a>统计文档条数</h4><ul><li>Model.count() <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">personModel.count(&#123;&#125;, (err,count)=&gt;&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(&apos;查询条数成功！ 一共：&apos; + count + &apos;条&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-25dcaed274322130.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2b7684dc310af51ac7fb50e5daa1123.png" title="">                </div>                <div class="image-caption">2b7684dc310af51ac7fb50e5daa1123.png</div>            </figure><h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><p> Entity—— 由Model创建的实体，使用save方法保存数据，Model和Entity的操作都能影响数据库的操作，但Model比Entity更具操作性。<br>使用Model创建Entity，如下示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">let mongoose= require(&apos;mongoose&apos;);</span><br><span class="line">let db= mongoose.connection(&apos;mongodb://localhost/m_data&apos;);</span><br><span class="line">db.on(&apos;open&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;连接成功！&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">let Schema= mongoose.Schema;</span><br><span class="line">let personSchema= new Schema(&#123;</span><br><span class="line">    name: String,</span><br><span class="line">    sex: String,</span><br><span class="line">    age: Number</span><br><span class="line">&#125;);</span><br><span class="line">let personModel= mongoose.model(&apos;person&apos;, personSchema);</span><br><span class="line">let personEntity = new personModel(&#123;</span><br><span class="line">    name: &apos;许巍&apos;,</span><br><span class="line">    sex: &apos;男&apos;,</span><br><span class="line">    age: 38</span><br><span class="line">&#125;)</span><br><span class="line">personEntity.save((err, person)=&gt;&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(&apos;保存成功！&apos;)</span><br><span class="line">        console.log(person);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log(&apos;保存失败！&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-cef62c6a437fa126.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="c85c9b12f87f890e10e74f23555c802.png" title="">                </div>                <div class="image-caption">c85c9b12f87f890e10e74f23555c802.png</div>            </figure><p>参考：<a href="https://blog.csdn.net/swimming_in_IT_/article/details/80723866" target="_blank" rel="noopener">https://blog.csdn.net/swimming_in_IT_/article/details/80723866</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mongoose简介&quot;&gt;&lt;a href=&quot;#mongoose简介&quot; class=&quot;headerlink&quot; title=&quot;mongoose简介&quot;&gt;&lt;/a&gt;mongoose简介&lt;/h3&gt;&lt;p&gt;mongoose官网：&lt;a href=&quot;https://mongoosejs
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB中常用语句</title>
    <link href="http://yoursite.com/2018/11/17/MongoDB%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2018/11/17/MongoDB中常用语句/</id>
    <published>2018-11-17T14:23:20.000Z</published>
    <updated>2018-12-21T08:24:33.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MOngoDB-删除语句"><a href="#MOngoDB-删除语句" class="headerlink" title="MOngoDB  删除语句"></a>MOngoDB  删除语句</h3><p><strong>delete()删除</strong></p><ol><li>删除一个集合<br><code>db.collection.deleteOne()</code></li><li>删除多个集合<br><code>db.collection.deletMany();</code></li></ol><p><strong>remove()删除</strong></p><ol><li>删除所有的name：李四的数据<br><code>db.student.remove({name:&quot;李四&quot;});</code></li><li>只删除一条sex:男的数据 仅删除一条<br><code>db.student.remove({sex:&quot;男&quot;},true);</code></li><li>删除全部<br><code>db.student.remove({});</code></li></ol><h3 id="数据库假删除"><a href="#数据库假删除" class="headerlink" title="数据库假删除"></a>数据库假删除</h3><p>有时候用户删除操作的时候，需求是这样的，仅是隐藏这条数据，并不是真的从数据库中删除。<br>这时候就用到假删除了，<br>比如这个是张三发的两篇微博：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.student.insert([</span><br><span class="line">    &#123;name:&quot;张三&quot;,content:&quot;今天心情好&quot;,isDel:0&#125;,</span><br><span class="line">    &#123;name:&quot;张三&quot;,content:&quot;今天心情一般&quot;,isDel:0&#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-0cf6106c47156b0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="b21d2b7140562e21fcbe9c168e02da9.png" title="">                </div>                <div class="image-caption">b21d2b7140562e21fcbe9c168e02da9.png</div>            </figure><p>用户增加两条数据，但只保留后一条，删除前一条，这时候用到假删除 ，在添加数据时加上一个字段<code>isDel:0</code><br>所以当用户删除数据时候 执行的不是remove方法而是update方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.student.update(&#123;&quot;_id&quot; : ObjectId(&quot;5bd6a46f1eb7a22fa07cb382&quot;)&#125;,&#123;</span><br><span class="line">    $set:&#123;</span><br><span class="line">      isDel:1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-c1ca4b50a635972c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="98cf763807e662cd724e6d65f1638fb.png" title="">                </div>                <div class="image-caption">98cf763807e662cd724e6d65f1638fb.png</div>            </figure><p>当<code>isDel:0</code>是表示用户没有删除 为1是表示用户已经删除</p><p>所以在查询的时候要筛选name和isDel条件即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.student.find(&#123;name:&quot;张三&quot;,isDel:0&#125;);</span><br></pre></td></tr></table></figure></p><p>查询到用户没有删除的数据:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-a917d02348ba2b6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="121b7fc4d6f40af1de843359cdbf585.png" title="">                </div>                <div class="image-caption">121b7fc4d6f40af1de843359cdbf585.png</div>            </figure><p>然后就可以实现假删除了。</p><h3 id="批量数据的操作和修改"><a href="#批量数据的操作和修改" class="headerlink" title="批量数据的操作和修改"></a>批量数据的操作和修改</h3><ol><li><p>向集合中插入10000个文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr= [];</span><br><span class="line">for(var i=0;i&lt;10000;i++)&#123;</span><br><span class="line">   arr.push(&#123;counter:i&#125;);</span><br><span class="line">&#125;</span><br><span class="line">db.demos.insert(arr);</span><br><span class="line">db.demos.find();</span><br></pre></td></tr></table></figure></li><li><p>查询demos中counter为666的文档<br><code>db.demos.find({counter:666});</code></p></li><li>查询demos中counter小于66的文档<br><code>db.demos.find({counter:{$lt:666}});</code></li><li>查询demos中counter大T666的文档<br><code>db.demos.find({counter:{$gt:666}});</code></li><li>查询demos中counter大于66小于666的文档1120查吉demos集合中的前10余数据<br><code>db.demos.find({counter:{$gt:66, $lt:666}});</code></li><li>查石demos集合中的第1字到20条数据<br><code>db.demos.find().limit(10);</code></li><li>查春demos集合中的第2 1条到30条数据  分页功能   skip从多少条开始 limit每次查询多少条 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.demos.find().skip(0).limit(10);//第一页 从0条开始 每查询10条</span><br><span class="line">db.demos.find().skip(10).limit(10);//第二页 从10条开始 每查询10条</span><br><span class="line">db.demos.find().skip(20).limit(10);//第三页 从20条开始 每查询10条</span><br></pre></td></tr></table></figure></li></ol><h3 id="集合中文档关系"><a href="#集合中文档关系" class="headerlink" title="集合中文档关系"></a>集合中文档关系</h3><ol><li>一对一（noe to noe）:<br>比如：人和身份证   老公和老婆</li><li>一对多（noe to many）:<br>比如：父母和孩子  用户和物品</li><li>多对多（many to many）:<br>比如：老师和学生</li></ol><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>以内嵌文档的形式体现，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//一对一</span><br><span class="line">db.aAndb.insert([</span><br><span class="line"> &#123;name:&quot;杨过&quot;,wife:&#123;name:&quot;小龙女&quot;,sex:&quot;女&quot;&#125;,sex:&quot;男&quot;&#125;,</span><br><span class="line">  &#123;name:&quot;杨过&quot;,wife:&#123;name:&quot;小龙女&quot;,sex:&quot;女&quot;&#125;,sex:&quot;男&quot;&#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">db.aAndb.find();</span><br></pre></td></tr></table></figure></p><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>通过内嵌文档的形式实现或者通过集合的形式实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//一对多  比如  微博 和 微博评论</span><br><span class="line">//添加微博</span><br><span class="line">db.weibo.insert([</span><br><span class="line">&#123;weibo:&quot;世界这么大，我想去看看&quot;&#125;,</span><br><span class="line">&#123;weibo:&quot;我要做一名web开发者！！！&quot;&#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">db.weibo.find();</span><br></pre></td></tr></table></figure></p><p>添加评论<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">db.comments.insert([</span><br><span class="line">&#123;</span><br><span class="line">weibo_id: ObjectId(&quot;5bdd89e06a5e78f4cfc2b9c8&quot;),</span><br><span class="line">list:[</span><br><span class="line">   &quot;那你有钱吗&quot;,</span><br><span class="line">    &quot;一个人吗？？去呢啊？？&quot;,</span><br><span class="line">    &quot;加油！！&quot;</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">weibo_id: ObjectId(&quot;5bdd89e06a5e78f4cfc2b9c9&quot;),</span><br><span class="line">list:[</span><br><span class="line">   &quot;那你要学习HTML&quot;,</span><br><span class="line">   &quot;那还要你要学习css&quot;,</span><br><span class="line">    &quot;加油！！&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">db.comments.find();</span><br></pre></td></tr></table></figure></p><p>查询一对多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var weibo_id= db.weibo.findOne(&#123;&quot;weibo&quot; : &quot;世界这么大，我想去看看&quot;&#125;)._id;</span><br><span class="line">db.comments.find(&#123;weibo_id: weibo_id&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="多对多的关系"><a href="#多对多的关系" class="headerlink" title="多对多的关系"></a>多对多的关系</h4><p>比如：学生和老师<br>可以通过多文档关联，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//多对多  老师《------》学生</span><br><span class="line"></span><br><span class="line">//插入老师集合</span><br><span class="line">db.teachers.insert([</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;语文老师&quot;,</span><br><span class="line">  teacher_id: 1,</span><br><span class="line">  student_id:[</span><br><span class="line">     1001,</span><br><span class="line">     1002,</span><br><span class="line">     1003</span><br><span class="line">  ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;数学老师&quot;,</span><br><span class="line">  teacher_id: 2,</span><br><span class="line">  student_id:[</span><br><span class="line">     1001,</span><br><span class="line">     1002,</span><br><span class="line">     1003</span><br><span class="line">  ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;英语老师&quot;,</span><br><span class="line">  teacher_id: 3,</span><br><span class="line">  student_id:[</span><br><span class="line">     1001,</span><br><span class="line">     1002,</span><br><span class="line">     1003</span><br><span class="line">  ]</span><br><span class="line"> &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">db.teachers.find();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//插入学生集合</span><br><span class="line">db.students.insert([</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;小明&quot;,</span><br><span class="line">  student_id: 1001,</span><br><span class="line">  teacher_id:[</span><br><span class="line">     1,</span><br><span class="line">     2,</span><br><span class="line">     3</span><br><span class="line">  ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;小红&quot;,</span><br><span class="line">  student_id: 1002,</span><br><span class="line">  teacher_id:[</span><br><span class="line">     1,</span><br><span class="line">     2,</span><br><span class="line">     3</span><br><span class="line">  ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#123;</span><br><span class="line">  name:&quot;小刚&quot;,</span><br><span class="line">  student_id: 1003,</span><br><span class="line">  teacher_id:[</span><br><span class="line">     1,</span><br><span class="line">     2,</span><br><span class="line">     3</span><br><span class="line">  ]</span><br><span class="line"> &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">db.students.find();</span><br><span class="line">db.teachers.find();</span><br></pre></td></tr></table></figure></p><h3 id="排序和索引"><a href="#排序和索引" class="headerlink" title="排序和索引"></a>排序和索引</h3><h4 id="排序："><a href="#排序：" class="headerlink" title="排序："></a>排序：</h4><p>查询文档时，默认是按照_id的值进行排序的（升序）<br>sort() 可以用来指定文档的排序规则，sort() 内部需要传递一个对象来指定文档的排序规则 ，其中1表示升序 ，-1表示降序<br>limit skip sort 的顺序可以任意改变 ，运行时会自动调整。<br>不希望它默认按照id排序  希望它按照工资来排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//按照工资升序排列</span><br><span class="line"></span><br><span class="line">db.section.find().sort(&#123;wages:1&#125;);</span><br><span class="line"></span><br><span class="line">//优先按照工资升序排列  如果遇到相同的就在  按照id升序排列</span><br><span class="line">db.section.find().sort(&#123;wages: 1&#125;,&#123;_id: -1&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h4><p>展示字段中 部分内容<br>或者是提取这个字段内的部分内容<br>在查询时 ，可以在第二个参数来设置查询的结果投影</p><blockquote><p>索引： find({ 查询条件 }, { 检索范围（1显示 0隐藏）})<br>注意： <code>_id</code>如果不设置默认是1（显示） 可手动隐藏</p></blockquote><p><code>db.section.find({}, {name: 1});</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//只显示name和wages字段</span><br><span class="line">`db.section.find(&#123;&#125;, &#123;name: 1, _id: 0, wages: 1&#125;);`</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-1b481d1c9381e28f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a07a1f2945204ef671ddebc28871c00.png" title="">                </div>                <div class="image-caption">a07a1f2945204ef671ddebc28871c00.png</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MOngoDB-删除语句&quot;&gt;&lt;a href=&quot;#MOngoDB-删除语句&quot; class=&quot;headerlink&quot; title=&quot;MOngoDB  删除语句&quot;&gt;&lt;/a&gt;MOngoDB  删除语句&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;delete()删除&lt;/strong&gt;&lt;
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>初试MongoDB数据库</title>
    <link href="http://yoursite.com/2018/11/15/%E5%88%9D%E8%AF%95MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/11/15/初试MongoDB数据库/</id>
    <published>2018-11-15T06:04:55.000Z</published>
    <updated>2018-12-21T08:21:38.380Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h3><p><strong>数据库（Database）基本概念：</strong></p><ol><li>数据库就是按照一定的数据结构来组织，储存和管理数据的仓库</li><li>我们写的程序都是在内存中运行的，一旦程序运行结束或者计算机断点，程序运行中的数据就会全部丢失；所以我们就需要将一些程序的数据持久化到键盘之中，以确保数据的安全性。</li><li>数据库则是大批量数据持久化的普遍选择，1.文件 2. 数据库  </li></ol><p><strong>为什么都采用数据库来储存数据:</strong></p><ul><li>数据库是有结构的</li><li>数据库可以提供各种接口，让数据处理（增删改查）快捷方便</li><li>各种语言（PHP jsp .net..）提供了完善的接口</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-d9cbd052415afbf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="b6dde1cf95ae2a9ec8e68c0bf1719a3.png" title="">                </div>                <div class="image-caption">b6dde1cf95ae2a9ec8e68c0bf1719a3.png</div>            </figure><p>###数据库分类</p><ol><li>ROBMS（关系型数据库）：<ul><li>比如MySql 、sql server Oracle 等</li><li>特点 通过一张张表来建立关联</li><li>基本都使用SQL语言来管理数据库，</li></ul></li><li>Nosql (非关系型数据库)：<ul><li>没有行 、列的概念 用json类储存数据</li><li>集合相当于“表”，文档相当于“行”</li><li>标准化和非标准化的摩擦。</li><li>标准化限制创新，非标准话不能统一</li></ul></li></ol><p><strong>特征</strong>：<br> 使用键值（Key Value）储存数据；<br>MongoDB的逻辑结构是一种层次结构，主要由：文档(document)、集合(collection)、数据库(database)这三部分组成的。 </p><ul><li>文档(document)：由键/值对构成，像{a:1}；{s:”abc”}等，它是MongoDB核心单元，MongoDB的文档（document），相当于关系数据库中的一行记录。 </li><li>集合（Collection）：多个文档组成一个集合（collection），相当于关系数据库的表。 </li><li>数据库（database）：多个集合（collection），逻辑上组织在一起，就是数据库（database）。<br>一个MongoDB实例支持多个数据库（database）。</li></ul><p><strong>关系型数据库和非关系型数据库区别：</strong><br>关系型数据库比较结构化，操作不是很灵活，菲关系型数据库操作灵活，但不适合大型数据存储，比较适合微架构，两者是相辅相成的关系<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-db349e8b6512241e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8bc32dd95a923344fdc2710d2fcbeab.png" title="">                </div>                <div class="image-caption">8bc32dd95a923344fdc2710d2fcbeab.png</div>            </figure></p><p><strong>非关系型数据库使用方面：</strong></p><ol><li>数据模型比较简单</li><li>需要灵活性更强的后台系统</li><li>对数据库性能要求比较高</li><li>不需要高度的数据一致性</li></ol><p><strong>非关系型数据库主要适合小微型架构的使用</strong></p><h3 id="数据库MongoDB安装"><a href="#数据库MongoDB安装" class="headerlink" title="数据库MongoDB安装"></a>数据库MongoDB安装</h3><p>MongoDB（非关系型数据库）：</p><ol><li>适合快速开发web应用而设计的数据库系统</li><li>设计目标是极简、灵活、经常在web应用栈的业务层被运用</li><li>它的数据模型是面向文档的，类似于json的结构</li><li>所以这个数据库中是各种各样的json, 并以键值形式对存储</li></ol><p>安装：<br>下载:<a href="https://www.mongodb.com/" target="_blank" rel="noopener">https://www.mongodb.com/</a><br>偶数是稳定版，奇数是开发版<br>最好下载64位的系统版本的</p><p><strong>配置环境变量:</strong></p><ol><li>新建—&gt;安装到bin路径复制到环境变量</li><li>创建data-&gt;db文件夹</li><li>打开命令行输入mongod启动DB服务器</li><li>指定端口号和路径 mongod –dbpath d:\data\db</li><li>将MongDB设置为系统服务，data\log<br>创建配置文件在bin下穿件文件mongod.cfg<br>执行一段命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.exe create MongoDB binPath= &quot;\&quot;F:\MongoDB\Server\3.2\bin\mongod.exe\&quot; --service --config= \&quot;F:\MongoDB\Server\3.2\mongod.cfg\&quot;&quot; DisplayName= &quot;MongoDB&quot; start= &quot;auto&quot;</span><br></pre></td></tr></table></figure></li></ol><p>主要是让MongoDB一直运行在内存中<br>参考资料：<br><a href="https://www.cnblogs.com/wzlblog/p/6364045.html" target="_blank" rel="noopener">https://www.cnblogs.com/wzlblog/p/6364045.html</a><br><a href="https://www.cnblogs.com/chenlq/p/6515876.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenlq/p/6515876.html</a></p><h3 id="在命令行中使用MongoDB插入命令"><a href="#在命令行中使用MongoDB插入命令" class="headerlink" title="在命令行中使用MongoDB插入命令"></a>在命令行中使用MongoDB插入命令</h3><p><strong>MongoDB的组成：</strong></p><ul><li>数据库 数据库是一个仓库 在仓库里可以放集合</li><li>集合： 集合类似数组 在集合里可以放文档</li><li>文档：文档是数据库中最小的单位 我们储存和操作的内容都是文档。</li></ul><p><strong>基本指令：</strong><br><code>show dbs</code>  显示当前所有的数据库<br><code>use</code> 数据库名  进入到指定数据库<br><code>db</code> 显示当前所在的数据库<br><code>show collections</code> 显示数据库中的所有集合</p><p>使用管理员打开 cmd<br>输入 <code>mongo</code>进入MongoDB的环境<br>进入MongoDB的环境才能执行MongoDB的命令<br>然后使用命令行进行CRUD(增删改查)：<br><code>db.&lt;collection&gt;.insert(doc)</code></p><p><strong>举例子：</strong><br>想school数据库中的学生集合student中插入一个新的学生对象<br>增加一条数据：<br><code>db.student.insert({id:&quot;001&quot;,name:&quot;znl&quot;,age:18,sex:“男”})</code><br>在当前的集合（school）中新建一条数据</p><p>查询一条数据：<br><code>db.&lt;collection&gt;.find();</code></p><p>如：<code>db.student.find();</code><br>回车 就能查询student下的所有数据<br>插入多条数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.集合名.insert([</span><br><span class="line">    &#123;name:&quot;张三&quot;,age:18,sex:&quot;man&quot;&#125;,</span><br><span class="line">    &#123;name:&quot;张三&quot;,age:18,sex:&quot;man&quot;&#125;,</span><br><span class="line">    &#123;name:&quot;张三&quot;,age:18,sex:&quot;man&quot;&#125;,</span><br><span class="line">    &#123;id:18，name:&quot;张三&quot;,age:18,sex:&quot;man&quot;&#125;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p><blockquote><p>插入多条数据时把多条语句放在一个数组里<br>插入可随便插入 不必拘泥于字段是否相同 当插入的字段不存在时会自动创建该字段</p></blockquote><p>查看更多更多操作：<a href="http://www.mongodb.org.cn/manual/" target="_blank" rel="noopener">http://www.mongodb.org.cn/manual/</a></p><h3 id="MongoDB-可视化工具-【NOSQL】"><a href="#MongoDB-可视化工具-【NOSQL】" class="headerlink" title="MongoDB 可视化工具 【NOSQL】"></a>MongoDB 可视化工具 【NOSQL】</h3><p>然而一直使用命令行操作是很麻烦的事情，所以推荐使用NOSQL可视化工具<br>安装可视化工具下载地址：<a href="https://www.mongodbmanager.com/download" target="_blank" rel="noopener">https://www.mongodbmanager.com/download</a></p><h3 id="使用可视化工具"><a href="#使用可视化工具" class="headerlink" title="使用可视化工具"></a>使用可视化工具</h3><p>可视化工具 查找功能：<br>插入(insert)语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.student(集合名字).insert([</span><br><span class="line">&#123;id:1,name:&quot;znl&quot;,age:18&#125;,</span><br><span class="line">&#123;id:1,name:&quot;znl&quot;,age:18&#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></p><p>查询语句：<br><code>db.student(集合name).find();</code></p><p>设定条件查询：<br><code>db.student.find({ &quot;_id&quot; : ObjectId(&quot;5bd01c825f0d528d36a2c06f&quot;)});</code><br>查询id对应的数据<br><code>db.student.find({age:18,name:&quot;张三&quot;});</code><br>查询所有的age是18并且name是张三的人<br><code>db.student.findOne({age:18,name:&quot;张三&quot;});</code><br>查询单条符合条件的数据</p><p>操作符-查询有多少条数据：<br><code>db.student.find().count();</code><br>或<br><code>db.student.find().length();</code><br>返回数据总条数</p><p>查询符合条件数据的条数：<br><code>db.student.find({name:&quot;张三&quot;}).length();</code><br>返回符合name:”张三”的条数</p><h3 id="数据库更新命令"><a href="#数据库更新命令" class="headerlink" title="数据库更新命令"></a>数据库更新命令</h3><p>更新原有的字段的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;张三&quot;&#125;,&#123;$set:&#123;</span><br><span class="line">      name:&quot;刘五&quot;,</span><br><span class="line">      age:45</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure></p><p>把匹配到的<code>name:&quot;张三&quot;</code>的数据都更新成 <code>name:&quot;刘五&quot;, age:45</code><br>也可以新增没有的字段 直接写入就可以<br><strong>$set ：有这个字段就修改 没有这个字段就新增</strong></p><p>删除一个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.student.update(&#123;&quot;name&quot;:&quot;张三&quot;&#125;，&#123;$unset:&#123;</span><br><span class="line">    age:1</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure></p><p>查询<code>name:张三</code>的一条数据 然后删除它的age字段</p><p>修改多条：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.student.updateMany(&#123;&quot;sex&quot;:&quot;man&quot;&#125;,&#123;$set:&#123;</span><br><span class="line">    aihao:&quot;玩游戏&quot;</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure></p><p>把符合<code>sex:man</code>的语句都新增（修改）一条<code>aihao:&quot;玩游戏&quot;</code><br><strong>$set ：有则修改 无则新增</strong></p><p>更新多条数据方法2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.student.update(&#123;name:&quot;张三&quot;&#125;,&#123;$set:&#123;</span><br><span class="line">      name:&quot;王五&quot;</span><br><span class="line">&#125;&#125;, &#123;</span><br><span class="line">     multi:true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>参考文档：<a href="https://docs.mongodb.com/manual/tutorial/query-documents/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/query-documents/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据库基本概念&quot;&gt;&lt;a href=&quot;#数据库基本概念&quot; class=&quot;headerlink&quot; title=&quot;数据库基本概念&quot;&gt;&lt;/a&gt;数据库基本概念&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;数据库（Database）基本概念：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS文件系统（fs）与流（stream）</title>
    <link href="http://yoursite.com/2018/11/08/NodeJs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88fs%EF%BC%89%E4%B8%8E%E6%B5%81%EF%BC%88stream%EF%BC%89/"/>
    <id>http://yoursite.com/2018/11/08/NodeJs文件系统（fs）与流（stream）/</id>
    <published>2018-11-08T06:04:55.000Z</published>
    <updated>2018-12-21T08:22:45.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件系统（File-System）："><a href="#文件系统（File-System）：" class="headerlink" title="文件系统（File System）："></a><strong>文件系统（File System）：</strong></h2><ol><li>在Node中，文件系统的交互是非常重要的，服务器的本质就是将本地的文件发送给客户端，</li><li>Node通过fs模块来和文件系统进行交互，该模块提供了一些标准的文件访问API类打开、读取、写入文件、以及与其交互。</li><li>要是用fs模块，首先要从核心模块中加载； 使用 const fs= require(‘fs’) ; 来引入</li></ol><h3 id="fs使用特点："><a href="#fs使用特点：" class="headerlink" title="fs使用特点："></a>fs使用特点：</h3><ol><li>fs模块中的所有操作都有两种形式可供选择同步和异步，</li><li>同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。</li><li>异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//1\. 引入模块</span><br><span class="line">const fs= require(&quot;fs&quot;);</span><br><span class="line">// console.log(fs)</span><br><span class="line"></span><br><span class="line">//2\. 打开文件</span><br><span class="line">// fs.open 异步读取（通常用异步 需设置回调函数）  </span><br><span class="line">// fs.openSync 同步读取（读取时会阻塞线程）</span><br><span class="line"></span><br><span class="line">let hello = fs.openSync(&quot;hello.txt&quot;, &quot;w&quot;);</span><br><span class="line">//                     不存在会自动新建</span><br><span class="line"></span><br><span class="line">//3\. 写入内容</span><br><span class="line">fs.writeFileSync(hello,&apos;hello word!&apos;);</span><br><span class="line"></span><br><span class="line">//4\. 保存并退出</span><br><span class="line">fs.closeSync(hello);</span><br></pre></td></tr></table></figure><p> <a href="https://github.com/AnsonZnl/StudyNodeJS/blob/master/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AF%BE%E6%97%B630-%E8%AF%BE%E6%97%B634%E7%AC%94%E8%AE%B0.md#%E8%AF%BE%E6%97%B631" target="_blank" rel="noopener"></a></p><h3 id="文件操作："><a href="#文件操作：" class="headerlink" title="文件操作："></a>文件操作：</h3><ol><li>打开文件：<br><code>fs.open(path,flags[,mode],callback)</code><br>异步打开 异步都是回调 回调嵌套回调<br><code>fs.openSync(path,flags[,mode])</code><br>同步打开 </li></ol><p>文件标记（flags）： <a href="http://nodejs.cn/api/fs.html#fs_fs_open_path_flags_mode_callback" target="_blank" rel="noopener">http://nodejs.cn/api/fs.html#fs_fs_open_path_flags_mode_callback</a></p><p>一、同步打开文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//1\. 引入模块 </span><br><span class="line">let fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//2.打开文件 同步</span><br><span class="line">var fd=fs.openSync(&apos;1.txt&apos;, &apos;w&apos;);</span><br><span class="line"></span><br><span class="line">//3.写入内容</span><br><span class="line">fs.writeFileSync(fd,&quot;hello world!&quot;); </span><br><span class="line"></span><br><span class="line">//4\. 保存并关闭</span><br><span class="line">fs.closeSync(fd);</span><br></pre></td></tr></table></figure></p><p> 二、异步打开文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//1.引入模块</span><br><span class="line">let fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//2\. 打开文件</span><br><span class="line">fs.open(&apos;1.txt&apos;, &apos;a&apos;, (err, fd)=&gt;&#123;</span><br><span class="line">    //2.1判断是否出错</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        //正确 2.2写入文件</span><br><span class="line">        fs.writeFile(fd, &quot;今天天.....气真好！&quot;, (err)=&gt;&#123;</span><br><span class="line">             //2.2.1 写入成功</span><br><span class="line">             if(!err)&#123;</span><br><span class="line">                 console.log(&apos;写入成功&apos;);</span><br><span class="line">             &#125;else&#123;</span><br><span class="line">                 throw err;</span><br><span class="line">             &#125;</span><br><span class="line">             //2.3 关闭文件</span><br><span class="line">             fs.close(fd, (err)=&gt;&#123;</span><br><span class="line">                 if(!err)&#123;</span><br><span class="line">                     console.log(&apos;文件以保存并关闭&apos;)</span><br><span class="line">                 &#125;else&#123;</span><br><span class="line">                     throw err;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/AnsonZnl/StudyNodeJS/blob/master/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AF%BE%E6%97%B630-%E8%AF%BE%E6%97%B634%E7%AC%94%E8%AE%B0.md#%E8%AF%BE%E6%97%B632" target="_blank" rel="noopener"></a></p><h3 id="使用文件流写入"><a href="#使用文件流写入" class="headerlink" title="使用文件流写入"></a>使用文件流写入</h3><p>文件流写入： <a href="http://nodejs.cn/api/fs.html#fs_fs_createwritestream_path_options" target="_blank" rel="noopener">http://nodejs.cn/api/fs.html#fs_fs_createwritestream_path_options</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//同步操作</span><br><span class="line"></span><br><span class="line">//1\. 引入模块</span><br><span class="line">let fs= require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//2.建立通道</span><br><span class="line">let ws = fs.createWriteStream(&apos;fsw.txt&apos;)</span><br><span class="line"></span><br><span class="line">//3.打开通道</span><br><span class="line">ws.once(&apos;open&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;通道已经打开&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&apos;close&apos;, ()=&gt;&#123;</span><br><span class="line">    console.log(&apos;通道已经关闭&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//4\. 写入内容</span><br><span class="line">ws.write(&apos;我爱你，&apos;);</span><br><span class="line">ws.write(&apos;我爱你，&apos;);</span><br><span class="line">ws.write(&apos;我爱你，&apos;);</span><br></pre></td></tr></table></figure><p> <a href="https://github.com/AnsonZnl/StudyNodeJS/blob/master/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AF%BE%E6%97%B630-%E8%AF%BE%E6%97%B634%E7%AC%94%E8%AE%B0.md#%E8%AF%BE%E6%97%B633" target="_blank" rel="noopener"></a></p><h3 id="读写文件："><a href="#读写文件：" class="headerlink" title="读写文件："></a>读写文件：</h3><p>文档地址：<a href="http://nodejs.cn/api/fs.html#fs_fs_readfile_path_options_callback" target="_blank" rel="noopener">http://nodejs.cn/api/fs.html#fs_fs_readfile_path_options_callback</a><br>读取文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//1\. 引入模块</span><br><span class="line">let fs = require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//2\. 读取文件</span><br><span class="line">fs.readFile(&apos;source/hello.txt&apos;,&apos;utf8&apos;,(err,data)=&gt;&#123;</span><br><span class="line">    //判断是否成功</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(data);//</span><br><span class="line">        // console.log(data.toString());</span><br><span class="line">        //data 默认读取的是二进制 使用toString() 方法转换成</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">读取图片：</span><br><span class="line"></span><br><span class="line">//3\. 读取图片</span><br><span class="line">fs.readFile(&quot;source/psb.jpg&quot;,(err,data)=&gt;&#123;</span><br><span class="line">    //判断是否成功</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        //写入图片</span><br><span class="line">        fs.writeFile(&apos;img.jpg&apos;, data, (err)=&gt;&#123;</span><br><span class="line">            if(!err)&#123;</span><br><span class="line">                console.log(&apos;写入成功！&apos;)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                throw err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/AnsonZnl/StudyNodeJS/blob/master/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E8%AF%BE%E6%97%B630-%E8%AF%BE%E6%97%B634%E7%AC%94%E8%AE%B0.md#%E8%AF%BE%E6%97%B634" target="_blank" rel="noopener"></a></p><p><strong>读取视频:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//1\. 引入模块</span><br><span class="line">let fs= require(&apos;fs&apos;);</span><br><span class="line"></span><br><span class="line">//2\. 读取视频</span><br><span class="line">fs.readFile(&apos;source/cddbb.mp4&apos;, (err, data)=&gt;&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        // 写入视频</span><br><span class="line">        fs.writeFile(&apos;nmx.mp4&apos;, data, (err)=&gt;&#123;</span><br><span class="line">            if(!err)&#123;</span><br><span class="line">                console.log(&apos;写入成功！&apos;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                throw err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//3\. 流式文件的读入（批量文件处理）</span><br><span class="line">let re= fs.createReadStream(&apos;source/cddbb.mp4&apos;);</span><br><span class="line">//建立读取流</span><br><span class="line">let ws= fs.createWriteStream(&apos;新建的视频.mp4&apos;);</span><br><span class="line">//建立写入流</span><br><span class="line"></span><br><span class="line">//4\. 创建管道</span><br><span class="line">re.pipe(ws);//文件流传输</span><br><span class="line">console.log(&apos;文件流传输完成&apos;)</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.jb51.net/article/133553.htm" target="_blank" rel="noopener">详解NodeJS文件系统fs</a><br>我的GitHub总结的<a href="https://github.com/AnsonZnl/StudyNodeJS" target="_blank" rel="noopener">NodeJS笔记</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文件系统（File-System）：&quot;&gt;&lt;a href=&quot;#文件系统（File-System）：&quot; class=&quot;headerlink&quot; title=&quot;文件系统（File System）：&quot;&gt;&lt;/a&gt;&lt;strong&gt;文件系统（File System）：&lt;/stro
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS中的Buffer</title>
    <link href="http://yoursite.com/2018/11/05/Node%E4%B8%AD%E7%9A%84Buffer/"/>
    <id>http://yoursite.com/2018/11/05/Node中的Buffer/</id>
    <published>2018-11-05T06:04:55.000Z</published>
    <updated>2018-12-21T08:22:49.824Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Buffer介绍"><a href="#Buffer介绍" class="headerlink" title="Buffer介绍"></a>Buffer介绍</h3><p><strong>为什么要用Buffer？</strong></p><ol><li>在Node/ES6 出现之前，前端工程师只需要进行一些简单的额字符串或者ODM操作就可以满足业务需求了，所有对二进制数据比较陌生。</li><li>在node出现之后，前端工程师面对的技术场景发送了变化，可以深入到网络传输、文件操作、图片处理等领域。而这些操作与二进制数据紧密相关。</li><li>在Node中的Buffer，是一个二进制数据容器，数据结构和数组类似，专门用于Node中的数据放。</li></ol><h3 id="新建Buffer"><a href="#新建Buffer" class="headerlink" title="新建Buffer"></a>新建Buffer</h3><p><code>Buffer.alloc(size[, fil[,encoding]])</code><br><code>size</code>:新建的buffer期望的长度<br><code>fill</code>用来预填充新建的Buffer的值 默认0<br><code>encoding</code>: 编码格式  默认：utf-8<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">        十六进制：00- ff</span><br><span class="line">        十进制 ：0- 255</span><br><span class="line">        二进制： 00000000- 11111111</span><br><span class="line">        0 / 1 代表一位 == 比特 </span><br><span class="line">        8bit = 1B</span><br><span class="line">        1kb = 1024 B</span><br><span class="line">        1mkb= 1024Kb</span><br><span class="line">        1GB = 1024m</span><br><span class="line">        1TB = 1024GB</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 2. Buffer.alloc(size[, fill[, encoding]])</span><br><span class="line">/*</span><br><span class="line">类数组使用即可 可遍历 可选择下标等等</span><br><span class="line">初始化： 确定的长度 不能改变</span><br><span class="line">填充值</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">let buffer2= Buffer.alloc(10);//创建了一个长度是10的buffer</span><br><span class="line">buffer2[0]= 10;//可以像使用数组一样使用buffer </span><br><span class="line">buffer2[1]= oxfc;//传一个十六进制的直接取后两位 fc</span><br><span class="line">buffer2[30]= 1;//这点和数组不同 溢出隐藏 </span><br><span class="line">console.log(buffer2);</span><br></pre></td></tr></table></figure></p><h3 id="Buffer使用"><a href="#Buffer使用" class="headerlink" title="Buffer使用"></a>Buffer使用</h3><p><strong>使用新方法使用Buffer </strong></p><ol><li>Buffer.form(str):将一个字符串转换成buffer</li><li>Buffer.alloc(size):创建一个指定大小的buffer</li><li>Buffer.alloUnsafe(size):创建一个指定大小的buffer，但是可能包含敏感数据。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 历史方法</span><br><span class="line">// let buffer = new Buffer(10);//类似 Array(10) 创建十个空间</span><br><span class="line">// console.log(buffer)// &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;</span><br><span class="line"></span><br><span class="line">//1. 字符串转成二进制</span><br><span class="line">let str= &apos;www.zhangningle.top&apos;;</span><br><span class="line">let buffer= Buffer.from(str);</span><br><span class="line">console.log(buffer);//&lt;Buffer 77 77 77 2e 7a 68 61 6e 67 6e 69 6e 67 6c 65 2e 74 6f 70&gt;</span><br><span class="line">//把buffer转成十进制的</span><br><span class="line">console.log(buffer.toString())//www.zhangningle.top</span><br><span class="line">// 汉字转换成二进制后 一个汉字要用三个字节表示</span><br></pre></td></tr></table></figure></li></ol><p><strong>Buffer总结点：</strong></p><ol><li>Buffer的结构和数组很像，操作方法也和数组很类似。</li><li>Buffer中是以二进制的方式储存数据的</li><li>Buffer是Node自带的，不需要引入，直接可以使用。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Buffer介绍&quot;&gt;&lt;a href=&quot;#Buffer介绍&quot; class=&quot;headerlink&quot; title=&quot;Buffer介绍&quot;&gt;&lt;/a&gt;Buffer介绍&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;为什么要用Buffer？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在No
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS中的CommonJS规范</title>
    <link href="http://yoursite.com/2018/10/18/CommonJS%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/10/18/CommonJS模块化开发/</id>
    <published>2018-10-18T06:04:55.000Z</published>
    <updated>2018-12-21T08:24:19.287Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模块化的意义"><a href="#模块化的意义" class="headerlink" title="模块化的意义"></a>模块化的意义</h3><blockquote><p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。<br>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Node环境中，一个.js文件就称之为一个模块（module）。</p></blockquote><h3 id="理解模块化"><a href="#理解模块化" class="headerlink" title="理解模块化"></a>理解模块化</h3><p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。<br>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</p><p><strong>每一个文件都可以看成一个模块，模块都可以相互暴露和相互引用</strong><br>1.在Node中 一个文件就是一个模块<br>2.在Node中，通过require()函数来引入外部的模块，引入外部模块要加上 ./ 或者 ../<br>3.在Node中，每一个js文件中js代码都是独立运行在一个小闭包中，而不是全局作用域，所以一个模块在不引用的情况下它的的变量和函数都在其他模块中无法访问，如果引用到其他模块中，则被引用的文件相当与在一个闭包内，相当与局部变量。<br>目的：全局变量私有化，避免全局污染。<br>4.暴露模块中的变量和函数：使用exports<br>只需要将需要暴露给外部的变量或者方法设置为exports的属性就行，<br><strong>可以把exports看做一个全局对象，把所有暴露出来的函数和变量都存放在里面</strong><br>Node有一些自带的模块，成为核心模块，他的引用不需要加./ 或者../ 如fs http</p><p><img src="https://upload-images.jianshu.io/upload_images/7072486-0d6620b0e8d69fa6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="171539764614_.pic.jpg"></p><p>引用：<code>const  moudel = require (&#39;./02.js&#39;)</code><br>暴露：<code>exports.str = srt;</code></p><h3 id="CommonJS案例"><a href="#CommonJS案例" class="headerlink" title="CommonJS案例"></a>CommonJS案例</h3><p>先写一个01.js暴露出去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let str = &quot;我是小二&quot;;</span><br><span class="line"></span><br><span class="line">let test = ()=&gt;&#123;</span><br><span class="line">  console.log(&quot;今天天气很好!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">exports.str = str;</span><br><span class="line">exports.test = test;</span><br></pre></td></tr></table></figure></p><p>在写一个02.js把暴露的01.js引用过来, 然后暴露自身<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const module02 = require(&apos;./01.js&apos;);// [ ./  ../ ]</span><br><span class="line"></span><br><span class="line">exports.module02 = module02; //暴露</span><br><span class="line"></span><br><span class="line">console.log(module02.str);//我是小二</span><br></pre></td></tr></table></figure></p><p>最后在写一个03.js 引用暴露的02.js， 这样在03.js 里就包含了 02.js 和01.js了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const module03 = require(&apos;./02.js&apos;);</span><br><span class="line">console.log(module03.module02.str)//我是小二</span><br></pre></td></tr></table></figure></p><p>所以最后是这样的：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-d7e8e14a1da2526b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="161539764109_.pic.jpg" title="">                </div>                <div class="image-caption">161539764109_.pic.jpg</div>            </figure></p><p>类似一个同心圆</p><h3 id="案例：写一个求和-求平均数的模块"><a href="#案例：写一个求和-求平均数的模块" class="headerlink" title="案例：写一个求和 / 求平均数的模块"></a>案例：写一个求和 / 求平均数的模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">exports.sun = (...numbers)=&gt;&#123;</span><br><span class="line">    let result = 0;</span><br><span class="line">    numbers.forEach((itme)=&gt;&#123;</span><br><span class="line">        result += itme;</span><br><span class="line">    &#125;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.avg= (...numbers)=&gt;&#123;</span><br><span class="line">    let result = 0;</span><br><span class="line">    numbers.forEach((itme)=&gt;&#123;</span><br><span class="line">        result+= itme;</span><br><span class="line">    &#125;);</span><br><span class="line">    return result / numbers.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434502419592fd80bbb0613a42118ccab9435af408fd000" target="_blank" rel="noopener">廖雪峰的官网-模块开发</a><br>视频资料：<a href="https://study.163.com/course/courseLearn.htm?courseId=1005269026#/learn/video?lessonId=1052250610&amp;courseId=1005269026" target="_blank" rel="noopener">网易云课堂-叶建秋-从零玩转Node.js</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;模块化的意义&quot;&gt;&lt;a href=&quot;#模块化的意义&quot; class=&quot;headerlink&quot; title=&quot;模块化的意义&quot;&gt;&lt;/a&gt;模块化的意义&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来
      
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
</feed>
