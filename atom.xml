<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张宁乐的博客</title>
  
  <subtitle>种一棵树最好的时间在十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-17T07:13:41.848Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>张宁乐</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue 知识点总结</title>
    <link href="http://yoursite.com/2018/09/17/Vue%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/09/17/Vue知识点总结/</id>
    <published>2018-09-17T06:04:54.000Z</published>
    <updated>2018-09-17T07:13:41.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h3><ul><li>vue的生命周期： <code>beforeCreate/created</code>、<code>beforeMount/mounted</code>、<code>beforeUpdate/updated</code>、<code>beforeDestory/destoryed</code></li><li>vue常用指令： <code>v-for</code>、<code>v-bind</code>（缩写形式<code>:prop</code>）、<code>v-on</code>(缩写形式<code>@click=’sss&#39;</code>)、<code>v-if/v-else/v-else-if</code>、<code>v-model</code>、<code>v-once</code>、<code>v-html</code>、<code>v-show</code>…</li><li>vue自定义组件：<code>Vue.component(‘componentName&#39;,{ props:[‘p1’,’p2’], template: ‘&lt;li&gt;&lt;/li&gt;&#39; })</code></li><li>vue常用实例方法和属性: <code>data/$data</code>、<code>methods/$methods</code>、<code>$el</code>、<code>computed</code>(计算属性)、<code>$watch</code>、<code>$set</code>、<code>$event</code>、<code>$emit</code>…</li><li>如果需要更新的属性需要缓存，则使用计算属性的方式，否则可以使用<code>methods</code>里的方法来更新属性（<code>methods</code>里的方法每次重新渲染都会执行）</li><li>计算属性默认提供了<code>getter</code>，你还可以给它设置<code>setter</code></li><li>当你数据变化是异步或者开销较大时，可以使用<code>watch</code>侦听器来响应数据的变化</li><li><code>v-bind:class</code>的值可以是一个对象，可实现类似<code>react</code>中<code>classnames</code>模块的功能</li><li>自定义组件上的<code>class</code>会被渲染拼接到<code>template</code>的根节点的<code>class</code>属性上（自定义组件上可使用<code>v-bind:class</code>来做class的判断显示逻辑）</li><li><code>v-bind:style</code>可以用来绑定内联样式，这个内联样式的值可以由一个对象来定义（类似css in js的模式）,且可以被定义为数组(多个样式对象)</li><li><code>v-bind:style</code>可以使用多重值的形式：<code>&lt;div :style=“display:[‘-webkit-box’,’-ms-flexbox’, ‘flex&#39;]&quot;&gt;&lt;/div&gt;</code></li><li><code>v-if/v-else/v-else-if</code>的时候，可以用key来管理可复用的元素</li><li><code>v-if</code>是’真正’的渲染，它会确保在切换条件过程中条件块内的元素的事件监听器和子组件适时的销毁和重建</li><li><code>v-if</code>是惰性的，初始为假，什么也不做，直到为真的时候才渲染元素</li><li><code>v-show</code>总是渲染元素，只是简单的进行切换</li><li><code>v-if</code>的切换开销大，<code>v-show</code>则是初始渲染开销大，频繁切换使用<code>v-show</code>，运行时经常改变则使用<code>v-if</code></li><li><code>v-if</code>和<code>v-for</code>一起使用时，<code>v-for</code>的优先级更高</li><li><code>v-for</code>可遍历数组，第二个参数是索引</li><li><code>v-for</code>可遍历对象，第二个参数是<code>key</code>，第三个参数是索引</li><li><code>v-for</code>和<code>&lt;template&gt;</code>搭配可减少渲染次数</li><li><code>v-for</code>和自定义组件使用时，需要使用<code>props</code>来传递值</li><li>尽可能的为遍历子元素加上<code>key</code>，获得渲染优化</li><li>数组变异方法：<code>push/pop/unshift/shift/splice/sort/reverse</code>改变原始数组</li><li>数组非变异方法：<code>filter/concat/slice</code> 不改变原始数组，总是返回新数组</li><li>Vue不能检测到数组索引赋值（使用<code>vm.$set</code>解决）和修改<code>length</code>长度赋值(使用<code>splice</code>解决)的情况</li><li>Vue不能检测对象属性的添加和删除(使用<code>vm.$set</code>或<code>Object.assign</code>)</li><li><code>is=“todo-item”</code>这种属性的写法比较适合DOM模板</li><li>事件修饰符，它们可串联使用：<code>.stop</code>、<code>.prevent</code>、<code>.capture</code>、<code>.self</code>、<code>.once</code>、<code>.passive</code>(尤其适合移动端)</li><li><code>.passive</code>不用同时和<code>.prevent</code>使用，后者会被忽略</li><li>按键修饰符: <code>.enter</code>、<code>.tab</code>、<code>.delete</code>、<code>.esc</code>、<code>.space</code>、<code>.up</code>、<code>.down</code>、<code>.left</code>、<code>.right</code></li><li>系统按键修饰符:<code>.ctrl</code>、<code>.alt</code>、<code>.shift</code>、<code>.meta(⌘|⊞|◆)</code>、<code>.exact</code>(允许精确控制系统修饰符组合键触发)</li><li>鼠标修饰符： <code>.left</code>、<code>.right</code>、<code>.middle</code></li><li><code>v-model</code>会忽略表单元素的<code>value</code>、<code>checked</code>、<code>selected</code>，仅仅使用实例中的数据作为数据源</li><li>表单事件修饰符：<code>.lazy</code>、<code>.number</code>、<code>.trim</code></li><li>组件是可复用的vue实例，具有vue实例大多数属性和方法</li><li>组件可复用，每个组件有独立的空间</li><li>组件上的data必须是一个函数，这样做避免影响了其他组件</li><li>通过<code>Vue.component()</code>全局注册的组件可在其被注册后的任何通过<code>new Vue()</code>创建的实例所使用，包含其组件树中的所有组件</li><li>通过插槽<code>&lt;slot&gt;</code>分发内容(其实就是类似于react的children)</li><li>动态组件<code>&lt;component&gt;</code>配合属性<code>is</code>来实现</li><li>解析DOM模板时需要注意下可能会有不生效的情况，需要使用is来传递组件</li></ul><h3 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h3><ul><li>全局注册/局部注册</li><li>局部注册组件在子组件中不可用</li><li>全局注册的行为必须在根Vue实例创建之前发生</li><li><code>camelCase</code>的属性可以在组件中使用<code>kebab-case</code></li><li>可以以对象的模式指定每一个<code>props</code>属性的类型</li><li>父级<code>props</code>的更新会向下流动，反之则不行</li><li>由于JavaScript对象和数组是引用传入的，所以当子组件对props的改变将会影响到父组件</li><li>props类型校验可以是原生构造对象的中的任意一个，也可以自定义检验类型，通过<code>instanceof</code>检查</li><li>对于绝大多数特性来说，外部传入的值会替换掉组件内部设置好的值，如input的type属性，但有的属性则是会进行合并，如class</li><li><code>inhertAttrs:false</code>设置不希望根元素继承特性，可以使用<code>$attrs</code>属性来设置继承的目标元素</li><li><code>v-on</code>在设置事件监听器时，会把事件名全部转换成小写，推荐始终使用<code>kebab-case</code>的事件名</li><li><code>v-model</code>可以使用自定义组件中的<code>model</code>属性自定义</li><li>父组件模板的所有东西都会在父级作用域内编译，子组件的所有内容都会在子组件作用域内编译</li><li>插槽(<code>&lt;slot&gt;&lt;/slot&gt;</code>)/具名插槽(<code>&lt;slot name=“header&quot;&gt;&lt;/slot&gt;</code>)/作用域插槽(<code>slot/slot-scope</code>)</li><li><code>&lt;keep-alive&gt;</code>组件可用来缓存被切换后隐藏的组件的状态</li><li><code>$root</code>访问根实例，<code>$parent</code>访问父组件实例(不推荐)</li><li>父组件访问子组件，使用<code>$refs</code>属性来获取设置了<code>ref</code>属性的子组件</li><li><code>provide</code>属性允许我们指定要分享给后代组件使用的方法，然后后代组件使用<code>inject</code>属性来获得祖先组件分享的方法(依赖注入)</li><li><p>事件侦听器（<code>$emit</code>派发的事件）</p><ul><li><code>v-on</code> 指令侦听</li><li><code>$on</code> 侦听一个事件</li><li><code>$once</code> 一次性侦听一个事件</li><li><code>$off</code> 停止侦听一个事件</li></ul></li><li>慎用递归组件</li><li>尽量避免组件的循环引用</li><li>优先使用<code>template</code>来定义模板，而不是<code>inline-template</code></li><li><code>$forceUpdate</code>来强制更新view</li><li>组件包含大量静态内容时，可使用<code>v-once</code>来标记，缓存静态内容</li></ul><h3 id="过渡-amp-动画"><a href="#过渡-amp-动画" class="headerlink" title="过渡 &amp; 动画"></a>过渡 &amp; 动画</h3><ul><li><code>transition</code>组件控制过渡动画，可以给任何元素和组件添加进入/离开过渡</li><li><p>当插入或删除<code>transition</code>中的元素时，vue会做如下处理</p><ul><li>自动嗅探元素是否使用了css过渡和动画，适当时机添加/删除类名</li><li>元素的钩子函数会在适当时机被调用</li><li>元素既没有钩子函数也没有css动画，插入和删除操作在下一帧立即执行（浏览器逐帧动画机制）</li></ul></li><li><p>过渡的类名</p><ul><li><code>v-enter/v-enter-active/v-enter-to</code></li><li><code>v-leave/v-leave-active/v-leave-to</code></li></ul></li><li>css动画用法同css过渡，区别是类名<code>v-enter</code>不会在DOM插入后立即删除，而是在<code>animationend</code>事件触发时删除</li><li><p>自定义过渡类名，使用以下属性指定:</p><ul><li><code>enter-class/enter-active-class/enter-to-class</code></li><li><code>leave-class/leave-active-class/leave-to-class</code></li><li>自定义类名优先级高于普通的类名</li></ul></li><li>使用<code>typ</code>e属性设置<code>transition</code>或<code>animation</code>来申明vue使用的动画类型</li><li><code>transition</code>组件上使用<code>duration</code>来设置动画执行的时间</li><li><p>可以使用钩子函数</p><ul><li><code>beforeEnter/enter/afterEnter/enterCancelled</code></li><li><code>beforeLeave/leave/afterLeave/leaveCancelled</code></li><li>钩子函数使用<code>v-on</code>指令绑定</li><li>钩子和结合过渡和动画使用，也可以单独使用</li><li>在<code>enter/leave</code>中，必须使用<code>done()</code>来进行回调，否则会同步调用，过渡或动画会立即完成</li><li>对于纯使用JavaScript来进行的动画，推荐使用<code>v-bind:css=“false”</code>来取消css的检测，减少css的影响</li></ul></li><li><p>可使用<code>apear</code>设置初始渲染的过渡</p><ul><li><code>apear/apear-active/apear-to</code></li><li><code>beforeApear/apear/afterApear/apearCancelled</code></li></ul></li><li>多元素过渡，设置唯一<code>key</code></li><li><p>过渡模式:</p><ul><li><code>In-out</code> 新元素先过渡，完成后当前元素过渡离开</li><li><code>out-in</code> 当前元素先过渡，完成后新元素过渡进入</li><li><code>默认行为</code>：进入和离开同时发生</li></ul></li><li>多个组件过渡使用动态组件实现</li><li><p>列表过渡 <code>&lt;transition-group&gt;</code></p><ul><li>以真实元素呈现，默认为<code>&lt;span&gt;</code>，可使用tag更改呈现标签</li><li>过渡模式不可用</li><li>内部需要唯一<code>key</code></li></ul></li><li>列表排序过渡，使用的是<code>FLIP</code>动画，使用类名<code>v-move</code>来定义class</li></ul><h3 id="可复用性-amp-组合"><a href="#可复用性-amp-组合" class="headerlink" title="可复用性 &amp; 组合"></a>可复用性 &amp; 组合</h3><ul><li><code>mixins</code>混入属性发生冲突时，以组件数据优先（一层属性深度浅合并）</li><li><code>mixins</code>混入方法发生冲突时，会将函数合并为一个数组，优先执行混入方法，其次执行组件方法</li><li><code>Vue.extend</code>策略和<code>mixins</code>相同</li><li>慎用全局混入</li><li>合并策略可以自定义（参考<code>vuex</code>的具体实现：<code>Vue.config.optionMergeStrategies</code>）</li><li>全局自定义指令：<code>Vue.directive()</code></li><li>局部自定义指令：属性<code>directives</code>，类型为<code>Object</code></li><li><p>钩子函数</p><ul><li><strong>bind</strong> 指令第一次绑定到元素时调用，只执行一次，可用于一次性初始化设置</li><li><strong>inserted</strong> 元素插入父节点时调用</li><li><strong>update</strong> 所有VNode更新时调用，可能发生在子<em>VNode</em>之前</li><li><strong>componentUpdated</strong> 指令所在组件在<em>VNode</em>和其子<em>VNode</em>更新后调用</li><li><strong>unbind</strong> 指令与元素解绑时调用</li></ul></li><li><p>钩子函数都会被传入以下参数：</p><ul><li><strong>el</strong> 指令绑定元素，可操作DOM</li><li><strong>binding</strong> 指令描述对象</li><li><strong>vnode</strong> Vue生成的虚拟节点</li><li><strong>oldVnode</strong> 上一个<code>Vnode</code>，仅在<code>update</code>和<code>componentUpdated</code>中使用</li></ul></li><li>指令接受所有合法的JavaScript表达式</li></ul><h3 id="渲染函数-amp-JSX"><a href="#渲染函数-amp-JSX" class="headerlink" title="渲染函数 &amp; JSX"></a>渲染函数 &amp; JSX</h3><ul><li><code>render</code>函数接受<code>createElement</code>方法作为参数</li><li><code>createElement</code>方法的作用是创建一个虚拟节点(VNode)</li><li><code>createElement</code>参数比较复杂，参照官网：参数</li><li>组件树中的<code>VNodes</code>必须唯一</li><li>render中的<code>v-if/v-for</code>可以使用<code>if/else</code>和<code>map</code>重写</li><li>插槽使用<code>this.$slot.default</code>访问，作用域插槽使用<code>this.$scopeSlots.default</code>访问和设置</li><li>可以使用插件<code>babel-plugin-transform-vue-jsx</code>支持JSX语法</li><li>将h作为<code>createElement</code>的别名是Vue生态的一个惯例，也是JSX要求的</li><li>函数式组件 关键词：functional</li><li>函数式组件渲染开销低，但相应的，它不会出现在Vue devtools的组件树里边</li><li>函数式组件要求你自己实现同名特性的替换与智能合并</li><li>Vue的模板实际编译成了<code>render</code>方法实现的<code>VNode</code>，可以使用<code>Vue.compile()</code>方法来输出编译结果</li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul><li><p>插件会为vue提供全局的功能，包括但不限于以下几种：</p><ul><li>添加全局的属性或方法，如<a href="https://github.com/karol-f/vue-custom-element" target="_blank" rel="noopener">vue-custom-element</a></li><li>添加全局的资源（指令、过滤器、过渡等），如：<a href="https://github.com/vuejs/vue-touch" target="_blank" rel="noopener">vue-touch</a></li><li>通过全局<code>mixins</code>添加一些组件选项，如：<a href="https://github.com/vuejs/vue-touch" target="_blank" rel="noopener">vue-router</a></li><li>添加Vue实例方法，通过添加到<code>Vue.prototype</code>上实现</li><li>一个独立的库，同时有自己的API，又实现以上部分功能，如：<a href="https://github.com/vuejs/vue-touch" target="_blank" rel="noopener">vue-router</a></li></ul></li><li>Vue插件有一个公开的方法<code>install</code>，第一个参数是Vue构造器，第二个参数是一个可选对象。</li><li>插件的使用通过全局方法<code>Vue.use(MyPlugin)</code>使用，只会注册一次插件</li><li>在CommonJS中，应该始终显式的调用<code>Vue.use</code>方法</li><li>社区插件列表<a href="https://github.com/vuejs/awesome-vue#components--libraries" target="_blank" rel="noopener">awesome-vue</a></li></ul><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; msg | filter &#125;&#125;</span><br><span class="line">&lt;div v-bind=“msg | filter&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>全局过滤器使用Vue.filter()创建</li><li>局部过滤器使用对象属性filters创建</li><li>过滤器函数总是接收表达式的值作为第一个参数，过滤器可以有多个，值依次向后传递</li><li>过滤器可以接收额外的参数</li></ul><h3 id="构建-amp-部署"><a href="#构建-amp-部署" class="headerlink" title="构建 &amp; 部署"></a>构建 &amp; 部署</h3><ul><li><code>&lt;script&gt;</code>标签引入<code>[vue.min.js](https://vuejs.org/js/vue.min.js)</code></li><li><p>使用<code>vue-cli</code></p><ul><li>webpack + vue-loader</li><li>browserify + vueify</li><li>rollup + rollup-plugin-vue</li></ul></li><li>利用钩子函数<code>Vue.config.errorHandler</code>定义配置来跟踪运行时错误，可以搭配<code>[Sentry](https://sentry.io/)</code>使用（<a href="https://sentry.io/for/vue/" target="_blank" rel="noopener">集成配置</a>）</li><li>单文件组件（<code>.vue</code>文件）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础知识：&quot;&gt;&lt;a href=&quot;#基础知识：&quot; class=&quot;headerlink&quot; title=&quot;基础知识：&quot;&gt;&lt;/a&gt;基础知识：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;vue的生命周期： &lt;code&gt;beforeCreate/created&lt;/code&gt;、&lt;code&gt;be
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Array的push与unshift方法性能比较分析</title>
    <link href="http://yoursite.com/2018/09/01/Array%E7%9A%84push%E4%B8%8Eunshift%E6%96%B9%E6%B3%95%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/09/01/Array的push与unshift方法性能比较分析/</id>
    <published>2018-09-01T12:45:23.000Z</published>
    <updated>2018-09-01T11:58:10.805Z</updated>
    
    <content type="html"><![CDATA[<p>从原理就可以知道，unshift的效率是较低的。原因是，它每添加一个元素，都要把现有元素往下移一个位置。但到底效率差异有多大呢？下面来测试一下。<br>测试环境的主要硬件：CPU T7100（1.8G）；内存4G DDR2 667；硬盘5400转。主要软件：操作系统为Windows 7；浏览器为Firefox 3.6.9。测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ ], s = +new Date; </span><br><span class="line">// push性能测试 </span><br><span class="line">for (var i = 0; i &lt; 50000; i++) &#123; </span><br><span class="line">　　arr.push(i); </span><br><span class="line">&#125; </span><br><span class="line">console.log(+new Date - s); </span><br><span class="line">s = +new Date; </span><br><span class="line">arr = [ ]; </span><br><span class="line">// unshift性能测试 </span><br><span class="line">for (var i = 0; i &lt; 50000; i++) &#123; </span><br><span class="line">　　arr.unshift(i); </span><br><span class="line">&#125; </span><br><span class="line">console.log(+new Date - s);</span><br></pre></td></tr></table></figure></p><p>这段代码分别执行了50000次push和unshift操作，运行一次以后，得出结果：<br>12<br>1152<br>可见，unshift比push要慢差不多100倍！因此，平时还是要慎用unshift，特别是对大数组。那如果一定要达到unshift的效果，有没有其他方法呢？答案是肯定的。<br>Array有一个叫做reverse的方法，能够把一个数组反转。先把要放进数组的元素用push添加，再执行一次reverse，就达到了unshift的效果。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 50000; i++) &#123; </span><br><span class="line">　　arr.push(i); </span><br><span class="line">&#125; </span><br><span class="line">arr.reverse(); </span><br><span class="line"></span><br><span class="line">//reverse的性能又如何呢，下面再来测试：</span><br><span class="line">var arr = [ ], s = +new Date; </span><br><span class="line">for (var i = 0; i &lt; 50000; i++) &#123; </span><br><span class="line">　　arr.push(i); </span><br><span class="line">&#125; </span><br><span class="line">arr.reverse(); </span><br><span class="line">console.log(+new Date - s);</span><br></pre></td></tr></table></figure></p><p>结果是：<br>12<br>可见，reverse性能极高，甚至于没有额外的消耗，可以放心使用。</p><p>当你的才华撑不起你的野心的时候、请潜下心、低下头、好好学习、</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从原理就可以知道，unshift的效率是较低的。原因是，它每添加一个元素，都要把现有元素往下移一个位置。但到底效率差异有多大呢？下面来测试一下。&lt;br&gt;测试环境的主要硬件：CPU T7100（1.8G）；内存4G DDR2 667；硬盘5400转。主要软件：操作系统为Win
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>给程序员的一点建议</title>
    <link href="http://yoursite.com/2018/08/21/%E7%BB%99%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B8%80%E7%82%B9%E5%BB%BA%E8%AE%AE/"/>
    <id>http://yoursite.com/2018/08/21/给程序员的一点建议/</id>
    <published>2018-08-21T12:45:23.000Z</published>
    <updated>2018-09-02T11:51:27.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何正确使用时间"><a href="#如何正确使用时间" class="headerlink" title="如何正确使用时间"></a>如何正确使用时间</h1><p>你是否时常会焦虑时间过的很快，没时间学习，本文将会分享一些个人的见解。</p><h2 id="花时间补基础，读文档"><a href="#花时间补基础，读文档" class="headerlink" title="花时间补基础，读文档"></a>花时间补基础，读文档</h2><p>在工作中我们时常会花很多时间去 debug，但是你是否发现很多问题最终只是你基础不扎实或者文档没有仔细看。</p><p>基础是你技术的基石，一定要花时间打好基础，而不是追各种新的技术。一旦你的基础扎实，学习各种新的技术也肯定不在话下，因为新的技术，究其根本都是相通的。</p><p>文档同样也是一门技术的基础。一个优秀的库，开发人员肯定已经把如何使用这个库都写在文档中了，仔细阅读文档一定会是少写 bug 的最省事路子。</p><h2 id="学会搜索"><a href="#学会搜索" class="headerlink" title="学会搜索"></a>学会搜索</h2><p>如果你还在使用百度搜索编程问题，请尽快抛弃这个垃圾搜索引擎。同样一个关键字，使用百度和谷歌，谷歌基本完胜的。即使你使用中文在谷歌中搜索，得到的结果也往往是谷歌占优，所以如果你想迅速的通过搜索引擎来解决问题，那一定是谷歌。</p><h2 id="学点英语"><a href="#学点英语" class="headerlink" title="学点英语"></a>学点英语</h2><p>说到英语，一定是大家所最不想听的。其实我一直认为程序员学习英语是简单的，因为我们工作中是一直接触着英语，并且看懂技术文章，文档所需要的单词量是极少的。我时常在群里看到大家发出一个问题的截图问什么原因，其实在截图中英语已经很明白的说明了问题的所在，如果你的英语过关，完全不需要浪费时间来提问和搜索。所以我认为学点英语也是节省时间中很重要的一点。</p><p>那么如何去学习呢，chrome 装个翻译插件，直接拿英文文档或文章读，不会的就直接划词翻译，然后记录下这个单词并背诵。每天花半小时看点英文文档和文章，坚持两个月，你的英语水平不说别的，看文档和文章绝对不会有难题了。这一定是一个很划算的个人时间投资，花点时间学习英语，能为你将来的技术之路铺平很多坎。</p><h2 id="画个图，想一想再做"><a href="#画个图，想一想再做" class="headerlink" title="画个图，想一想再做"></a>画个图，想一想再做</h2><p>你是否遇到过这种问题，需求一下来，看一眼，然后马上就按照设计稿开始做了，可能中间出个问题导致你需要返工。</p><p>如果你存在这样的问题，我很推荐在看到设计稿和需求的时候花点时间想一想，画一画。考虑一下设计稿中是否可以找到可以拆分出来的复用组件，是否存在之前写过的组件。该如何组织这个界面，数据的流转是怎么样的。然后画一下这个页面的需求，最后再动手做。</p><h2 id="利用好下班时间学习"><a href="#利用好下班时间学习" class="headerlink" title="利用好下班时间学习"></a>利用好下班时间学习</h2><p>说到下班时间，那可能就有人说了公司很迟下班，这其实是国内很普遍的情况。但是我认为正常的加班是可以的，但是强制的加班就是在损耗你的身体和前途。</p><p>可以这么说，大部分的 996 公司，加班的这些时间并不会增加你的技术，无非就是在写一些重复的业务逻辑。也许你可以拿到更多的钱，但是代价是身体还有前途。程序员是靠技术吃饭的，如果你长久呆在一个长时间加班的公司，不能增长你的技术还要吞噬你的下班学习时间，那么你一定会废掉的。如果你遇到了这种情况，只能推荐尽快跳槽到非 996 的公司。</p><p>那么如果你有足够的下班时间，一定要花上 1， 2 小时去学习，上班大家基本都一样，技术的精进就是看下班以后的那几个小时了。如果你能利用好下班时间来学习，坚持下去，时间一定会给你很好的答复。</p><h2 id="列好-ToDo"><a href="#列好-ToDo" class="headerlink" title="列好 ToDo"></a>列好 ToDo</h2><p>我喜欢规划好一段时间内要做的事情，并且要把事情拆分为小点。给 ToDo 列好优先级，紧急的优先级最高。相同优先级的我喜欢先做简单的，因为这样一旦完成就能划掉一个，提高成就感。</p><h2 id="反思和整理"><a href="#反思和整理" class="headerlink" title="反思和整理"></a>反思和整理</h2><p>每周末都会花上点时间整理下本周记录的笔记和看到的不错文章。然后考虑下本周完成的工作和下周准备要完成的工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何正确使用时间&quot;&gt;&lt;a href=&quot;#如何正确使用时间&quot; class=&quot;headerlink&quot; title=&quot;如何正确使用时间&quot;&gt;&lt;/a&gt;如何正确使用时间&lt;/h1&gt;&lt;p&gt;你是否时常会焦虑时间过的很快，没时间学习，本文将会分享一些个人的见解。&lt;/p&gt;
&lt;h2 id
      
    
    </summary>
    
    
      <category term="个人发展" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>webpack4快速入门</title>
    <link href="http://yoursite.com/2018/08/11/Webpack%204%20%E5%92%8C%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E5%85%A5%E9%97%A8%EF%BC%88%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8webpack4%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%8C%E7%9C%8B%E6%87%82%E4%BA%86%E4%BD%A0%E5%B0%B1%E5%85%A5%E9%97%A8%E4%BA%86%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/11/Webpack 4 和单页应用入门（史上最全webpack4入门教程，看懂了你就入门了）/</id>
    <published>2018-08-11T12:45:23.000Z</published>
    <updated>2018-08-11T15:52:55.082Z</updated>
    
    <content type="html"><![CDATA[<p><strong>可以说是我目前看到最详细的 webpack 4 入门文章。<br>基本看完这个，基本也算一个合格的初级webpack配置工程师了。</strong></p><blockquote><p>webpack 更新到了 4.0，官网还没有更新文档。因此把教程更新一下，方便大家用起 webpack 4。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-30b8f96f6314cf58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="webpack" title="">                </div>                <div class="image-caption">webpack</div>            </figure> <h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#写在开头" target="_blank" rel="noopener"></a>写在开头</h2><p><del>先说说为什么要写这篇文章，最初的原因是组里的小朋友们看了 <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> 文档后，表情都是这样的：摘自 webpack 一篇文档的评论区）</del></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-7cc744905b9edb5e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wtf" title="">                </div>                <div class="image-caption">wtf</div>            </figure> <p><del>是的，即使是外国佬也在吐槽这文档不是人能看的。回想起当年自己啃 webpack 文档的血与泪的往事，觉得有必要整一个教程，可以让大家看完后愉悦地搭建起一个 webpack 打包方案的项目。</del></p><p>官网新的 <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> 文档现在写的很详细了，能看英文的小伙伴可以直接去看官网。</p><p>可能会有人问 webpack 到底有什么用，你不能上来就糊我一脸代码让我马上搞，我照着搞了一遍结果根本没什么用，都是骗人的。所以，在说 webpack 之前，我想先谈一下前端打包方案这几年的演进历程，在什么场景下，我们遇到了什么问题，催生出了应对这些问题的工具。了解了需求和目的之后，你就知道什么时候 webpack 可以帮到你。我希望我用完之后很爽，你们用完之后也是。</p><h2 id="先说说前端打包方案的黑暗历史"><a href="#先说说前端打包方案的黑暗历史" class="headerlink" title="先说说前端打包方案的黑暗历史"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#先说说前端打包方案的黑暗历史" target="_blank" rel="noopener"></a>先说说前端打包方案的黑暗历史</h2><p>在很长的一段前端历史里，是不存在打包这个说法的。那个时候页面基本是纯静态的或者服务端输出的，没有 AJAX，也没有 jQuery。那个时候的 JavaScript 就像个玩具，用处大概就是在侧栏弄个时钟，用 media player 放个 mp3 之类的脚本，代码量不是很多，直接放在 <code>&lt;script&gt;</code> 标签里或者弄个 js 文件引一下就行，日子过得很轻松愉快。</p><p>随后的几年，人们开始尝试在一个页面里做更多的事情。容器的显示，隐藏，切换。用 css 写的弹层，图片轮播等等。但如果一个页面内不能向服务器请求数据，能做的事情毕竟有限的，代码的量也能维持在页面交互逻辑范围内。这时候很多人开始突破一个页面能做的事情的范围，使用隐藏的 iframe 和 flash 等作为和服务器通信的桥梁，新世界的大门慢慢地被打开，在一个页面内和服务器进行数据交互，意味着以前需要跳转多个页面的事情现在可以用一个页面搞定。但由于 iframe 和 flash 技术过于 tricky 和复杂，并没能得到广泛的推广。</p><p>直到 Google 推出 Gmail 的时候（2004 年），人们意识到了一个被忽略的接口，<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener">XMLHttpRequest</a>, 也就是我们俗称的 AJAX, 这是一个使用方便的，兼容性良好的服务器通信接口。从此开始，我们的页面开始玩出各种花来了，前端一下子出现了各种各样的库，<a href="http://prototypejs.org/" target="_blank" rel="noopener">Prototype</a>、<a href="https://dojotoolkit.org/" target="_blank" rel="noopener">Dojo</a>、<a href="http://mootools.net/" target="_blank" rel="noopener">MooTools</a>、<a href="https://www.sencha.com/products/extjs/" target="_blank" rel="noopener">Ext JS</a>、<a href="https://jquery.com/" target="_blank" rel="noopener">jQuery</a>…… 我们开始往页面里插入各种库和插件，我们的 js 文件也就爆炸了。</p><p>随着 js 能做的事情越来越多，引用越来越多，文件越来越大，加上当时大约只有 2Mbps 左右的网速，下载速度还不如 3G 网络，对 js 文件的压缩和合并的需求越来越强烈，当然这里面也有把代码混淆了不容易被盗用等其他因素在里面。<a href="http://crockford.com/javascript/jsmin" target="_blank" rel="noopener">JSMin</a>、<a href="http://yui.github.io/yuicompressor/" target="_blank" rel="noopener">YUI Compressor</a>、<a href="https://developers.google.com/closure/compiler/" target="_blank" rel="noopener">Closure Compiler</a>、<a href="http://lisperator.net/uglifyjs/" target="_blank" rel="noopener">UglifyJS</a> 等 js 文件压缩合并工具陆陆续续诞生了。压缩工具是有了，但我们得要执行它，最简单的办法呢，就是 windows 上搞个 bat 脚本，mac / linux 上搞个 bash 脚本，哪几个文件要合并在一块的，哪几个要压缩的，发布的时候运行一下脚本，生成压缩后的文件。</p><p>基于合并压缩技术，项目越做越大，问题也越来越多，大概就是以下这些问题：</p><ul><li>库和插件为了要给他人调用，肯定要找个地方注册，一般就是在 window 下申明一个全局的函数或对象。难保哪天用的两个库在全局用同样的名字，那就冲突了。</li><li>库和插件如果还依赖其他的库和插件，就要告知使用人，需要先引哪些依赖库，那些依赖库也有自己的依赖库的话，就要先引依赖库的依赖库，以此类推。</li></ul><p>恰好就在这个时候（2009 年），随着后端 JavaScript 技术的发展，人们提出了 <a href="http://wiki.commonjs.org/wiki/Modules/1.1.1" target="_blank" rel="noopener">CommonJS</a> 的模块化规范，大概的语法是： 如果 <code>a.js</code> 依赖 <code>b.js</code> 和 <code>c.js</code>， 那么就在 <code>a.js</code> 的头部，引入这些依赖文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var b = require(&apos;./b&apos;)</span><br><span class="line">var c = require(&apos;./c&apos;)</span><br></pre></td></tr></table></figure><p>那么变量 <code>b</code> 和 <code>c</code> 会是什么呢？那就是 b.js 和 c.js 导出的东西，比如 b.js 可以这样导出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.square = function(num) &#123;</span><br><span class="line">  return num * num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以在 a.js 使用这个 <code>square</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var n = b.square(2)</span><br></pre></td></tr></table></figure><p>如果 c.js 依赖 d.js， 导出的是一个 <code>Number</code>， 那么可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var d = require(&apos;./d&apos;)</span><br><span class="line">module.exports = d.PI // 假设 d.PI 的值是 3.14159</span><br></pre></td></tr></table></figure><p>那么 a.js 中的变量 <code>c</code> 就是数字 <code>3.14159</code>，具体的语法规范可以查看 Node.js 的 <a href="https://nodejs.org/api/modules.html" target="_blank" rel="noopener">文档</a>。</p><p>但是 CommonJS 在浏览器内并不适用。因为 <code>require()</code> 的返回是同步的，意味着有多个依赖的话需要一个一个依次下载，堵塞了 js 脚本的执行。所以人们就在 CommonJS 的基础上定义了 <a href="https://github.com/amdjs/amdjs-api" target="_blank" rel="noopener">Asynchronous Module Definition (AMD)</a> 规范(2011 年），使用了异步回调的语法来并行下载多个依赖项，比如作为入口的 a.js 可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;./b&apos;, &apos;./c&apos;], function(b, c) &#123;</span><br><span class="line">  var n = b.square(2)</span><br><span class="line">  console.log(c)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>相应的导出语法也是异步回调方式，比如 <code>c.js</code> 依赖 <code>d.js</code>， 就写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;./d&apos;], function(d) &#123;</span><br><span class="line">  return d.PI</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到，定义一个模块是使用 <code>define()</code> 函数，<code>define()</code> 和 <code>require()</code> 的区别是，<code>define()</code> 必须要在回调函数中返回一个值作为导出的东西，<code>require()</code> 不需要导出东西，因此回调函数中不需要返回值，也无法作为被依赖项被其他文件导入，因此一般用于入口文件，比如页面中这样加载 <code>a.js</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/a&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>以上是 AMD 规范的基本用法，更详细的就不多说了（反正也淘汰了～），有兴趣的可以看 <a href="http://requirejs.org/docs/api.html" target="_blank" rel="noopener">这里</a>。</p><p>js 模块化问题基本解决了，css 和 html 也没闲着。什么 <a href="http://lesscss.org/" target="_blank" rel="noopener">less</a>，<a href="http://sass-lang.com/" target="_blank" rel="noopener">sass</a>，<a href="http://stylus-lang.com/" target="_blank" rel="noopener">stylus</a> 的 css 预处理器横空出世，说能帮我们简化 css 的写法，自动给你加 vendor prefix。html 在这期间也出现了一堆模板语言，什么 <a href="http://handlebarsjs.com/" target="_blank" rel="noopener">handlebars</a>，<a href="http://www.embeddedjs.com/" target="_blank" rel="noopener">ejs</a>，<a href="http://jade-lang.com/" target="_blank" rel="noopener">jade</a>，可以把 ajax 拿到的数据插入到模板中，然后用 innerHTML 显示到页面上。</p><p>托 AMD 和 CSS 预处理和模板语言的福，我们的编译脚本也洋洋洒洒写了百来行。命令行脚本有个不好的地方，就是 windows 和 mac/linux 是不通用的，如果有跨平台需求的话，windows 要装个可以执行 bash 脚本的命令行工具，比如 msys（目前最新的是 <a href="http://msys2.github.io/" target="_blank" rel="noopener">msys2</a>），或者使用 php 或 python 等其他语言的脚本来编写，对于非全栈型的前端程序员来说，写 bash / php / python 还是很生涩的。因此我们需要一个简单的打包工具，可以利用各种编译工具，编译 / 压缩 js、css、html、图片等资源。然后 <a href="http://gruntjs.com/" target="_blank" rel="noopener">Grunt</a> 产生了（2012 年），配置文件格式是我们最爱的 js，写法也很简单，社区有非常多的插件支持各种编译、lint、测试工具。一年多后另一个打包工具 <a href="http://gulpjs.com/" target="_blank" rel="noopener">gulp</a> 诞生了，扩展性更强，采用流式处理效率更高。</p><p>依托 AMD 模块化编程，SPA(Single-page application) 的实现方式更为简单清晰，一个网页不再是传统的类似 word 文档的页面，而是一个完整的应用程序。SPA 应用有一个总的入口页面，我们通常把它命名为 index.html、app.html、main.html，这个 html 的 <code>&lt;body&gt;</code> 一般是空的，或者只有总的布局（layout），比如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-e4d8616ab5f42665.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure> <p>布局会把 header、nav、footer 的内容填上，但 main 区域是个空的容器。这个作为入口的 html 最主要的工作是加载启动 SPA 的 js 文件，然后由 js 驱动，根据当前浏览器地址进行路由分发，加载对应的 AMD 模块，然后该 AMD 模块执行，渲染对应的 html 到页面指定的容器内（比如图中的 main）。在点击链接等交互时，页面不会跳转，而是由 js 路由加载对应的 AMD 模块，然后该 AMD 模块渲染对应的 html 到容器内。</p><p>虽然 AMD 模块让 SPA 更容易地实现，但小问题还是很多的：</p><ul><li>不是所有的第三方库都是 AMD 规范的，这时候要配置 <code>shim</code>，很麻烦。</li><li>虽然 RequireJS 支持通过插件把 html 作为依赖加载，但 html 里面的 <code>&lt;img&gt;</code> 的路径是个问题，需要使用绝对路径并且保持打包后的图片路径和打包前的路径不变，或者使用 html 模板语言把 <code>src</code> 写成变量，在运行时生成。</li><li>不支持动态加载 css，变通的方法是把所有的 css 文件合并压缩成一个文件，在入口的 html 页面一次性加载。</li><li>SPA 项目越做越大，一个应用打包后的 js 文件到了几 MB 的大小。虽然 <a href="http://requirejs.org/docs/optimization.html" target="_blank" rel="noopener">r.js</a> 支持分模块打包，但配置很麻烦，因为模块之间会互相依赖，在配置的时候需要 exclude 那些通用的依赖项，而依赖项要在文件里一个个检查。</li><li>所有的第三方库都要自己一个个的下载，解压，放到某个目录下，更别提更新有多麻烦了。虽然可以用 <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a> 包管理工具，但 npm 的包都是 CommonJS 规范的，给后端 Node.js 用的，只有部分支持 AMD 规范，而且在 npm 3 之前，这些包有依赖项的话也是不能用的。后来有个 <a href="https://bower.io/" target="_blank" rel="noopener">bower</a> 包管理工具是专门的 web 前端仓库，这里的包一般都支持 AMD 规范。</li><li>AMD 规范定义和引用模块的语法太麻烦，上面介绍的 AMD 语法仅是最简单通用的语法，API 文档里面还有很多变异的写法，特别是当发生循环引用的时候（a 依赖 b，b 依赖 a），需要使用其他的 <a href="http://requirejs.org/docs/api.html#circular" target="_blank" rel="noopener">语法</a> 解决这个问题。而且 npm 上很多前后端通用的库都是 CommonJS 的语法。后来很多人又开始尝试使用 ES6 模块规范，如何引用 ES6 模块又是一个大问题。</li><li>项目的文件结构不合理，因为 grunt/gulp 是按照文件格式批量处理的，所以一般会把 js、html、css、图片分别放在不同的目录下，所以同一个模块的文件会散落在不同的目录下，开发的时候找文件是个麻烦的事情。code review 时想知道一个文件是哪个模块的也很麻烦，解决办法比如又要在 imgs 目录下建立按模块命名的文件夹，里面再放图片。</li></ul><p>到了这里，我们的主角 webpack 登场了（2012 年）（此处应有掌声）。</p><p>和 webpack 差不多同期登场的还有 <a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a>。这里简单介绍一下 Browserify。Browserify 的目的是让前端也能用 CommonJS 的语法 <code>require(&#39;module&#39;)</code> 来加载 js。它会从入口 js 文件开始，把所有的 <code>require()</code> 调用的文件打包合并到一个文件，这样就解决了异步加载的问题。那么 Browserify 有什么不足之处导致我不推荐使用它呢? 主要原因有下面几点：</p><ul><li>最主要的一点，Browserify 不支持把代码打包成多个文件，在有需要的时候加载。这就意味着访问任何一个页面都会全量加载所有文件。</li><li>Browserify 对其他非 js 文件的加载不够完善，因为它主要解决的是 <code>require()</code> js 模块的问题，其他文件不是它关心的部分。比如 html 文件里的 img 标签，它只能转成 <a href="https://en.wikipedia.org/wiki/Data_URI_scheme" target="_blank" rel="noopener">Data URI</a> 的形式，而不能替换为打包后的路径。</li><li>因为上面一点 Browserify 对资源文件的加载支持不够完善，导致打包时一般都要配合 gulp 或 grunt 一块使用，无谓地增加了打包的难度。</li><li>Browserify 只支持 CommonJS 模块规范，不支持 AMD 和 ES6 模块规范，这意味旧的 AMD 模块和将来的 ES6 模块不能使用。</li></ul><p>基于以上几点，Browserify 并不是一个理想的选择。那么 webpack 是否解决了以上的几个问题呢? 废话，不然介绍它干嘛。那么下面章节我们用实战的方式来说明 webpack 是怎么解决上述的问题的。</p><h2 id="上手先搞一个简单的-SPA-应用"><a href="#上手先搞一个简单的-SPA-应用" class="headerlink" title="上手先搞一个简单的 SPA 应用"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#上手先搞一个简单的-spa-应用" target="_blank" rel="noopener"></a>上手先搞一个简单的 SPA 应用</h2><p>一上来步子太大容易扯到蛋，让我们先弄个最简单的 webpack 配置来热一下身。</p><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#安装-nodejs" target="_blank" rel="noopener"></a>安装 Node.js</h3><p>webpack 是基于我大 Node.js 的打包工具，上来第一件事自然是先安装 Node.js 了，<a href="https://nodejs.org/" target="_blank" rel="noopener">传送门 -&gt;</a>。</p><h3 id="初始化一个项目"><a href="#初始化一个项目" class="headerlink" title="初始化一个项目"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#初始化一个项目" target="_blank" rel="noopener"></a>初始化一个项目</h3><p>我们先随便找个地方，建一个文件夹叫 <code>simple</code>， 然后在这里面搭项目。完成品在 <a href="https://github.com/fenivana/webpack-and-spa-guide/blob/master/examples/simple" target="_blank" rel="noopener">examples/simple</a> 目录，大家搞的时候可以参照一下。我们先看一下目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── dist                      打包输出目录，只需部署这个目录到生产环境</span><br><span class="line">├── package.json              项目配置信息</span><br><span class="line">├── node_modules              npm 安装的依赖包都在这里面</span><br><span class="line">├── src                       我们的源代码</span><br><span class="line">│   ├── components            可以复用的模块放在这里面</span><br><span class="line">│   ├── index.html            入口 html</span><br><span class="line">│   ├── index.js              入口 js</span><br><span class="line">│   ├── shared                公共函数库</span><br><span class="line">│   └── views                 页面放这里</span><br><span class="line">└── webpack.config.js         webpack 配置文件</span><br></pre></td></tr></table></figure><p>打开命令行窗口，<code>cd</code> 到刚才建的 simple 目录。然后执行这个命令初始化项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>命令行会要你输入一些配置信息，我们这里一路按回车下去，生成一个默认的项目配置文件 <code>package.json</code>。</p><h3 id="给项目加上语法报错和代码规范检查"><a href="#给项目加上语法报错和代码规范检查" class="headerlink" title="给项目加上语法报错和代码规范检查"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#给项目加上语法报错和代码规范检查" target="_blank" rel="noopener"></a>给项目加上语法报错和代码规范检查</h3><p>我们安装 <a href="http://eslint.org/" target="_blank" rel="noopener">eslint</a>， 用来检查语法报错，当我们书写 js 时，有错误的地方会出现提示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint eslint-config-enough babel-eslint eslint-loader --save-dev</span><br></pre></td></tr></table></figure><p><code>npm install</code> 可以一条命令同时安装多个包，包之间用空格分隔。包会被安装进 <code>node_modules</code> 目录中。</p><p><code>--save-dev</code> 会把安装的包和版本号记录到 <code>package.json</code> 中的 <code>devDependencies</code> 对象中，还有一个 <code>--save</code>， 会记录到 <code>dependencies</code> 对象中，它们的区别，我们可以先简单的理解为打包工具和测试工具用到的包使用 <code>--save-dev</code> 存到 <code>devDependencies</code>， 比如 eslint、webpack。浏览器中执行的 js 用到的包存到 <code>dependencies</code>， 比如 jQuery 等。那么它们用来干嘛的？</p><p>因为有些 npm 包安装是需要编译的，那么导致 windows / mac /linux 上编译出的可执行文件是不同的，也就是无法通用，因此我们在提交代码到 git 上去的时候，一般都会在 <code>.gitignore</code> 里指定忽略 node_modules 目录和里面的文件，这样其他人从 git 上拉下来的项目是没有 node_modules 目录的，这时我们需要运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>它会读取 <code>package.json</code> 中的 <code>devDependencies</code> 和 <code>dependencies</code> 字段，把记录的包的相应版本下载下来。</p><p>这里 <a href="https://github.com/fenivana/eslint-config-enough" target="_blank" rel="noopener">eslint-config-enough</a> 是配置文件，它规定了代码规范，要使它生效，我们要在 <code>package.json</code> 中添加内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;eslintConfig&quot;: &#123;</span><br><span class="line">    &quot;extends&quot;: &quot;enough&quot;,</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">      &quot;browser&quot;: true,</span><br><span class="line">      &quot;node&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业界最有名的语法规范是 <a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">airbnb</a> 出品的，但它规定的太死板了，比如不允许使用 <code>for-of</code> 和 <code>for-in</code> 等。感兴趣的同学可以参照 <a href="https://www.npmjs.com/package/eslint-config-airbnb" target="_blank" rel="noopener">这里</a> 安装使用。</p><p><a href="https://github.com/babel/babel-eslint" target="_blank" rel="noopener">babel-eslint</a> 是 <code>eslint-config-enough</code> 依赖的语法解析库，替代 eslint 默认的解析库以支持还未标准化的语法。比如 <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">import()</a>。</p><p><a href="https://github.com/MoOx/eslint-loader" target="_blank" rel="noopener">eslint-loader</a> 用于在 webpack 编译的时候检查代码，如果有错误，webpack 会报错。</p><p>项目里安装了 eslint 还没用，我们的 IDE 和编辑器也得要装 eslint 插件支持它。</p><p><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a> 需要安装 <a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint" target="_blank" rel="noopener">ESLint 扩展</a></p><p><a href="https://atom.io/" target="_blank" rel="noopener">atom</a> 需要安装 <a href="https://atom.io/packages/linter" target="_blank" rel="noopener">linter</a> 和 <a href="https://atom.io/packages/linter-eslint" target="_blank" rel="noopener">linter-eslint</a> 这两个插件，装好后重启生效。</p><p><a href="https://www.jetbrains.com/webstorm/" target="_blank" rel="noopener">WebStorm</a> 需要在设置中打开 eslint 开关：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-c0a131357700b656.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure> <h3 id="写几个页面"><a href="#写几个页面" class="headerlink" title="写几个页面"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#写几个页面" target="_blank" rel="noopener"></a>写几个页面</h3><p>我们写一个最简单的 SPA 应用来介绍 SPA 应用的内部工作原理。首先，建立 src/index.html 文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>它是一个空白页面，注意这里我们不需要自己写 <code>&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</code>， 因为打包后的文件名和路径可能会变，所以我们用 webpack 插件帮我们自动加上。</p><p>src/index.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 引入 router</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line"></span><br><span class="line">// 启动 router</span><br><span class="line">router.start()</span><br></pre></td></tr></table></figure><p>src/router.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 引入页面文件</span><br><span class="line">import foo from &apos;./views/foo&apos;</span><br><span class="line">import bar from &apos;./views/bar&apos;</span><br><span class="line"></span><br><span class="line">const routes = &#123;</span><br><span class="line">  &apos;/foo&apos;: foo,</span><br><span class="line">  &apos;/bar&apos;: bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Router 类，用来控制页面根据当前 URL 切换</span><br><span class="line">class Router &#123;</span><br><span class="line">  start() &#123;</span><br><span class="line">    // 点击浏览器后退 / 前进按钮时会触发 window.onpopstate 事件，我们在这时切换到相应页面</span><br><span class="line">    // https://developer.mozilla.org/en-US/docs/Web/Events/popstate</span><br><span class="line">    window.addEventListener(&apos;popstate&apos;, () =&gt; &#123;</span><br><span class="line">      this.load(location.pathname)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    // 打开页面时加载当前页面</span><br><span class="line">    this.load(location.pathname)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 前往 path，变更地址栏 URL，并加载相应页面</span><br><span class="line">  go(path) &#123;</span><br><span class="line">    // 变更地址栏 URL</span><br><span class="line">    history.pushState(&#123;&#125;, &apos;&apos;, path)</span><br><span class="line">    // 加载页面</span><br><span class="line">    this.load(path)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 加载 path 路径的页面</span><br><span class="line">  load(path) &#123;</span><br><span class="line">    // 首页</span><br><span class="line">    if (path === &apos;/&apos;) path = &apos;/foo&apos;</span><br><span class="line">    // 创建页面实例</span><br><span class="line">    const view = new routes[path]()</span><br><span class="line">    // 调用页面方法，把页面加载到 document.body 中</span><br><span class="line">    view.mount(document.body)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 导出 router 实例</span><br><span class="line">export default new Router()</span><br></pre></td></tr></table></figure><p>src/views/foo/index.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 引入 router</span><br><span class="line">import router from &apos;../../router&apos;</span><br><span class="line"></span><br><span class="line">// 引入 html 模板，会被作为字符串引入</span><br><span class="line">import template from &apos;./index.html&apos;</span><br><span class="line"></span><br><span class="line">// 引入 css, 会生成 &lt;style&gt; 块插入到 &lt;head&gt; 头中</span><br><span class="line">import &apos;./style.css&apos;</span><br><span class="line"></span><br><span class="line">// 导出类</span><br><span class="line">export default class &#123;</span><br><span class="line">  mount(container) &#123;</span><br><span class="line">    document.title = &apos;foo&apos;</span><br><span class="line">    container.innerHTML = template</span><br><span class="line">    container.querySelector(&apos;.foo__gobar&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">      // 调用 router.go 方法加载 /bar 页面</span><br><span class="line">      router.go(&apos;/bar&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>src/views/bar/index.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 引入 router</span><br><span class="line">import router from &apos;../../router&apos;</span><br><span class="line"></span><br><span class="line">// 引入 html 模板，会被作为字符串引入</span><br><span class="line">import template from &apos;./index.html&apos;</span><br><span class="line"></span><br><span class="line">// 引入 css, 会生成 &lt;style&gt; 块插入到 &lt;head&gt; 头中</span><br><span class="line">import &apos;./style.css&apos;</span><br><span class="line"></span><br><span class="line">// 导出类</span><br><span class="line">export default class &#123;</span><br><span class="line">  mount(container) &#123;</span><br><span class="line">    document.title = &apos;bar&apos;</span><br><span class="line">    container.innerHTML = template</span><br><span class="line">    container.querySelector(&apos;.bar__gofoo&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123;</span><br><span class="line">      // 调用 router.go 方法加载 /foo 页面</span><br><span class="line">      router.go(&apos;/foo&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助 webpack 插件，我们可以 <code>import</code> html, css 等其他格式的文件，文本类的文件会被储存为变量打包进 js 文件，其他二进制类的文件，比如图片，可以自己配置，小图片作为 <a href="https://en.wikipedia.org/wiki/Data_URI_scheme" target="_blank" rel="noopener">Data URI</a> 打包进 js 文件，大文件打包为单独文件，我们稍后再讲这块。</p><p>其他的 src 目录下的文件大家自己浏览，拷贝一份到自己的工作目录，等会打包时会用到。</p><p>页面代码这样就差不多搞定了，接下来我们进入 webpack 的安装和配置阶段。现在我们还没有讲 webpack 配置所以页面还无法访问，等会弄好 webpack 配置后再看页面实际效果。</p><h3 id="安装-webpack-和-Babel"><a href="#安装-webpack-和-Babel" class="headerlink" title="安装 webpack 和 Babel"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#安装-webpack-和-babel" target="_blank" rel="noopener"></a>安装 webpack 和 Babel</h3><p>我们把 webpack 和它的插件安装到项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli webpack-serve html-webpack-plugin html-loader css-loader style-loader file-loader url-loader --save-dev</span><br></pre></td></tr></table></figure><p><a href="https://github.com/webpack/webpack" target="_blank" rel="noopener">webpack</a> 即 webpack 核心库。它提供了很多 <a href="https://webpack.js.org/api/node/" target="_blank" rel="noopener">API</a>, 通过 Node.js 脚本中 <code>require(&#39;webpack&#39;)</code> 的方式来使用 webpack。</p><p><a href="https://github.com/webpack/webpack-cli" target="_blank" rel="noopener">webpack-cli</a> 是 webpack 的命令行工具。让我们可以不用写打包脚本，只需配置打包配置文件，然后在命令行输入 <code>webpack-cli --config webpack.config.js</code> 来使用 webpack, 简单很多。webpack 4 之前命令行工具是集成在 webpack 包中的，4.0 开始 webpack 包本身不再集成 cli。</p><p><a href="https://github.com/webpack-contrib/webpack-serve" target="_blank" rel="noopener">webpack-serve</a> 是 webpack 提供的用来开发调试的服务器，让你可以用 <a href="http://127.0.0.1:8080/" target="_blank" rel="noopener">http://127.0.0.1:8080/</a> 这样的 url 打开页面来调试，有了它就不用配置 <a href="https://nginx.org/en/" target="_blank" rel="noopener">nginx</a> 了，方便很多。</p><p><a href="https://github.com/ampedandwired/html-webpack-plugin" target="_blank" rel="noopener">html-webpack-plugin</a>, <a href="https://github.com/webpack/html-loader" target="_blank" rel="noopener">html-loader</a>, <a href="https://github.com/webpack/css-loader" target="_blank" rel="noopener">css-loader</a>, <a href="https://github.com/webpack/style-loader" target="_blank" rel="noopener">style-loader</a> 等看名字就知道是打包 html 文件，css 文件的插件，大家在这里可能会有疑问，<code>html-webpack-plugin</code> 和 <code>html-loader</code> 有什么区别，<code>css-loader</code> 和 <code>style-loader</code> 有什么区别，我们等会看配置文件的时候再讲。</p><p><a href="https://github.com/webpack/file-loader" target="_blank" rel="noopener">file-loader</a> 和 <a href="https://github.com/webpack/url-loader" target="_blank" rel="noopener">url-loader</a> 是打包二进制文件的插件，具体也在配置文件章节讲解。</p><p>接下来，为了能让不支持 ES6 的浏览器 （比如 IE) 也能照常运行，我们需要安装 <a href="http://babeljs.io/" target="_blank" rel="noopener">babel</a>, 它会把我们写的 ES6 源代码转化成 ES5，这样我们源代码写 ES6，打包时生成 ES5。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-core babel-preset-env babel-loader --save-dev</span><br></pre></td></tr></table></figure><p>这里 <code>babel-core</code> 顾名思义是 babel 的核心编译器。<a href="https://babeljs.io/docs/plugins/preset-env/" target="_blank" rel="noopener">babel-preset-env</a> 是一个配置文件，我们可以使用这个配置文件转换 <a href="http://exploringjs.com/es6/" target="_blank" rel="noopener">ES2015</a>/<a href="https://leanpub.com/exploring-es2016-es2017/read" target="_blank" rel="noopener">ES2016</a>/<a href="http://www.2ality.com/2016/02/ecmascript-2017.html" target="_blank" rel="noopener">ES2017</a> 到 ES5，是的，不只 ES6 哦。babel 还有 <a href="http://babeljs.io/docs/plugins/" target="_blank" rel="noopener">其他配置文件</a>。</p><p>光安装了 <code>babel-preset-env</code>，在打包时是不会生效的，需要在 <code>package.json</code> 加入 <code>babel</code> 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;babel&quot;: &#123;</span><br><span class="line">    &quot;presets&quot;: [&quot;env&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包时 babel 会读取 <code>package.json</code> 中 <code>babel</code> 字段的内容，然后执行相应的转换。</p><p><a href="https://github.com/babel/babel-loader" target="_blank" rel="noopener">babel-loader</a> 是 webpack 的插件，我们下面章节再说。</p><h3 id="配置-webpack"><a href="#配置-webpack" class="headerlink" title="配置 webpack"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#配置-webpack" target="_blank" rel="noopener"></a>配置 webpack</h3><p>包都装好了，接下来总算可以进入正题了。我们来创建 webpack 配置文件 <code>webpack.config.js</code>，注意这个文件是在 node.js 中运行的，因此不支持 ES6 的 <code>import</code> 语法。我们来看文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">const &#123; resolve &#125; = require(&apos;path&apos;)</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line">const history = require(&apos;connect-history-api-fallback&apos;)</span><br><span class="line">const convert = require(&apos;koa-connect&apos;)</span><br><span class="line"></span><br><span class="line">// 使用 WEBPACK_SERVE 环境变量检测当前是否是在 webpack-server 启动的开发环境中</span><br><span class="line">const dev = Boolean(process.env.WEBPACK_SERVE)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  /*</span><br><span class="line">  webpack 执行模式</span><br><span class="line">  development：开发环境，它会在配置文件中插入调试相关的选项，比如 moduleId 使用文件路径方便调试</span><br><span class="line">  production：生产环境，webpack 会将代码做压缩等优化</span><br><span class="line">  */</span><br><span class="line">  mode: dev ? &apos;development&apos; : &apos;production&apos;,</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  配置 source map</span><br><span class="line">  开发模式下使用 cheap-module-eval-source-map, 生成的 source map 能和源码每行对应，方便打断点调试</span><br><span class="line">  生产模式下使用 hidden-source-map, 生成独立的 source map 文件，并且不在 js 文件中插入 source map 路径，用于在 error report 工具中查看 （比如 Sentry)</span><br><span class="line">  */</span><br><span class="line">  devtool: dev ? &apos;cheap-module-eval-source-map&apos; : &apos;hidden-source-map&apos;,</span><br><span class="line"></span><br><span class="line">  // 配置页面入口 js 文件</span><br><span class="line">  entry: &apos;./src/index.js&apos;,</span><br><span class="line"></span><br><span class="line">  // 配置打包输出相关</span><br><span class="line">  output: &#123;</span><br><span class="line">    // 打包输出目录</span><br><span class="line">    path: resolve(__dirname, &apos;dist&apos;),</span><br><span class="line"></span><br><span class="line">    // 入口 js 的打包输出文件名</span><br><span class="line">    filename: &apos;index.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  module: &#123;</span><br><span class="line">    /*</span><br><span class="line">    配置各种类型文件的加载器，称之为 loader</span><br><span class="line">    webpack 当遇到 import ... 时，会调用这里配置的 loader 对引用的文件进行编译</span><br><span class="line">    */</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        /*</span><br><span class="line">        使用 babel 编译 ES6 / ES7 / ES8 为 ES5 代码</span><br><span class="line">        使用正则表达式匹配后缀名为 .js 的文件</span><br><span class="line">        */</span><br><span class="line">        test: /\.js$/,</span><br><span class="line"></span><br><span class="line">        // 排除 node_modules 目录下的文件，npm 安装的包不需要编译</span><br><span class="line">        exclude: /node_modules/,</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        use 指定该文件的 loader, 值可以是字符串或者数组。</span><br><span class="line">        这里先使用 eslint-loader 处理，返回的结果交给 babel-loader 处理。loader 的处理顺序是从最后一个到第一个。</span><br><span class="line">        eslint-loader 用来检查代码，如果有错误，编译的时候会报错。</span><br><span class="line">        babel-loader 用来编译 js 文件。</span><br><span class="line">        */</span><br><span class="line">        use: [&apos;babel-loader&apos;, &apos;eslint-loader&apos;]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        // 匹配 html 文件</span><br><span class="line">        test: /\.html$/,</span><br><span class="line">        /*</span><br><span class="line">        使用 html-loader, 将 html 内容存为 js 字符串，比如当遇到</span><br><span class="line">        import htmlString from &apos;./template.html&apos;;</span><br><span class="line">        template.html 的文件内容会被转成一个 js 字符串，合并到 js 文件里。</span><br><span class="line">        */</span><br><span class="line">        use: &apos;html-loader&apos;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        // 匹配 css 文件</span><br><span class="line">        test: /\.css$/,</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        先使用 css-loader 处理，返回的结果交给 style-loader 处理。</span><br><span class="line">        css-loader 将 css 内容存为 js 字符串，并且会把 background, @font-face 等引用的图片，</span><br><span class="line">        字体文件交给指定的 loader 打包，类似上面的 html-loader, 用什么 loader 同样在 loaders 对象中定义，等会下面就会看到。</span><br><span class="line">        */</span><br><span class="line">        use: [&apos;style-loader&apos;, &apos;css-loader&apos;]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        /*</span><br><span class="line">        匹配各种格式的图片和字体文件</span><br><span class="line">        上面 html-loader 会把 html 中 &lt;img&gt; 标签的图片解析出来，文件名匹配到这里的 test 的正则表达式，</span><br><span class="line">        css-loader 引用的图片和字体同样会匹配到这里的 test 条件</span><br><span class="line">        */</span><br><span class="line">        test: /\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\?.+)?$/,</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        使用 url-loader, 它接受一个 limit 参数，单位为字节(byte)</span><br><span class="line"></span><br><span class="line">        当文件体积小于 limit 时，url-loader 把文件转为 Data URI 的格式内联到引用的地方</span><br><span class="line">        当文件大于 limit 时，url-loader 会调用 file-loader, 把文件储存到输出目录，并把引用的文件路径改写成输出后的路径</span><br><span class="line"></span><br><span class="line">        比如 views/foo/index.html 中</span><br><span class="line">        &lt;img src=&quot;smallpic.png&quot;&gt;</span><br><span class="line">        会被编译成</span><br><span class="line">        &lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAA...&quot;&gt;</span><br><span class="line"></span><br><span class="line">        而</span><br><span class="line">        &lt;img src=&quot;largepic.png&quot;&gt;</span><br><span class="line">        会被编译成</span><br><span class="line">        &lt;img src=&quot;/f78661bef717cf2cc2c2e5158f196384.png&quot;&gt;</span><br><span class="line">        */</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  /*</span><br><span class="line">  配置 webpack 插件</span><br><span class="line">  plugin 和 loader 的区别是，loader 是在 import 时根据不同的文件名，匹配不同的 loader 对这个文件做处理，</span><br><span class="line">  而 plugin, 关注的不是文件的格式，而是在编译的各个阶段，会触发不同的事件，让你可以干预每个编译阶段。</span><br><span class="line">  */</span><br><span class="line">  plugins: [</span><br><span class="line">    /*</span><br><span class="line">    html-webpack-plugin 用来打包入口 html 文件</span><br><span class="line">    entry 配置的入口是 js 文件，webpack 以 js 文件为入口，遇到 import, 用配置的 loader 加载引入文件</span><br><span class="line">    但作为浏览器打开的入口 html, 是引用入口 js 的文件，它在整个编译过程的外面，</span><br><span class="line">    所以，我们需要 html-webpack-plugin 来打包作为入口的 html 文件</span><br><span class="line">    */</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      /*</span><br><span class="line">      template 参数指定入口 html 文件路径，插件会把这个文件交给 webpack 去编译，</span><br><span class="line">      webpack 按照正常流程，找到 loaders 中 test 条件匹配的 loader 来编译，那么这里 html-loader 就是匹配的 loader</span><br><span class="line">      html-loader 编译后产生的字符串，会由 html-webpack-plugin 储存为 html 文件到输出目录，默认文件名为 index.html</span><br><span class="line">      可以通过 filename 参数指定输出的文件名</span><br><span class="line">      html-webpack-plugin 也可以不指定 template 参数，它会使用默认的 html 模板。</span><br><span class="line">      */</span><br><span class="line">      template: &apos;./src/index.html&apos;,</span><br><span class="line"></span><br><span class="line">      /*</span><br><span class="line">      因为和 webpack 4 的兼容性问题，chunksSortMode 参数需要设置为 none</span><br><span class="line">      https://github.com/jantimon/html-webpack-plugin/issues/870</span><br><span class="line">      */</span><br><span class="line">      chunksSortMode: &apos;none&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">配置开发时用的服务器，让你可以用 http://127.0.0.1:8080/ 这样的 url 打开页面来调试</span><br><span class="line">并且带有热更新的功能，打代码时保存一下文件，浏览器会自动刷新。比 nginx 方便很多</span><br><span class="line">如果是修改 css, 甚至不需要刷新页面，直接生效。这让像弹框这种需要点击交互后才会出来的东西调试起来方便很多。</span><br><span class="line"></span><br><span class="line">因为 webpack-cli 无法正确识别 serve 选项，使用 webpack-cli 执行打包时会报错。</span><br><span class="line">因此我们在这里判断一下，仅当使用 webpack-serve 时插入 serve 选项。</span><br><span class="line">issue：https://github.com/webpack-contrib/webpack-serve/issues/19</span><br><span class="line">*/</span><br><span class="line">if (dev) &#123;</span><br><span class="line">  module.exports.serve = &#123;</span><br><span class="line">    // 配置监听端口，默认值 8080</span><br><span class="line">    port: 8080,</span><br><span class="line"></span><br><span class="line">    // add: 用来给服务器的 koa 实例注入 middleware 增加功能</span><br><span class="line">    add: app =&gt; &#123;</span><br><span class="line">      /*</span><br><span class="line">      配置 SPA 入口</span><br><span class="line"></span><br><span class="line">      SPA 的入口是一个统一的 html 文件，比如</span><br><span class="line">      http://localhost:8080/foo</span><br><span class="line">      我们要返回给它</span><br><span class="line">      http://localhost:8080/index.html</span><br><span class="line">      这个文件</span><br><span class="line">      */</span><br><span class="line">      app.use(convert(history()))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="走一个"><a href="#走一个" class="headerlink" title="走一个"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#走一个" target="_blank" rel="noopener"></a>走一个</h3><p>配置 OK 了，接下来我们就运行一下吧。我们先试一下开发环境用的 <code>webpack-serve</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/webpack-serve webpack.config.js</span><br></pre></td></tr></table></figure><p>执行时需要指定配置文件。</p><p>上面的命令适用于 Mac / Linux 等 * nix 系统，也适用于 Windows 上的 PowerShell 和 bash/zsh 环境（<a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" target="_blank" rel="noopener">Windows Subsystem for Linux</a>, <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git Bash</a>、<a href="http://babun.github.io/" target="_blank" rel="noopener">Babun</a>、<a href="http://msys2.github.io/" target="_blank" rel="noopener">MSYS2</a> 等）。安利一下 Windows 同学使用 <a href="https://www.microsoft.com/store/p/ubuntu/9nblggh4msv6" target="_blank" rel="noopener">Ubuntu on Windows</a>，可以避免很多跨平台的问题，比如设置环境变量。</p><p>如果使用 Windows 的 cmd.exe，请执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_modules\.bin\webpack-serve webpack.config.js</span><br></pre></td></tr></table></figure><p>npm 会把包的可执行文件安装到 <code>./node_modules/.bin/</code> 目录下，所以我们要在这个目录下执行命令。</p><p>命令执行后，控制台显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">｢wdm｣: Compiled successfully。</span><br></pre></td></tr></table></figure><p>这就代表编译成功了，我们可以在浏览器打开 <code>http://localhost:8080/</code> 看看效果。如果有报错，那可能是什么地方没弄对？请自己仔细检查一下～</p><p>我们可以随意更改一下 src 目录下的源代码，保存后，浏览器里的页面应该很快会有相应变化。</p><p>要退出编译，按 <code>ctrl+c</code>。</p><p>开发环境编译试过之后，我们试试看编译生产环境的代码，命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/webpack-cli</span><br></pre></td></tr></table></figure><p>不需要指定配置文件，默认读取 webpack.config.js</p><p>执行脚本的命令有点麻烦，因此，我们可以利用 npm，把命令写在 <code>package.json</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-serve webpack.config.js&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack-cli&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>package.json</code> 中的 <code>scripts</code> 对象，可以用来写一些脚本命令，命令不需要前缀目录 <code>./node_modules/.bin/</code>，npm 会自动寻找该目录下的命令。我们可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>来启动开发环境。</p><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>来打包生产环境的代码。</p><h2 id="进阶配置"><a href="#进阶配置" class="headerlink" title="进阶配置"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#进阶配置" target="_blank" rel="noopener"></a>进阶配置</h2><p>上面的项目虽然可以跑起来了，但有几个点我们还没有考虑到：</p><ul><li>设置静态资源的 url 路径前缀</li><li>各个页面分开打包</li><li>第三方库和业务代码分开打包</li><li>输出的 entry 文件加上 hash</li><li>开发环境关闭 performance.hints</li><li>配置 favicon</li><li>开发环境允许其他电脑访问</li><li>打包时自定义部分参数</li><li>webpack-serve 处理路径带后缀名的文件的特殊规则</li><li>代码中插入环境变量</li><li>简化 import 路径</li><li>优化 babel 编译后的代码性能</li><li>使用 webpack 自带的 ES6 模块处理功能</li><li>使用 autoprefixer 自动创建 css 的 vendor prefixes</li></ul><p>那么，让我们在上面的配置的基础上继续完善，下面的代码我们只写出改变的部分。代码在 <a href="https://github.com/fenivana/webpack-and-spa-guide/blob/master/examples/advanced" target="_blank" rel="noopener">examples/advanced</a> 目录。</p><h3 id="设置静态资源的-url-路径前缀"><a href="#设置静态资源的-url-路径前缀" class="headerlink" title="设置静态资源的 url 路径前缀"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#设置静态资源的-url-路径前缀" target="_blank" rel="noopener"></a>设置静态资源的 url 路径前缀</h3><p>现在我们的资源文件的 url 直接在根目录，比如 <code>http://127.0.0.1:8080/index.js</code>， 这样做缓存控制和 CDN 不是很方便，因此我们给资源文件的 url 加一个前缀，比如 <code>http://127.0.0.1:8080/assets/index.js</code>. 我们来修改一下 webpack 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: &apos;/assets/&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>webpack-serve</code> 也需要修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if (dev) &#123;</span><br><span class="line">  module.exports.serve = &#123;</span><br><span class="line">    port: 8080,</span><br><span class="line">    host: &apos;0.0.0.0&apos;,</span><br><span class="line">    dev: &#123;</span><br><span class="line">      /*</span><br><span class="line">      指定 webpack-dev-middleware 的 publicpath</span><br><span class="line">      一般情况下与 output.publicPath 保持一致（除非 output.publicPath 使用的是相对路径）</span><br><span class="line">      https://github.com/webpack/webpack-dev-middleware#publicpath</span><br><span class="line">      */</span><br><span class="line">      publicPath: &apos;/assets/&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    add: app =&gt; &#123;</span><br><span class="line">      app.use(convert(history(&#123;</span><br><span class="line">        index: &apos;/assets/&apos; // index.html 文件在 /assets/ 路径下</span><br><span class="line">      &#125;)))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="各个页面分开打包"><a href="#各个页面分开打包" class="headerlink" title="各个页面分开打包"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#各个页面分开打包" target="_blank" rel="noopener"></a>各个页面分开打包</h3><p>这样浏览器只需加载当前页面所需的代码。</p><p>webpack 可以使用异步加载文件的方式引用模块，我们使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">async</a>/ <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener">await</a> 和 <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener">dynamic import</a> 来实现：</p><p>src/router.js:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 将 async/await 转换成 ES5 代码后需要这个运行时库来支持</span><br><span class="line">import &apos;regenerator-runtime/runtime&apos;</span><br><span class="line"></span><br><span class="line">const routes = &#123;</span><br><span class="line">  // import() 返回 promise</span><br><span class="line">  &apos;/foo&apos;: () =&gt; import(&apos;./views/foo&apos;),</span><br><span class="line">  &apos;/bar.do&apos;: () =&gt; import(&apos;./views/bar.do&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Router &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  // 加载 path 路径的页面</span><br><span class="line">  // 使用 async/await 语法</span><br><span class="line">  async load(path) &#123;</span><br><span class="line">    // 首页</span><br><span class="line">    if (path === &apos;/&apos;) path = &apos;/foo&apos;</span><br><span class="line"></span><br><span class="line">    // 动态加载页面</span><br><span class="line">    const View = (await routes[path]()).default</span><br><span class="line"></span><br><span class="line">    // 创建页面实例</span><br><span class="line">    const view = new View()</span><br><span class="line"></span><br><span class="line">    // 调用页面方法，把页面加载到 document.body 中</span><br><span class="line">    view.mount(document.body)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就不需要在开头把所有页面文件都 import 进来了。</p><p><a href="https://github.com/facebook/regenerator/tree/master/packages/regenerator-runtime" target="_blank" rel="noopener">regenerator-runtime</a> 是 <a href="https://github.com/facebook/regenerator" target="_blank" rel="noopener">regenerator</a> 的运行时库。Babel 通过插件 <a href="https://babeljs.io/docs/plugins/transform-regenerator" target="_blank" rel="noopener">transform-regenerator</a> 使用 <code>regenerator</code> 将 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener">generator</a>函数和 async/await 语法转换成 ES5 语法后，需要运行时库才能正确执行。</p><p>另外因为 <code>import()</code> 还没有正式进入标准，需要使用 <a href="https://babeljs.io/docs/plugins/syntax-dynamic-import/" target="_blank" rel="noopener">syntax-dynamic-import</a> 来解析此语法。 我们可以安装 <a href="https://babeljs.io/docs/plugins/preset-stage-2/" target="_blank" rel="noopener">babel-preset-stage-2</a>，它包含了 <code>import()</code> 和其他 stage 2 的语法支持。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install regenerator-runtime babel-preset-stage-2 --save-dev</span><br></pre></td></tr></table></figure><p><code>package.json</code> 改一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;babel&quot;: &#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">      &quot;env&quot;,</span><br><span class="line">      &quot;stage-2&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 webpack 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    /*</span><br><span class="line">    代码中引用的文件（js、css、图片等）会根据配置合并为一个或多个包，我们称一个包为 chunk。</span><br><span class="line">    每个 chunk 包含多个 modules。无论是否是 js，webpack 都将引入的文件视为一个 module。</span><br><span class="line">    chunkFilename 用来配置这个 chunk 输出的文件名。</span><br><span class="line"></span><br><span class="line">    [chunkhash]：这个 chunk 的 hash 值，文件发生变化时该值也会变。使用 [chunkhash] 作为文件名可以防止浏览器读取旧的缓存文件。</span><br><span class="line"></span><br><span class="line">    还有一个占位符 [id]，编译时每个 chunk 会有一个id。</span><br><span class="line">    我们在这里不使用它，因为这个 id 是个递增的数字，增加或减少一个chunk，都可能导致其他 chunk 的 id 发生改变，导致缓存失效。</span><br><span class="line">    */</span><br><span class="line">    chunkFilename: &apos;[chunkhash].js&apos;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三方库和业务代码分开打包"><a href="#第三方库和业务代码分开打包" class="headerlink" title="第三方库和业务代码分开打包"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#第三方库和业务代码分开打包" target="_blank" rel="noopener"></a>第三方库和业务代码分开打包</h3><p>这样更新业务代码时可以借助浏览器缓存，用户不需要重新下载没有发生变化的第三方库。 Webpack 4 最大的改进便是自动拆分 chunk, 如果同时满足下列条件，chunk 就会被拆分：</p><ul><li>新的 chunk 能被复用，或者模块是来自 node_modules 目录</li><li>新的 chunk 大于 30Kb(min+gz 压缩前）</li><li>按需加载 chunk 的并发请求数量小于等于 5 个</li><li>页面初始加载时的并发请求数量小于等于 3 个</li></ul><p>一般情况只需配置这几个参数即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    使用文件路径的 hash 作为 moduleId。</span><br><span class="line">    虽然我们使用 [chunkhash] 作为 chunk 的输出名，但仍然不够。</span><br><span class="line">    因为 chunk 内部的每个 module 都有一个 id，webpack 默认使用递增的数字作为 moduleId。</span><br><span class="line">    如果引入了一个新文件或删掉一个文件，可能会导致其他文件的 moduleId 也发生改变，</span><br><span class="line">    那么受影响的 module 所在的 chunk 的 [chunkhash] 就会发生改变，导致缓存失效。</span><br><span class="line">    因此使用文件路径的 hash 作为 moduleId 来避免这个问题。</span><br><span class="line">    */</span><br><span class="line">    new webpack.HashedModuleIdsPlugin()</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    /*</span><br><span class="line">    上面提到 chunkFilename 指定了 chunk 打包输出的名字，那么文件名存在哪里了呢？</span><br><span class="line">    它就存在引用它的文件中。这意味着一个 chunk 文件名发生改变，会导致引用这个 chunk 文件也发生改变。</span><br><span class="line"></span><br><span class="line">    runtimeChunk 设置为 true, webpack 就会把 chunk 文件名全部存到一个单独的 chunk 中，</span><br><span class="line">    这样更新一个文件只会影响到它所在的 chunk 和 runtimeChunk，避免了引用这个 chunk 的文件也发生改变。</span><br><span class="line">    */</span><br><span class="line">    runtimeChunk: true,</span><br><span class="line"></span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      /*</span><br><span class="line">      默认 entry 的 chunk 不会被拆分</span><br><span class="line">      因为我们使用了 html-webpack-plugin 来动态插入 &lt;script&gt; 标签，entry 被拆成多个 chunk 也能自动被插入到 html 中，</span><br><span class="line">      所以我们可以配置成 all, 把 entry chunk 也拆分了</span><br><span class="line">      */</span><br><span class="line">      chunks: &apos;all&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack 4 支持更多的手动优化，详见： <a href="https://gist.github.com/sokra/1522d586b8e5c0f5072d7565c2bee693" target="_blank" rel="noopener">https://gist.github.com/sokra/1522d586b8e5c0f5072d7565c2bee693</a></p><p>但正如 webpack 文档中所说，默认配置已经足够优化，在没有测试的情况下不要盲目手动优化。</p><h3 id="输出的-entry-文件加上-hash"><a href="#输出的-entry-文件加上-hash" class="headerlink" title="输出的 entry 文件加上 hash"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#输出的-entry-文件加上-hash" target="_blank" rel="noopener"></a>输出的 entry 文件加上 hash</h3><p>上面我们提到了 <code>chunkFilename</code> 使用 <code>[chunkhash]</code> 防止浏览器读取错误缓存，那么 entry 同样需要加上 hash。 但使用 <code>webpack-serve</code> 启动开发环境时，entry 文件是没有 <code>[chunkhash]</code> 的，用了会报错。 因此我们只在执行 <code>webpack-cli</code> 时使用 <code>[chunkhash]</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: dev ? &apos;[name].js&apos; : &apos;[chunkhash].js&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用了 <code>[name]</code> 占位符。解释它之前我们先了解一下 <code>entry</code> 的完整定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    NAME: [FILE1, FILE2, ...]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以定义多个 entry 文件，比如你的项目有多个 html 入口文件，每个 html 对应一个或多个 entry 文件。 然后每个 entry 可以定义由多个 module 组成，这些 module 会依次执行。 在 webpack 4 之前，这是很有用的功能，比如之前提到的第三方库和业务代码分开打包，在以前，我们需要这么配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry &#123;</span><br><span class="line">    main: &apos;./src/index.js&apos;,</span><br><span class="line">    vendor: [&apos;jquery&apos;, &apos;lodash&apos;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>entry 引用文件的规则和 <code>import</code> 是一样的，会寻找 <code>node_modules</code> 里的包。然后结合 <code>CommonsChunkPlugin</code> 把 vendor 定义的 module 从业务代码分离出来打包成一个单独的 chunk。 如果 entry 是一个 module，我们可以不使用数组的形式。</p><p>在 simple 项目中，我们配置了 <code>entry: &#39;./src/index.js&#39;</code>，这是最简单的形式，转换成完整的写法就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: [&apos;./src/index.js&apos;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack 会给这个 entry 指定名字为 <code>main</code>。</p><p>看到这应该知道 <code>[name]</code> 的意思了吧？它就是 entry 的名字。</p><p>有人可能注意到官网文档中还有一个 <code>[hash]</code> 占位符，这个 hash 是整个编译过程产生的一个总的 hash 值，而不是单个文件的 hash 值，项目中任何一个文件的改动，都会造成这个 hash 值的改变。<code>[hash]</code> 占位符是始终存在的，但我们不希望修改一个文件导致所有输出的文件 hash 都改变，这样就无法利用浏览器缓存了。因此这个 <code>[hash]</code> 意义不大。</p><h3 id="开发环境关闭-performance-hints"><a href="#开发环境关闭-performance-hints" class="headerlink" title="开发环境关闭 performance.hints"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#开发环境关闭-performancehints" target="_blank" rel="noopener"></a>开发环境关闭 performance.hints</h3><p>我们注意到运行开发环境是命令行会报一段 warning：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING in asset size limit: The following asset(s) exceed the recommended size limit (250 kB).</span><br><span class="line">This can impact web performance.</span><br></pre></td></tr></table></figure><p>这是说建议每个输出的 js 文件的大小不要超过 250k。但开发环境因为包含了 sourcemap 并且代码未压缩所以一般都会超过这个大小，所以我们可以在开发环境把这个 warning 关闭。</p><p>webpack 配置中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  performance: &#123;</span><br><span class="line">    hints: dev ? false : &apos;warning&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置-favicon"><a href="#配置-favicon" class="headerlink" title="配置 favicon"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#配置-favicon" target="_blank" rel="noopener"></a>配置 favicon</h3><p>在 src 目录中放一张 favicon.png，然后 <code>src/index.html</code> 的 <code>&lt;head&gt;</code> 中插入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;favicon.png&quot;&gt;</span><br></pre></td></tr></table></figure><p>修改 webpack 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.html$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;html-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              /*</span><br><span class="line">              html-loader 接受 attrs 参数，表示什么标签的什么属性需要调用 webpack 的 loader 进行打包。</span><br><span class="line">              比如 &lt;img&gt; 标签的 src 属性，webpack 会把 &lt;img&gt; 引用的图片打包，然后 src 的属性值替换为打包后的路径。</span><br><span class="line">              使用什么 loader 代码，同样是在 module.rules 定义中使用匹配的规则。</span><br><span class="line"></span><br><span class="line">              如果 html-loader 不指定 attrs 参数，默认值是 img:src, 意味着会默认打包 &lt;img&gt; 标签的图片。</span><br><span class="line">              这里我们加上 &lt;link&gt; 标签的 href 属性，用来打包入口 index.html 引入的 favicon.png 文件。</span><br><span class="line">              */</span><br><span class="line">              attrs: [&apos;img:src&apos;, &apos;link:href&apos;]</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        /*</span><br><span class="line">        匹配 favicon.png</span><br><span class="line">        上面的 html-loader 会把入口 index.html 引用的 favicon.png 图标文件解析出来进行打包</span><br><span class="line">        打包规则就按照这里指定的 loader 执行</span><br><span class="line">        */</span><br><span class="line">        test: /favicon\.png$/,</span><br><span class="line"></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            // 使用 file-loader</span><br><span class="line">            loader: &apos;file-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              /*</span><br><span class="line">              name：指定文件输出名</span><br><span class="line">              [hash] 为源文件的hash值，[ext] 为后缀。</span><br><span class="line">              */</span><br><span class="line">              name: &apos;[hash].[ext]&apos;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      // 图片文件的加载配置增加一个 exclude 参数</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\?.+)?$/,</span><br><span class="line"></span><br><span class="line">        // 排除 favicon.png, 因为它已经由上面的 loader 处理了。如果不排除掉，它会被这个 loader 再处理一遍</span><br><span class="line">        exclude: /favicon\.png$/,</span><br><span class="line"></span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;url-loader&apos;,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: 10000</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 html-webpack-plugin 接受一个 <code>favicon</code> 参数，可以指定 favicon 文件路径，会自动打包插入到 html 文件中。但它有个 <a href="https://github.com/ampedandwired/html-webpack-plugin/issues/364" target="_blank" rel="noopener">bug</a>，打包后的文件名路径不带 hash，就算有 hash，它也是 [hash]，而不是 [chunkhash]。导致修改代码也会改变 favicon 打包输出的文件名。issue 中提到的 favicons-webpack-plugin 倒是可以用，但它依赖 PhantomJS, 非常大。</p><h3 id="开发环境允许其他电脑访问"><a href="#开发环境允许其他电脑访问" class="headerlink" title="开发环境允许其他电脑访问"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#开发环境允许其他电脑访问" target="_blank" rel="noopener"></a>开发环境允许其他电脑访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const internalIp = require(&apos;internal-ip&apos;)</span><br><span class="line"></span><br><span class="line">module.exports.serve = &#123;</span><br><span class="line">  host: &apos;0.0.0.0&apos;,</span><br><span class="line">  hot: &#123;</span><br><span class="line">    host: &#123;</span><br><span class="line">      client: internalIp.v4.sync(),</span><br><span class="line">      server: &apos;0.0.0.0&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打包时自定义部分参数"><a href="#打包时自定义部分参数" class="headerlink" title="打包时自定义部分参数"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#打包时自定义部分参数" target="_blank" rel="noopener"></a>打包时自定义部分参数</h3><p>在多人开发时，每个人可能需要有自己的配置，比如说 webpack-serve 监听的端口号，如果写死在 webpack 配置里，而那个端口号在某个同学的电脑上被其他进程占用了，简单粗暴的修改 <code>webpack.config.js</code> 会导致提交代码后其他同学的端口也被改掉。</p><p>还有一点就是开发环境、测试环境、生产环境的部分 webpack 配置是不同的，比如 <code>publicPath</code> 在生产环境可能要配置一个 CDN 地址。</p><p>我们在根目录建立一个文件夹 <code>config</code>，里面创建 3 个配置文件：</p><ul><li>default.js: 生产环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  publicPath: &apos;http://cdn.example.com/assets/&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>dev.js: 默认开发环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  publicPath: &apos;/assets/&apos;,</span><br><span class="line"></span><br><span class="line">  serve: &#123;</span><br><span class="line">    port: 8090</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>local.js: 个人本地环境，在 dev.js 基础上修改部分参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const config = require(&apos;./dev&apos;)</span><br><span class="line">config.serve.port = 8070</span><br><span class="line">module.exports = config</span><br></pre></td></tr></table></figure><p><code>package.json</code> 修改 <code>scripts</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;local&quot;: &quot;npm run webpack-serve --config=local&quot;,</span><br><span class="line">    &quot;dev&quot;: &quot;npm run webpack-serve --config=dev&quot;,</span><br><span class="line">    &quot;webpack-serve&quot;: &quot;webpack-serve webpack.config.js&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack-cli&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack 配置修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">const url = require(&apos;url&apos;)</span><br><span class="line"></span><br><span class="line">const config = require(&apos;./config/&apos; + (process.env.npm_config_config || &apos;default&apos;))</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    // ...</span><br><span class="line">    publicPath: config.publicPath</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (dev) &#123;</span><br><span class="line">  module.exports.serve = &#123;</span><br><span class="line">    host: &apos;0.0.0.0&apos;,</span><br><span class="line">    port: config.serve.port,</span><br><span class="line">    dev: &#123;</span><br><span class="line">      publicPath: config.publicPath</span><br><span class="line">    &#125;,</span><br><span class="line">    add: app =&gt; &#123;</span><br><span class="line">      app.use(convert(history(&#123;</span><br><span class="line">        index: url.parse(config.publicPath).pathname</span><br><span class="line">      &#125;)))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的关键是 <code>npm run</code> 传进来的自定义参数可以通过 <code>process.env.npm_config_*</code> 获得。参数中如果有 <code>-</code> 会被转成 <code>_</code>。</p><p>还有一点，我们不需要把自己个人用的配置文件提交到 git，所以我们在 <code>.gitignore</code> 中加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config/*</span><br><span class="line">!config/default.js</span><br><span class="line">!config/dev.js</span><br></pre></td></tr></table></figure><p>把 <code>config</code> 目录排除掉，但是保留生产环境和 dev 默认配置文件。</p><p>可能有同学注意到了 <code>webpack-cli</code> 可以通过 <a href="https://webpack.js.org/api/cli/#environment-options" target="_blank" rel="noopener">–env</a> 的方式从命令行传参给脚本，遗憾的是 <code>webpack-cli</code> <a href="https://github.com/webpack-contrib/webpack-serve#webpack-function-configs" target="_blank" rel="noopener">不支持</a>。</p><h3 id="webpack-serve-处理带后缀名的文件的特殊规则"><a href="#webpack-serve-处理带后缀名的文件的特殊规则" class="headerlink" title="webpack-serve 处理带后缀名的文件的特殊规则"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#webpack-serve-处理带后缀名的文件的特殊规则" target="_blank" rel="noopener"></a>webpack-serve 处理带后缀名的文件的特殊规则</h3><p>当处理带后缀名的请求时，比如 <a href="http://localhost:8080/bar.do" target="_blank" rel="noopener">http://localhost:8080/bar.do</a> ，<code>connect-history-api-fallback</code> 会认为它应该是一个实际存在的文件，就算找不到该文件，也不会 fallback 到 index.html，而是返回 404。但在 SPA 应用中这不是我们希望的。</p><p>幸好有一个配置选项 <code>disableDotRule: true</code> 可以禁用这个规则，使带后缀的文件当不存在时也能 fallback 到 index.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module.exports.serve = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  add: app =&gt; &#123;</span><br><span class="line">    app.use(convert(history(&#123;</span><br><span class="line">      // ...</span><br><span class="line">      disableDotRule: true,</span><br><span class="line">      htmlAcceptHeaders: [&apos;text/html&apos;, &apos;application/xhtml+xml&apos;] // 需要配合 disableDotRule 一起使用</span><br><span class="line">    &#125;)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码中插入环境变量"><a href="#代码中插入环境变量" class="headerlink" title="代码中插入环境变量"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#代码中插入环境变量" target="_blank" rel="noopener"></a>代码中插入环境变量</h3><p>在业务代码中，有些变量在开发环境和生产环境是不同的，比如域名、后台 API 地址等。还有开发环境可能需要打印调试信息等。</p><p>我们可以使用 <a href="https://webpack.js.org/plugins/define-plugin/" target="_blank" rel="noopener">DefinePlugin</a> 插件在打包时往代码中插入需要的环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">const pkgInfo = require(&apos;./package.json&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.DefinePlugin(&#123;</span><br><span class="line">      DEBUG: dev,</span><br><span class="line">      VERSION: JSON.stringify(pkgInfo.version),</span><br><span class="line">      CONFIG: JSON.stringify(config.runtimeConfig)</span><br><span class="line">    &#125;),</span><br><span class="line">    // ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefinePlugin 插件的原理很简单，如果我们在代码中写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(DEBUG)</span><br></pre></td></tr></table></figure><p>它会做类似这样的处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;console.log(DEBUG)&apos;.replace(&apos;DEBUG&apos;, true)</span><br></pre></td></tr></table></figure><p>最后生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(true)</span><br></pre></td></tr></table></figure><p>这里有一点需要注意，像这里的 <code>VERSION</code>， 如果我们不对 <code>pkgInfo.version</code> 做 <code>JSON.stringify()</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(VERSION)</span><br></pre></td></tr></table></figure><p>然后做替换操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;console.log(VERSION)&apos;.replace(&apos;VERSION&apos;, &apos;1.0.0&apos;)</span><br></pre></td></tr></table></figure><p>最后生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(1.0.0)</span><br></pre></td></tr></table></figure><p>这样语法就错误了。所以，我们需要 <code>JSON.stringify(pkgInfo.version)</code> 转一下变成 <code>&#39;&quot;1.0.0&quot;&#39;</code>，替换的时候才会带引号。</p><p>还有一点，webpack 打包压缩的时候，会把代码进行优化，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (DEBUG) &#123;</span><br><span class="line">  console.log(&apos;debug mode&apos;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&apos;production mode&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被编译成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (false) &#123;</span><br><span class="line">  console.log(&apos;debug mode&apos;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&apos;production mode&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后压缩优化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;production mode&apos;)</span><br></pre></td></tr></table></figure><h3 id="简化-import-路径"><a href="#简化-import-路径" class="headerlink" title="简化 import 路径"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#简化-import-路径" target="_blank" rel="noopener"></a>简化 import 路径</h3><p>文件 a 引入文件 b 时，b 的路径是相对于 a 文件所在目录的。如果 a 和 b 在不同的目录，藏得又深，写起来就会很麻烦：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import b from &apos;../../../components/b&apos;</span><br></pre></td></tr></table></figure><p>为了方便，我们可以定义一个路径别名（alias）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    &apos;~&apos;: resolve(__dirname, &apos;src&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们可以以 <code>src</code> 目录为基础路径来 <code>import</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import b from &apos;~/components/b&apos;</span><br></pre></td></tr></table></figure><p>html 中的 <code>&lt;img&gt;</code> 标签没法使用这个别名功能，但 <code>html-loader</code> 有一个 <code>root</code> 参数，可以使 <code>/</code> 开头的文件相对于 <code>root</code> 目录解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.html$/,</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: &apos;html-loader&apos;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        root: resolve(__dirname, &apos;src&apos;),</span><br><span class="line">        attrs: [&apos;img:src&apos;, &apos;link:href&apos;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，<code>&lt;img src=&quot;/favicon.png&quot;&gt;</code> 就能顺利指向到 src 目录下的 favicon.png 文件，不需要关心当前文件和目标文件的相对路径。</p><p>PS: 在调试 <code>&lt;img&gt;</code> 标签的时候遇到一个坑，<code>html-loader</code> 会解析 <code>&lt;!-- --&gt;</code> 注释中的内容，之前在注释中写的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">大于 10kb 的图片，图片会被储存到输出目录，src 会被替换为打包后的路径</span><br><span class="line">&lt;img src=&quot;/assets/f78661bef717cf2cc2c2e5158f196384.png&quot;&gt;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><p>之前因为没有加 <code>root</code> 参数，所以 <code>/</code> 开头的文件名不会被解析，加了 <code>root</code> 导致编译时报错，找不到该文件。大家记住这一点。</p><h3 id="优化-babel-编译后的代码性能"><a href="#优化-babel-编译后的代码性能" class="headerlink" title="优化 babel 编译后的代码性能"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#优化-babel-编译后的代码性能" target="_blank" rel="noopener"></a>优化 babel 编译后的代码性能</h3><p>babel 编译后的代码一般会造成性能损失，babel 提供了一个 <a href="http://babeljs.io/docs/plugins/preset-env/#optionsloose" target="_blank" rel="noopener">loose</a> 选项，使编译后的代码不需要完全遵循 ES6 规定，简化编译后的代码，提高代码执行效率：</p><p>package.json:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;babel&quot;: &#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">      [</span><br><span class="line">        &quot;env&quot;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;loose&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;stage-2&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这么做会有兼容性的风险，可能会导致 ES6 源码理应的执行结果和编译后的 ES5 代码的实际结果并不一致。如果代码没有遇到实际的效率瓶颈，官方 <a href="http://www.2ality.com/2015/12/babel6-loose-mode.html" target="_blank" rel="noopener">不建议</a> 使用 <code>loose</code> 模式。</p><h3 id="使用-webpack-自带的-ES6-模块处理功能"><a href="#使用-webpack-自带的-ES6-模块处理功能" class="headerlink" title="使用 webpack 自带的 ES6 模块处理功能"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#使用-webpack-自带的-es6-模块处理功能" target="_blank" rel="noopener"></a>使用 webpack 自带的 ES6 模块处理功能</h3><p>我们目前的配置，babel 会把 ES6 模块定义转为 CommonJS 定义，但 webpack 自己可以处理 <code>import</code> 和 <code>export</code>， 而且 webpack 处理 <code>import</code> 时会做代码优化，把没用到的部分代码删除掉。因此我们通过 babel 提供的 <code>modules: false</code> 选项把 ES6 模块转为 CommonJS 模块的功能给关闭掉。</p><p>package.json:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;babel&quot;: &#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">      [</span><br><span class="line">        &quot;env&quot;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;loose&quot;: true,</span><br><span class="line">          &quot;modules&quot;: false</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;stage-2&quot;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-autoprefixer-自动创建-css-的-vendor-prefixes"><a href="#使用-autoprefixer-自动创建-css-的-vendor-prefixes" class="headerlink" title="使用 autoprefixer 自动创建 css 的 vendor prefixes"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#使用-autoprefixer-自动创建-css-的-vendor-prefixes" target="_blank" rel="noopener"></a>使用 autoprefixer 自动创建 css 的 vendor prefixes</h3><p>css 有一个很麻烦的问题就是比较新的 css 属性在各个浏览器里是要加前缀的，我们可以使用 <a href="https://github.com/postcss/autoprefixer" target="_blank" rel="noopener">autoprefixer</a> 工具自动创建这些浏览器规则，那么我们的 css 中只需要写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:fullscreen a &#123;</span><br><span class="line">    display: flex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>autoprefixer 会编译成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">:-webkit-full-screen a &#123;</span><br><span class="line">    display: -webkit-box;</span><br><span class="line">    display: flex</span><br><span class="line">&#125;</span><br><span class="line">:-moz-full-screen a &#123;</span><br><span class="line">    display: flex</span><br><span class="line">&#125;</span><br><span class="line">:-ms-fullscreen a &#123;</span><br><span class="line">    display: -ms-flexbox;</span><br><span class="line">    display: flex</span><br><span class="line">&#125;</span><br><span class="line">:fullscreen a &#123;</span><br><span class="line">    display: -webkit-box;</span><br><span class="line">    display: -ms-flexbox;</span><br><span class="line">    display: flex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们用 npm 安装它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install postcss-loader autoprefixer --save-dev</span><br></pre></td></tr></table></figure><p>autoprefixer 是 <a href="http://postcss.org/" target="_blank" rel="noopener">postcss</a> 的一个插件，所以我们也要安装 postcss 的 webpack <a href="https://github.com/postcss/postcss-loader" target="_blank" rel="noopener">loader</a>。</p><p>修改一下 webpack 的 css rule：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.css$/,</span><br><span class="line">  use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;postcss-loader&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建文件 <code>postcss.config.js</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    require(&apos;autoprefixer&apos;)()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-webpack-打包多页面应用（Multiple-Page-Application）"><a href="#使用-webpack-打包多页面应用（Multiple-Page-Application）" class="headerlink" title="使用 webpack 打包多页面应用（Multiple-Page Application）"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#使用-webpack-打包多页面应用multiple-page-application" target="_blank" rel="noopener"></a>使用 webpack 打包多页面应用（Multiple-Page Application）</h2><p>多页面网站同样可以用 webpack 来打包，以便使用 npm 包，<code>import()</code>，<code>code splitting</code> 等好处。</p><p>MPA 意味着并没不是一个单一的 html 入口和 js 入口，而是每个页面对应一个 html 和多个 js。那么我们可以把项目结构设计为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">├── dist</span><br><span class="line">├── package.json</span><br><span class="line">├── node_modules</span><br><span class="line">├── src</span><br><span class="line">│   ├── components</span><br><span class="line">│   ├── shared</span><br><span class="line">|   ├── favicon.png</span><br><span class="line">│   └── pages                 页面放这里</span><br><span class="line">|       ├── foo               编译后生成 http://localhost:8080/foo.html</span><br><span class="line">|       |    ├── index.html</span><br><span class="line">|       |    ├── index.js</span><br><span class="line">|       |    ├── style.css</span><br><span class="line">|       |    └── pic.png</span><br><span class="line">|       └── bar                        http://localhost:8080/bar.html</span><br><span class="line">|           ├── index.html</span><br><span class="line">|           ├── index.js</span><br><span class="line">|           ├── style.css</span><br><span class="line">|           └── baz                    http://localhost:8080/bar/baz.html</span><br><span class="line">|               ├── index.html</span><br><span class="line">|               ├── index.js</span><br><span class="line">|               └── style.css</span><br><span class="line">└── webpack.config.js</span><br></pre></td></tr></table></figure><p>这里每个页面的 <code>index.html</code> 是个完整的从 <code>&lt;!DOCTYPE html&gt;</code> 开头到 <code>&lt;/html&gt;</code> 结束的页面，这些文件都要用 <code>html-webpack-plugin</code> 处理。<code>index.js</code> 是每个页面的业务逻辑，作为每个页面的入口 js 配置到 <code>entry</code> 中。这里我们需要用 <code>glob</code> 库来把这些文件都筛选出来批量操作。为了使用 webpack 4 的 <code>optimization.splitChunks</code> 和 <code>optimization.runtimeChunk</code> 功能，我写了 <a href="https://github.com/fenivana/html-webpack-include-sibling-chunks-plugin" target="_blank" rel="noopener">html-webpack-include-sibling-chunks-plugin</a> 插件来配合使用。还要装几个插件把 css 压缩并放到 <code>&lt;head&gt;</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install glob html-webpack-include-sibling-chunks-plugin uglifyjs-webpack-plugin mini-css-extract-plugin optimize-css-assets-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p><code>webpack.config.js</code> 修改的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;)</span><br><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;)</span><br><span class="line">const OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)</span><br><span class="line">const HtmlWebpackIncludeSiblingChunksPlugin = require(&apos;html-webpack-include-sibling-chunks-plugin&apos;)</span><br><span class="line">const glob = require(&apos;glob&apos;)</span><br><span class="line"></span><br><span class="line">const dev = Boolean(process.env.WEBPACK_SERVE)</span><br><span class="line">const config = require(&apos;./config/&apos; + (process.env.npm_config_config || &apos;default&apos;))</span><br><span class="line"></span><br><span class="line">const entries = glob.sync(&apos;./src/**/index.js&apos;)</span><br><span class="line">const entry = &#123;&#125;</span><br><span class="line">const htmlPlugins = []</span><br><span class="line">for (const path of entries) &#123;</span><br><span class="line">  const template = path.replace(&apos;index.js&apos;, &apos;index.html&apos;)</span><br><span class="line">  const chunkName = path.slice(&apos;./src/pages/&apos;.length, -&apos;/index.js&apos;.length)</span><br><span class="line">  entry[chunkName] = dev ? [path, template] : path</span><br><span class="line">  htmlPlugins.push(new HtmlWebpackPlugin(&#123;</span><br><span class="line">    template,</span><br><span class="line">    filename: chunkName + &apos;.html&apos;,</span><br><span class="line">    chunksSortMode: &apos;none&apos;,</span><br><span class="line">    chunks: [chunkName]</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">    // 我们不定义 publicPath，否则访问 html 时需要带上 publicPath 前缀</span><br><span class="line">    filename: dev ? &apos;[name].js&apos; : &apos;[chunkhash].js&apos;,</span><br><span class="line">    chunkFilename: &apos;[chunkhash].js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    runtimeChunk: true,</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: &apos;all&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    minimizer: dev ? [] : [</span><br><span class="line">      new UglifyJsPlugin(&#123;</span><br><span class="line">        cache: true,</span><br><span class="line">        parallel: true,</span><br><span class="line">        sourceMap: true</span><br><span class="line">      &#125;),</span><br><span class="line">      new OptimizeCSSAssetsPlugin()</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      // ...</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css$/,</span><br><span class="line">        use: [dev ? &apos;style-loader&apos; : MiniCssExtractPlugin.loader, &apos;css-loader&apos;, &apos;postcss-loader&apos;]</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      // ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    这里不使用 [chunkhash]</span><br><span class="line">    因为从同一个 chunk 抽离出来的 css 共享同一个 [chunkhash]</span><br><span class="line">    [contenthash] 你可以简单理解为 moduleId + content 生成的 hash</span><br><span class="line">    因此一个 chunk 中的多个 module 有自己的 [contenthash]</span><br><span class="line">    */</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: &apos;[contenthash].css&apos;,</span><br><span class="line">      chunkFilename: &apos;[contenthash].css&apos;</span><br><span class="line">    &#125;),</span><br><span class="line"></span><br><span class="line">    // 必须放在html-webpack-plugin前面</span><br><span class="line">    new HtmlWebpackIncludeSiblingChunksPlugin(),</span><br><span class="line"></span><br><span class="line">    ...htmlPlugins</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>entry</code> 和 <code>htmlPlugins</code> 会通过遍历 pages 目录生成，比如：</p><p>entry:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &apos;bar/baz&apos;: &apos;./src/pages/bar/baz/index.js&apos;,</span><br><span class="line">  bar: &apos;./src/pages/bar/index.js&apos;,</span><br><span class="line">  foo: &apos;./src/pages/foo/index.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开发环境中，为了能够修改 html 文件后网页能够自动刷新，我们还需要把 html 文件也加入 entry 中，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: [&apos;./src/pages/foo/index.js&apos;, &apos;./src/pages/foo/index.html&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当 foo 页面的 index.js 或 index.html 文件改动时，都会触发浏览器刷新该页面。虽然把 html 加入 entry 很奇怪，但放心，不会导致错误。记得不要在生产环境这么做，不然导致 chunk 文件包含了无用的 html 片段。</p><p>htmlPlugins:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: &apos;./src/pages/bar/baz/index.html&apos;,</span><br><span class="line">    filename: &apos;bar/baz.html&apos;,</span><br><span class="line">    chunksSortMode: &apos;none&apos;,</span><br><span class="line">    chunks: [&apos;bar/baz&apos;]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: &apos;./src/pages/bar/index.html&apos;,</span><br><span class="line">    filename: &apos;bar.html&apos;,</span><br><span class="line">    chunksSortMode: &apos;none&apos;,</span><br><span class="line">    chunks: [&apos;bar&apos;]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  new HtmlWebpackPlugin(&#123;</span><br><span class="line">    template: &apos;./src/pages/foo/index.html&apos;,</span><br><span class="line">    filename: &apos;foo.html&apos;,</span><br><span class="line">    chunksSortMode: &apos;none&apos;,</span><br><span class="line">    chunks: [&apos;foo&apos;]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>代码在 <a href="https://github.com/fenivana/webpack-and-spa-guide/blob/master/examples/mpa" target="_blank" rel="noopener">examples/mpa</a> 目录。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><a href="https://github.com/wallstreetcn/webpack-and-spa-guide#总结" target="_blank" rel="noopener"></a>总结</h2><p>通过这篇文章，我想大家应该学会了 webpack 的正确打开姿势。虽然我没有提及如何用 webpack 来编译 <a href="https://facebook.github.io/react/" target="_blank" rel="noopener">React</a> 和 <a href="http://vuejs.org/" target="_blank" rel="noopener">vue.js</a>, 但大家可以想到，无非是安装一些 loader 和 plugin 来处理 <a href="https://babeljs.io/docs/plugins/preset-react/" target="_blank" rel="noopener">jsx</a> 和 <a href="http://vue-loader.vuejs.org/" target="_blank" rel="noopener">vue</a> 格式的文件，那时难度就不在于 webpack 了，而是代码架构组织的问题了。具体的大家自己去摸索一下。</p><blockquote><p>文章来源：<a href="https://github.com/wallstreetcn/webpack-and-spa-guide" target="_blank" rel="noopener">https://github.com/wallstreetcn/webpack-and-spa-guide</a><br>作者：wallstreetcn<br>声明：文章著作权归作者所有，如有侵权，请联系小编删除。</p></blockquote><p>关注公众号“web前端导航”，最新的前端教程和学习资料等你来拿！<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/7072486-65e75c57ef7286c8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" title="">                </div>                <div class="image-caption">image</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;可以说是我目前看到最详细的 webpack 4 入门文章。&lt;br&gt;基本看完这个，基本也算一个合格的初级webpack配置工程师了。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;webpack 更新到了 4.0，官网还没有更新文档。因此把教程更新
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门</title>
    <link href="http://yoursite.com/2018/07/19/webpack%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/07/19/webpack入门/</id>
    <published>2018-07-19T12:45:23.000Z</published>
    <updated>2018-07-19T13:17:16.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么使用webpack"><a href="#为什么使用webpack" class="headerlink" title="为什么使用webpack??"></a>为什么使用webpack??</h2><p><strong>一句话 webpack能够提高了我们的开发效率</strong><br>什么是Webpack<br>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>新建一个空的练习文件夹 如：webpackText<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//全局安装</span><br><span class="line">npm install -g webpack</span><br><span class="line">//安装到你的项目目录</span><br><span class="line">npm install --save-dev webpack</span><br><span class="line">//npm install --save-dev webpack@版本号</span><br><span class="line">//可下载对应版本的webpack</span><br></pre></td></tr></table></figure></p><h3 id="正式使用Webpack前的准备"><a href="#正式使用Webpack前的准备" class="headerlink" title="正式使用Webpack前的准备"></a>正式使用Webpack前的准备</h3><ol><li>创建package.json文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure></li></ol><p>项目名称和作者等信息回车即可</p><ol start="2"><li><p>package.json文件已经就绪，我们在本项目中安装Webpack作为依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 安装Webpack</span><br><span class="line">npm install --save-dev webpack</span><br></pre></td></tr></table></figure></li><li><p>创建两个文件夹,app文件夹和public文件夹，app文件夹用来存放原始数据和我们将写的JavaScript模块，public文件夹用来存放之后供浏览器读取的文件（包括使用webpack打包生成的js文件以及一个index.html文件）创建三个文件:</p></li></ol><ul><li><code>index.html</code> –放在public文件夹中;</li><li><code>Greeter.js</code>– 放在app文件夹中;</li><li><code>main.js</code>– 放在app文件夹中;</li></ul><p>此时项目结构如下图所示<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-c977d7d00f7a1ec4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构" title="">                </div>                <div class="image-caption">项目结构</div>            </figure></p><p>我们在<strong>index.html</strong>文件中写入最基础的html代码，它在这里目的在于引入打包后的js文件（这里我们先把之后打包后的js文件命名为<code>bundle.js</code>，之后我们还会详细讲述）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- index.html --&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Webpack Sample Project&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=&apos;root&apos;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>我们在Greeter.js中定义一个返回包含问候信息的html元素的函数,并依据CommonJS规范导出这个函数为一个模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Greeter.js</span><br><span class="line">module.exports = function() &#123;</span><br><span class="line">  var greet = document.createElement(&apos;div&apos;);</span><br><span class="line">  greet.textContent = &quot;Hi there and greetings!&quot;;</span><br><span class="line">  return greet;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>main.js文件中我们写入下述代码，用以把Greeter模块返回的节点插入页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//main.js </span><br><span class="line">const greeter = require(&apos;./Greeter.js&apos;);</span><br><span class="line">document.querySelector(&quot;#root&quot;).appendChild(greeter());</span><br></pre></td></tr></table></figure></p><p>根目录下新建webpack.config.js，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry:  __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件</span><br><span class="line">  output: &#123;//__dirname 是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</span><br><span class="line">    path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方</span><br><span class="line">    filename: &quot;bundle.js&quot;//打包后输出文件的文件名</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了更方面的打包，在package.json中对scripts对象进行相关设置即可，设置方法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;webpack-sample-project&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Sample webpack project&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;webpack&quot; // 修改的是这里，JSON文件不支持注释，引用时请清除</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;zhang&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;webpack&quot;: &quot;3.10.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>命令行中输入<code>npm start</code>试试<br>然后浏览器打开public/index.html<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-6493c12b502af61f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WechatIMG2.jpeg" title="">                </div>                <div class="image-caption">WechatIMG2.jpeg</div>            </figure></p><h3 id="使用webpack构建本地服务器"><a href="#使用webpack构建本地服务器" class="headerlink" title="使用webpack构建本地服务器"></a>使用webpack构建本地服务器</h3><ol><li>安装devserver<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure></li></ol><p>注意：webpack3.x的请下载webpack-dev-server2.9，不然会报错</p><ol start="2"><li><p>把这些命令加到webpack的配置文件中，现在的配置文件webpack.config.js如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  devtool: &apos;eval-source-map&apos;,</span><br><span class="line"></span><br><span class="line">  entry:  __dirname + &quot;/app/main.js&quot;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + &quot;/public&quot;,</span><br><span class="line">    filename: &quot;bundle.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录</span><br><span class="line">    historyApiFallback: true,//不跳转</span><br><span class="line">    inline: true//实时刷新</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在package.json中的scripts对象中添加如下命令，用以开启本地服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;webpack&quot;,</span><br><span class="line">    &quot;server&quot;: &quot;webpack-dev-server --open&quot;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li></ol><p>在终端中输入npm run server即可在本地的8080端口查看结果（实时刷新）<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/7072486-cb7c29cb6d2e9dff.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WechatIMG3.jpeg" title="">                </div>                <div class="image-caption">WechatIMG3.jpeg</div>            </figure></p><h2 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h2><p>鼎鼎大名的Loaders登场了！<br>Loaders是webpack提供的最激动人心的功能之一了。通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的<br><strong>Loaders可以把React的中用到的JSX文件转换为JS文件</strong><br> Loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，Loaders的配置包括以下几方面：</p><ul><li>test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）</li><li>loader：loader的名称（必须）</li><li>include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；</li><li>query：为loaders提供额外的设置选项（可选）<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3>Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：</li></ul><p>让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持；<br>让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；<br>Babel的安装与配置<br>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-env-preset包和解析JSX的babel-preset-react包）。</p><p>一次性安装这些依赖包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// npm一次性安装多个依赖模块，模块之间用空格隔开</span><br><span class="line">npm install --save-dev babel-core babel-loader babel-preset-env babel-preset-react</span><br></pre></td></tr></table></figure></p><p>Babel其实可以完全在 webpack.config.js 中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方</span><br><span class="line">        filename: &quot;bundle.js&quot;//打包后输出文件的文件名</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &apos;eval-source-map&apos;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录</span><br><span class="line">        historyApiFallback: true,//不跳转</span><br><span class="line">        inline: true//实时刷新</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /(\.jsx|\.js)$/,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: &quot;babel-loader&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                exclude: /node_modules/</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//.babelrc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为webpack4都出来了 我学的这篇是webpack3.5版本的，但是基础的东西都还是一样的，最后放上这个webpack的配置文件，如果每一项都懂的话，入门应该是没问题了。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 一个常见的`webpack`配置文件</span><br><span class="line">const webpack = require(&apos;webpack&apos;);</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">        entry: __dirname + &quot;/app/main.js&quot;, //已多次提及的唯一入口文件</span><br><span class="line">        output: &#123;</span><br><span class="line">            path: __dirname + &quot;/build&quot;,</span><br><span class="line">            filename: &quot;bundle-[hash].js&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        devtool: &apos;none&apos;,</span><br><span class="line">        devServer: &#123;</span><br><span class="line">            contentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录</span><br><span class="line">            historyApiFallback: true, //不跳转</span><br><span class="line">            inline: true,</span><br><span class="line">            hot: true</span><br><span class="line">        &#125;,</span><br><span class="line">        module: &#123;</span><br><span class="line">            rules: [&#123;</span><br><span class="line">                    test: /(\.jsx|\.js)$/,</span><br><span class="line">                    use: &#123;</span><br><span class="line">                        loader: &quot;babel-loader&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    exclude: /node_modules/</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    test: /\.css$/,</span><br><span class="line">                    use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">                        fallback: &quot;style-loader&quot;,</span><br><span class="line">                        use: [&#123;</span><br><span class="line">                            loader: &quot;css-loader&quot;,</span><br><span class="line">                            options: &#123;</span><br><span class="line">                                modules: true,</span><br><span class="line">                                localIdentName: &apos;[name]__[local]--[hash:base64:5]&apos;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, &#123;</span><br><span class="line">                            loader: &quot;postcss-loader&quot;</span><br><span class="line">                        &#125;],</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: __dirname + &quot;/app/index.tmpl.html&quot; //new 一个这个插件的实例，并传入相关的参数</span><br><span class="line">        &#125;),</span><br><span class="line">        new webpack.optimize.OccurrenceOrderPlugin(),</span><br><span class="line">        new webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">        new ExtractTextPlugin(&quot;style.css&quot;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>参考：<a href="https://www.jianshu.com/p/42e11515c10f" target="_blank" rel="noopener">https://www.jianshu.com/p/42e11515c10f</a><br>webpack中文网：<a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">https://www.webpackjs.com/concepts/</a><br>简要理解CommonJS规范：<a href="https://blog.csdn.net/u012443286/article/details/78825917" target="_blank" rel="noopener">https://blog.csdn.net/u012443286/article/details/78825917</a><br>webpack4那点东西：<a href="https://juejin.im/post/5abef5e96fb9a028e33b9035" target="_blank" rel="noopener">https://juejin.im/post/5abef5e96fb9a028e33b9035</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么使用webpack&quot;&gt;&lt;a href=&quot;#为什么使用webpack&quot; class=&quot;headerlink&quot; title=&quot;为什么使用webpack??&quot;&gt;&lt;/a&gt;为什么使用webpack??&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一句话 webpack能够提高了我们
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中基本数据类型和引用数据类型的区别</title>
    <link href="http://yoursite.com/2018/07/19/JavaScript%E4%B8%AD%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/07/19/JavaScript中基本数据类型和引用数据类型的区别/</id>
    <published>2018-07-19T12:45:23.000Z</published>
    <updated>2018-09-02T11:42:23.004Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、基本数据类型和引用数据类型</strong></p><p>　　ECMAScript包括两个不同类型的值：基本数据类型和引用数据类型。</p><p>　　基本数据类型指的是简单的数据段，引用数据类型指的是有多个值构成的对象。</p><p>　　当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值。</p><p><strong>2、常见的基本数据类型：</strong></p><p>　　Number、String 、Boolean、Null和Undefined。基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。示例：</p><p>　　var a = 10;</p><p>　　var b = a;</p><p>　　b = 20;</p><p>　　console.log(a); // 10值</p><p>　　上面，b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值。</p><p>　　<strong>b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。</strong></p><p>下图演示了这种基本数据类型赋值的过程：</p><p><strong>3、引用类型数据：</strong></p><p><strong>也就是对象类型Object type，比如：Object 、Array 、Function 、Data等。</strong> </p><p>javascript的引用数据类型是保存在堆内存中的对象。</p><p>　　与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。</p><p>　　所以，引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。</p><p>　　var obj1 = new Object();</p><p>　　var obj2 = obj1;</p><p>　　obj2.name = “我有名字了”;</p><p>　　console.log(obj1.name); // 我有名字了</p><p>　　说明这两个引用数据类型指向了同一个堆内存对象。obj1赋值给onj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2，</p><p>　　但是实际上他们共同指向了同一个堆内存对象。<strong>实际上改变的是堆内存对象。</strong></p><p>下面我们来演示这个引用数据类型赋值过程：</p><pre><code>[图片上传失败...(image-3d74f7-1531992451590)]</code></pre><p><strong>4、总结区别</strong></p><p><strong>　　a 声明变量时不同的内存分配：　</strong></p><p>　　1）原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在<strong>变量访问的位置</strong>。</p><p>　　　　这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。</p><p>　　2）引用值：存储在堆（heap）中的对象，也就是说，<strong>存储在变量处的值是一个指针（point），指向存储对象的内存地址。</strong></p><p>　　　  这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。</p><p>　　　  地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。</p><p>　　<strong>b</strong> <strong>不同的内存分配机制也带来了不同的访问机制</strong></p><p>　　1）在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，</p><p>　　　　首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的<strong>按引用访问</strong>。</p><p>　　2）而原始类型的值则是可以直接访问到的。</p><p><strong>　　c 复制变量时的不同</strong></p><p>1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，<strong>此后这两个变量是完全独立的，他们只是拥有相同的value而已。</strong></p><p>　　2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，</p><p>　　　　也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。</p><p>　　　　（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。<strong>多了一个指针</strong></p><p>　　<strong>d 参数传递的不同（</strong>把实参复制给形参的过程<strong>）</strong></p><p>　　首先我们应该明确一点：ECMAScript中所有函数的参数都<strong>是按值来传递</strong>的。</p><p>　　但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 　</p><p>　　1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。</p><p>　　2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！</p><p>　　　　因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。</p><p>参考：<a href="https://www.cnblogs.com/cxying93/p/6106469.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxying93/p/6106469.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;1、基本数据类型和引用数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　ECMAScript包括两个不同类型的值：基本数据类型和引用数据类型。&lt;/p&gt;
&lt;p&gt;　　基本数据类型指的是简单的数据段，引用数据类型指的是有多个值构成的对象。&lt;/p&gt;
&lt;p&gt;　　当我们把变
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript对象/原型链</title>
    <link href="http://yoursite.com/2018/07/19/JavaScript%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2018/07/19/JavaScript对象原型链/</id>
    <published>2018-07-19T12:45:23.000Z</published>
    <updated>2018-09-02T11:42:38.085Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对象的原型是什么？"><a href="#对象的原型是什么？" class="headerlink" title="对象的原型是什么？"></a>对象的原型是什么？</h3><p>Object是引用类型，包括：Object 、Array 、Function 、Data等。<br><strong>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。</strong></p><p>当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前（this）对象上查找该属性，如果没有找到，就到其原型对象上找(数组是Array.prototype,function是function。prototype)，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。</p><p>比如创建了一个Array对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3]</span><br></pre></td></tr></table></figure></p><p>其原型链是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr ----&gt; Array.prototype ----&gt; Object.prototype ----&gt; null</span><br></pre></td></tr></table></figure></p><p>Array.prototype定义了indexOf()、shift()等方法，因此你可以在所有的Array对象上直接调用这些方法。甚至你都可以在Array.prototype自定义方法，但是没有必要最后不要这样做。</p><p>当我们创建一个函数时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数也是一个对象 ，他的原型链是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null</span><br></pre></td></tr></table></figure></p><p>由于Function.prototype定义了apply()等方法，因此，所有函数都可以调用apply()方法。</p><h3 id="用构造函数创建对象"><a href="#用构造函数创建对象" class="headerlink" title="用构造函数创建对象"></a>用构造函数创建对象</h3><p>用函数来创建对象比直接用var = {…}创建对象要方面的多，它就是构造函数。<br>构造函数的首字母都应该大写<br>首先先创建一个构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Student(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.hello = function () &#123;</span><br><span class="line">        alert(&apos;Hello, &apos; + this.name + &apos;!&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以用关键字new来调用这个函数，并返回一个对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var xiaoming = new Student(&apos;小明&apos;);</span><br><span class="line">xiaoming.name; // &apos;小明&apos;</span><br><span class="line">xiaoming.hello(); // Hello, 小明!</span><br></pre></td></tr></table></figure></p><p>注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。</p><p>新创建的xiaoming的原型链是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xiaoming ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null</span><br></pre></td></tr></table></figure></p><p>也就是说，xiaoming的原型指向函数Student的原型。如果你又创建了xiaohong、xiaojun，那么这些对象的原型与xiaoming是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaoming ↘</span><br><span class="line">xiaohong -→ Student.prototype ----&gt; Object.prototype ----&gt; null</span><br><span class="line">xiaojun  ↗</span><br></pre></td></tr></table></figure></p><p>用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(xiaoming.constructor === Student)//true</span><br></pre></td></tr></table></figure></p><p>我们可以用instanceof来检测对象类型；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(xiaohong instanceof Object);//true</span><br><span class="line">console.log(xiaohong instanceof Student);//true</span><br><span class="line">console.log(xiaoming instanceof Object);//true</span><br><span class="line">console.log(xiaoming instanceof Student);//true</span><br></pre></td></tr></table></figure></p><p>这个例子中所创建的对象即是Object的实例 也是Student的实例，因为所有的对象都继承自Object</p><p>参考：js高程第六章<br>参考：<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997235247b53be560ab041a7b10360a567422a78000" target="_blank" rel="noopener">廖雪峰的博客</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对象的原型是什么？&quot;&gt;&lt;a href=&quot;#对象的原型是什么？&quot; class=&quot;headerlink&quot; title=&quot;对象的原型是什么？&quot;&gt;&lt;/a&gt;对象的原型是什么？&lt;/h3&gt;&lt;p&gt;Object是引用类型，包括：Object 、Array 、Function 、Da
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript零散知识整理</title>
    <link href="http://yoursite.com/2018/07/02/js%20%E9%9B%B6%E7%A2%8E/"/>
    <id>http://yoursite.com/2018/07/02/js 零碎/</id>
    <published>2018-07-02T12:45:23.000Z</published>
    <updated>2018-07-02T12:55:06.870Z</updated>
    
    <content type="html"><![CDATA[<p>call() 参考：<a href="https://blog.csdn.net/ywl570717586/article/details/52681392/" target="_blank" rel="noopener">https://blog.csdn.net/ywl570717586/article/details/52681392/</a><br>this解读参考：<a href="https://juejin.im/post/5b3715def265da59af40a630" target="_blank" rel="noopener">https://juejin.im/post/5b3715def265da59af40a630</a><br>函数传入值参考：js高程 p113</p><h3 id="快速删除尾部数组"><a href="#快速删除尾部数组" class="headerlink" title="快速删除尾部数组"></a>快速删除尾部数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,4,5];</span><br><span class="line">arr.length=3;</span><br><span class="line">console.log(arr)//[1,2,3]</span><br></pre></td></tr></table></figure><p>直接改变数组的length的值</p><h3 id="从数组中移除重复元素"><a href="#从数组中移除重复元素" class="headerlink" title="从数组中移除重复元素"></a>从数组中移除重复元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,1,2,2,3,3]</span><br><span class="line">const removeDuplicateltems = arr =&gt; [...new Set(arr)];</span><br><span class="line">console.log(removeDuplicateltems(arr))//[1,2,3]</span><br></pre></td></tr></table></figure><h3 id="函数作为值传入"><a href="#函数作为值传入" class="headerlink" title="函数作为值传入"></a>函数作为值传入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//把函数作为值传入进去</span><br><span class="line">    function callSomeFunction(someFunction,someArgument)&#123;</span><br><span class="line">      return someFunction(someArgument);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最终调用的这个函数 他有两个参数， 第一个参数是一个方法 ， 第二个参数是第一个方法的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add10(num)&#123;</span><br><span class="line">  return num + 10;</span><br><span class="line">&#125;</span><br><span class="line">var result1=callSomeFunction(add10,10);</span><br><span class="line">  console.log(result1);//20</span><br></pre></td></tr></table></figure></p><p>这个例子稍微一看就明白了吧，  传入的10 最终成了add()的参数, 也就是成了num,  所以结果是20<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function getGreeting(name)&#123;</span><br><span class="line">  return &quot;holle,&quot; + name;</span><br><span class="line">&#125;</span><br><span class="line">var result2=callSomeFunction(getGreeting, &quot;Nicholas&quot;);</span><br><span class="line">console.log(result2);//holle Nicholas</span><br></pre></td></tr></table></figure></p><p>上面的理解了  这个也就不难了  同理 “ Nicholas” 变成了getGreeting() 的参数 name，所以输出结果是 holle Nicholas</p><h3 id="call-解释"><a href="#call-解释" class="headerlink" title="call() 解释"></a>call() 解释</h3><p>先看看关于call()的官方解释，“调用一个对象的一个方法，以另一个对象替换当前对象。”，看了这样的解释，或许让你更摸不着头脑了。看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x = &quot;我是全局变量&quot;;　　　　//定义全局变量x</span><br><span class="line">function a()&#123;　　　　　　　　　//定义函数类结构a　　</span><br><span class="line">    this.x = &quot;我是在函数类结构a中声明的哦&quot;;    </span><br><span class="line">&#125;</span><br><span class="line">//定义普通函数，弹出当前指针所包含的变量x的值</span><br><span class="line">function f()&#123;       </span><br><span class="line">    alert (this.x);</span><br><span class="line">&#125;</span><br><span class="line">f.call(new a());//返回值为“我是在函数类结构a中声明的哦”</span><br></pre></td></tr></table></figure></p><p>我的理解是，f.call(new a())就是把函数（其实也是对象）f复制到被调用对象“new a()”下面去解析，事实上和下面这段代码的解析结果一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">　　this.x = &quot;我是在函数类结构a中声明的哦&quot;;</span><br><span class="line">　　alert(this.x);    //我是在函数类结构a中声明的哦</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>只不过此时变量X的作用域不同而已，咿…看起来好像有点继承的味道哦，难道不是吗？在上例中,f完全被构造函数a的实力对象继承了，如果说这还不足以说明a.call(b)是一种继承模式，那么再看一个更具有继承味道的用法吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;    </span><br><span class="line">    this.a =&quot;a&quot;;    </span><br><span class="line">    this.b = function()&#123;    </span><br><span class="line">        alert(&quot;b&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function e()&#123;    </span><br><span class="line">    f.call(this);     </span><br><span class="line">&#125;</span><br><span class="line">var c = new e();</span><br><span class="line">alert(c.a);  //弹出a</span><br><span class="line">c.b();    //弹出b</span><br></pre></td></tr></table></figure><p>在这个例子中，只要会使用浏览器的朋友，都能看得出来e完全继承了f的属性和方法，否则是无法解释的，因为在e中并没有定义属性a和b，那么按常理推断在e的实例对象c中，并不会出现这两个属性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;call() 参考：&lt;a href=&quot;https://blog.csdn.net/ywl570717586/article/details/52681392/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/ywl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Echarts (一)</title>
    <link href="http://yoursite.com/2018/06/30/Echarts%E4%B8%80/"/>
    <id>http://yoursite.com/2018/06/30/Echarts一/</id>
    <published>2018-06-30T12:45:23.000Z</published>
    <updated>2018-06-30T14:26:47.474Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Echarts.js是基于canvas 图画，可视化数据工具。</strong></p><h2 id="Echarts官方案例"><a href="#Echarts官方案例" class="headerlink" title="Echarts官方案例"></a>Echarts官方案例</h2><p>官网下载<a href="http://echarts.baidu.com/" target="_blank" rel="noopener">Echarts</a><br> 然后引入官网下载Echarts.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;ECharts 入门示例--柱状图&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;../js/echarts.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;</span><br><span class="line">   &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">   &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">       // 基于准备好的dom，初始化echarts实例</span><br><span class="line">       var myChart = echarts.init(document.getElementById(&apos;main&apos;));</span><br><span class="line"></span><br><span class="line">       // 指定图表的配置项和数据</span><br><span class="line">       var option = &#123;</span><br><span class="line">           title: &#123;</span><br><span class="line">               text: &apos;ECharts 入门示例&apos;</span><br><span class="line">               //标题</span><br><span class="line">           &#125;,</span><br><span class="line">   //工具箱</span><br><span class="line">           tooltip: &#123;</span><br><span class="line">       show: true,</span><br><span class="line">   feature:&#123;</span><br><span class="line">       saveAsImage:&#123;</span><br><span class="line">       show: true</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   //图例</span><br><span class="line">           legend: &#123;</span><br><span class="line">               data:[&apos;销量&apos;]</span><br><span class="line">           &#125;,</span><br><span class="line">           //x轴</span><br><span class="line">           xAxis: &#123;</span><br><span class="line">               data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]</span><br><span class="line">           &#125;,</span><br><span class="line">           //Y轴</span><br><span class="line">           yAxis: &#123;&#125;,</span><br><span class="line">   //数据</span><br><span class="line">           series: [&#123;</span><br><span class="line">               name: &apos;销量&apos;,</span><br><span class="line">               type: &apos;bar&apos;,</span><br><span class="line">               data: [5, 20, 36, 10, 10, 20]</span><br><span class="line">           &#125;]</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       // 使用刚指定的配置项和数据显示图表。</span><br><span class="line">       myChart.setOption(option);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>如图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p0bnwspy9.bkt.clouddn.com/Y%29XNBRN8%5DD%25@1W78XTXFA25.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>更多的配置可以看官方的<a href="http://echarts.baidu.com/option.html#title" target="_blank" rel="noopener">配置项手册</a>，每一项都有很详细的说明。</p><h2 id="异步读取数据-填充图表"><a href="#异步读取数据-填充图表" class="headerlink" title="异步读取数据 填充图表"></a>异步读取数据 填充图表</h2><p>正常来说我的图表的数据都是异步加载的 不会都是写死的 按照教程的异步加载 我的浏览器是报一个错误 大概意思就是访问的数据应该是以<code>http:</code>开头的 不然读取不到<br>需要开启一个虚拟的服务器才可以读取本地的json数据 我是用node开启了一个本地服务器。<br>参考：<a href="https://www.cnblogs.com/leoxuan/p/6513591.html" target="_blank" rel="noopener">https://www.cnblogs.com/leoxuan/p/6513591.html</a><br>本地创建了dataj.json 文件 用于储存数据,然后异步请求。<br>因为使用jquery的ajax，所以引入了一个jquery。<br>cnd使用的<a href="http://www.bootcdn.cn/" target="_blank" rel="noopener">BootCND</a> 非常好用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;ECharts ajax加载&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdn.bootcss.com/echarts/4.1.0.rc2/echarts-en.common.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;main&quot; style=&quot;width:600px;height:400px;&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    若在Chrome浏览器下 想要访问本地的data.json文件必须开起一个本地的虚拟服务器以http开头</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;a href=&quot;https://www.cnblogs.com/leoxuan/p/6513591.html&quot;&gt;原文博客地址：https://www.cnblogs.com/leoxuan/p/6513591.html&lt;/a&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    var myChart = echarts.init(document.getElementById(&apos;main&apos;));</span><br><span class="line">// 显示标题，图例和空的坐标轴</span><br><span class="line">myChart.setOption(&#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">        text: &apos;异步数据加载示例&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    tooltip: &#123;&#125;,</span><br><span class="line">    legend: &#123;</span><br><span class="line">        data:[&apos;第一年销量&apos;,&apos;第二年销量&apos;]</span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis: &#123;</span><br><span class="line">        data: []</span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis: &#123;&#125;,</span><br><span class="line">    series: [&#123;</span><br><span class="line">        name: &apos;第一年销量&apos;,</span><br><span class="line">        type: &apos;bar&apos;,</span><br><span class="line">        data: []</span><br><span class="line">    &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: &apos;第二年销量&apos;,</span><br><span class="line">        type: &apos;bar&apos;,</span><br><span class="line">        data: []</span><br><span class="line">      &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 异步加载数据</span><br><span class="line">$.get(&apos;http://localhost:8082/example/data.json&apos;).done(function (data) &#123;</span><br><span class="line">    // 填入数据</span><br><span class="line">    myChart.setOption(&#123;</span><br><span class="line">        xAxis: &#123;</span><br><span class="line">            data: data.name</span><br><span class="line">        &#125;,</span><br><span class="line">        series: [&#123;</span><br><span class="line">            // 根据名字对应到相应的系列</span><br><span class="line">            name: &apos;第一年销量&apos;,</span><br><span class="line">            data: data.data1</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">          name: &apos;第二年销量&apos;,</span><br><span class="line">          data: data.data2</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>data.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:[&quot;Android&quot;,&quot;IOS&quot;,&quot;PC&quot;,&quot;Other&quot;],&quot;data1&quot;:[420,200,360,100],&quot;data2&quot;:[460,260,390,200]&#125;</span><br></pre></td></tr></table></figure></p><p>如图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://p0bnwspy9.bkt.clouddn.com/15F%5DLE1V8%25%5BRKUWN$Y7S30A.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Echarts.js是基于canvas 图画，可视化数据工具。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Echarts官方案例&quot;&gt;&lt;a href=&quot;#Echarts官方案例&quot; class=&quot;headerlink&quot; title=&quot;Echarts官方案例&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Echarts" scheme="http://yoursite.com/tags/Echarts/"/>
    
  </entry>
  
  <entry>
    <title>js高程读书笔记（1章-5章）</title>
    <link href="http://yoursite.com/2018/06/22/js%E9%AB%98%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%881-5%EF%BC%89/"/>
    <id>http://yoursite.com/2018/06/22/js高程读书笔记（1-5）/</id>
    <published>2018-06-22T14:45:23.000Z</published>
    <updated>2018-09-02T11:42:54.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章，JavaScript简介"><a href="#第一章，JavaScript简介" class="headerlink" title="第一章，JavaScript简介"></a>第一章，JavaScript简介</h2><p>1.JavaScript包含三个部分，ECMAScript，DOM，BOM。<br>ECMAScript是JavaScript的核心，包括语法，类型，语句，关键字，保留字，操作符，对象。</p><p>２.ECMAScript提供核心语言功能。DOM提供访问和操作网页内容的方法和接口。BOM提供与浏览器交互的方法和接口。</p><p>３.DOM包含DOM１、DOM２、DOM３。</p><ul><li>DOM１由两个模块构成DOM核心和DOM HTML；</li><li>DOM２引入了DOM视图、DOM事件、DOM样式、DOM遍历和范围；</li><li>DOM３新增了验证文档的方式，并引入了已统一的方式加载和保存文档的方法。</li></ul><h2 id="第二章，在HTML中使用JavaScript"><a href="#第二章，在HTML中使用JavaScript" class="headerlink" title="第二章，在HTML中使用JavaScript"></a>第二章，在HTML中使用JavaScript</h2><p>在html中内嵌代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;holle world!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;放到body的底部&lt;/p&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      alert(&quot;holle world!&quot;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>外部引用文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;holle world!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;p&gt;放到body的底部&lt;/p&gt;</span><br><span class="line">    &lt;script src=&quot;xxx.js的路径&quot;&gt;&lt;script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h2 id="第三章，基本概念"><a href="#第三章，基本概念" class="headerlink" title="第三章，基本概念"></a>第三章，基本概念</h2><h3 id="1-ECMAScript数据类型"><a href="#1-ECMAScript数据类型" class="headerlink" title="1.  ECMAScript数据类型"></a>1.  ECMAScript数据类型</h3><p>1.1 有五种基本的数据类型：Undefined，Null，Boolean，Number，String，还有一种复杂的数据类型：Object。typeof可以确定数据类型。[ES6增加新类型：Symbol]</p><p>1.2 使用typeof操作符检测null值时会返回“object”，这是因为从逻辑角度来看null指示一个空对象指针。</p><p>1.3 Boolean类型的字面值true和false是区分大小写的。若想让其他类型的值转换为Boolean，可以调用转型函数Boolean()。</p><p>1.4 Number。八进制第一位必须是0，然后是八进制数字序列（0~7）。十六进制前两位必须是0x，后跟任何十六进制数字（0~9及A~F）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有三个函数可以把非数值转换为数值：Number(),parseInt(),parseFloat();</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>转换八进制</th><th>转换十六进制</th><th>空字符</th><th>字符串</th></tr></thead><tbody><tr><td>Number()</td><td>忽略前导0，理解为十进制</td><td>转换为相同大小的十进制</td><td>转换为0</td><td>不全为数字的字符串会转换为NaN</td></tr><tr><td>parseInt()</td><td>转换为相同大小的十进制(在函数第二位加参数8)</td><td>转换为相同大小的十进制(在函数第二位加参数16)</td><td>转换为NaN</td><td>若遇到的第一个字符是数字字符，会一直解析直到遇到第一个非数字字符为止；若遇到的第一个字符为非数字字符，转化为NaN</td></tr><tr><td>parseFloat()</td><td>忽略前导0，理解为十进制</td><td>忽略前导0x，理解为十进制,转化为0</td><td>同上</td><td>同上</td></tr></tbody></table><p>1.5 String，字符串一旦创建，它的值就不能改变!!!改变的话也只是销毁之后重新创建。</p><p>1.6 将一个值转换为字符串，可以使用toString(),Null和Undefined类型没有这个方法。数值，对象，字符串，布尔值均有这个方法。数值调用toString()方法时，可以加参数2,8,10,16，表示转化为相应进制的字符串。</p><p>1.7 Object，Object的每个实例都具有以下的属性和方法。</p><table><thead><tr><th>属性和方法名</th><th>说明</th></tr></thead><tbody><tr><td>hasOwnProperty(propertyName)</td><td>用于检查给定属性在当前对象实例（而不是实例的原型中）是否存在。eg：o.hasOwnProperty(“name”)</td></tr><tr><td>isPrototypeOf(object)</td><td>用于检查传入的对象是否是传入对象的原型</td></tr><tr><td>propertyIsEnumerable(propertyName)</td><td>用于检查给定的属性是否能够使用for-in语句来枚举</td></tr></tbody></table><h3 id="2-操作符"><a href="#2-操作符" class="headerlink" title="2.操作符"></a>2.操作符</h3><p>2.1 任何操作数与NaN进行关系比较，结果都是false。大写字母的字符编码全部小于小写字母的字符编码。</p><p>2.2 相等和不相等（== ,!=）,强制转换再比较；全等和不全等（===,!==）,仅比较而不转换。</p><p>2.3 由于ECMAScript中不存在块级作用域，因此循环内部定义的变量可以在外部访问到。</p><p>2.4 for-in语句可以用来枚举对象的属性。</p><p>2.5 break和continue，一般情况下，break语句会立即退出循环，强制执行循环后面的语句，而continue语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。但是遇到与labe标签配合使用，一般发生在循环嵌套的情况下，break会退出到label标签的位置，而continue只是会退出内部循环，执行外部循环。</p><p>2.6 可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象来访问参数数组。</p><p>2.7 ECMAScript没有重载。</p><h2 id="第四章-变量，作用域和内存问题"><a href="#第四章-变量，作用域和内存问题" class="headerlink" title="第四章 变量，作用域和内存问题"></a>第四章 变量，作用域和内存问题</h2><h3 id="1-基本类型和引用类型的值"><a href="#1-基本类型和引用类型的值" class="headerlink" title="1. 基本类型和引用类型的值"></a>1. 基本类型和引用类型的值</h3><p>1.1 ECMAScript变量可能包含两种不同类型的值：基本类型值和引用类型值，<strong>基本类型值</strong>指的是一个简单的数据段，五种基本数据类型Undifined,Null,Boolean,String,Number是<strong>按值访问</strong>的,因为可以操作保存在变量中的实际的值。<strong>引用类型</strong>的值是保存在内存中的对象，JS不允许直接访问内存中的位置，所以引用类型的值是按<strong>引用访问</strong>的。只有引用类型值可以动态地添加属性。</p><p>1.2 访问变量有按值和按引用两种方式，而<strong>参数只能按值传递</strong>。</p><p>1.3 <strong>检测类型</strong>，<strong>typeof</strong>,用于确定一个变量是字符串，数值，布尔值，对象还是Undefined的最佳工具。如果一个变量的值是Null或者是Object，则typeof都会返回“Object”。</p><p>1.4 <strong>instanceof</strong>用于确定一个值是哪种引用类型。若使用instanceof操作符检测基本类型值，则该操作符始终会返回false。</p><blockquote><p><code>alert(person instanceof Object);</code><br><code>alert(person instanceof Array);</code><br><code>alert(person instanceof RegExp);</code></p></blockquote><h3 id="2-执行环境及作用域"><a href="#2-执行环境及作用域" class="headerlink" title="2. 执行环境及作用域"></a>2. 执行环境及作用域</h3><p>2.1 在Web浏览器中，全局执行环境被认为是window对象。</p><p>2.2 在try-catch语句的catch块和with语句可以在作用域链的前端临时增加一个变量对象，会延长作用域链。</p><p>2.3 JS没有块级作用域，即在if和for语句中声明的变量，在其语句结束后不会销毁，会依旧存在于循环外部的执行环境中。</p><h3 id="3-垃圾收集"><a href="#3-垃圾收集" class="headerlink" title="3. 垃圾收集"></a>3. 垃圾收集</h3><p>3.1 JS中内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾收集机制的原理是：找出不再使用的变量，然后释放其占用的内存。具体到浏览器，一般有两种实现方法：<strong>标记清除</strong>，<strong>引用计数</strong>。</p><p>3.2 JS中最常用的垃圾收集机制是标记清除。当变量进入环境时，就将这个变量标记为“进入环境”</p><p>3.3 <strong>内存管理</strong>，使用具备垃圾收集机制的语言编写程序，开发人员一般不必担心内存管理的问题。但是分配给Web浏览器的可用内存通常要比分配给桌面应用程序的少。</p><p>3.4 优化内存的最佳方式是：让执行中的代码只保存必要的数据。一旦数据不再使用，最好将其值设置为null来释放其引用。但是，解除一个值的引用并不意味着自动回收该值所占用的内存，<strong>解除引用</strong>的真正作用是让其值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p><h2 id="第五章-引用类型"><a href="#第五章-引用类型" class="headerlink" title="第五章 引用类型"></a>第五章 引用类型</h2><p>引用类型与传统面向对象程序设计中的类类似，但实现不同。</p><h3 id="1-Object类型"><a href="#1-Object类型" class="headerlink" title="1. Object类型"></a>1. Object类型</h3><p>Object是一种基础类型，其他所有类型都从Object继承了基本的行为。</p><h3 id="2-Arrary类型"><a href="#2-Arrary类型" class="headerlink" title="2. Arrary类型"></a>2. Arrary类型</h3><p>2.1 Array类型的每一项可以保存任何类型的数据。数组的大小是可以动态调整的。</p><p>2.2 数组的length属性有个特点——它不是只读的。</p><p>2.3 <strong>检验数组</strong></p><blockquote><p>方法一：<code>value instanceof Array</code><br>方法二：<code>Array.isArray(value)</code></p></blockquote><p>2.4 <strong>转化方法</strong>：toString(),valueOf(),前者返回由数组中的每个值的字符串形式拼接而成的一个已逗号分隔的字符串。而后者还是返回的是一个数组。</p><p>2.5 <strong>栈方法</strong>和<strong>队列方法</strong>见<a href="http://blog.csdn.net/didiaidada/article/details/44243419" target="_blank" rel="noopener">这里</a>。</p><p>2.6 <strong>重排序方法</strong>：reverse()和sort(),前者只是反转数组。后者只是对字符串进行排序。若想比较大下，还得接受一个比较函数作为参数。</p><p>2.7 <strong>操作方法</strong></p><p>2.7.1 concat()方法可以基于当前数组中的所有项创建一个新数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var  colors = [&quot;red&quot;,&quot;green&quot;];</span><br><span class="line">var colors2 = colors.concat(&quot;yellow&quot;,[&quot;black&quot;,&quot;brown&quot;]);</span><br></pre></td></tr></table></figure><p>2.7.2 slice()可以基于当前数组中的一个或多个创建一个新数组。该函数接受一个或者两个参数，即要返回项的起始和结束位置。该方法返回起始和结束位置之间的项，但是不包括结束位置的项。</p><p>2.7.3 splice()的功能很强大，可以实现数组中元素的删除,插入,替换。该方法接收两个或者三个参数，起始项的位置，要删除的个数，待插入的元素。</p><p>2.8 <strong>位置方法</strong>：ECMAScript5为数组实例添加两个位置方法：indeOf()和lastIndex(),前者从数组开头开始向后查找，后者从数组的末尾开始向前查找。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。未找到的话返回-1。</p><p>2.9 <strong>迭代方法</strong></p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">解释(所有方法均运用于数组的每一项)</th></tr></thead><tbody><tr><td style="text-align:left"><code>every()</code></td><td style="text-align:left">若该函数对每一项都返回true，则返回true</td></tr><tr><td style="text-align:left"><code>filter()</code></td><td style="text-align:left">返回该函数会返回true的项组成的数组</td></tr><tr><td style="text-align:left"><code>forEach()</code></td><td style="text-align:left">无返回值</td></tr><tr><td style="text-align:left"><code>map()</code></td><td style="text-align:left">返回每次函数调用的结果组成的数组</td></tr><tr><td style="text-align:left"><code>some()</code></td><td style="text-align:left">若该函数对某一项返回true，则返回true</td></tr></tbody></table><p>2.10 <strong>归并方法</strong>：reduce()和reduceRight(),这两个函数接收四个参数：前一个值，当前值，项的索引和数组对象。</p><h3 id="3-Data类型"><a href="#3-Data类型" class="headerlink" title="3. Data类型"></a>3. Data类型</h3><p>3.1 <code>var now = new Date();</code>新创建的对象会自动获取当前的日期和时间。</p><p>3.2 如果想根据特定的日期和时间创建日期对象，必须传入该日期的毫秒数。Date.parse()和Date.UTC()可以实现。</p><p>3.3 Date.now()返回表示调用这个方法时的日期和时间的毫秒数。</p><p>3.4 <strong>日期格式化方法</strong></p><table><thead><tr><th style="text-align:left">方法</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">toDateString()</td><td>以特定实现的格式显示星期几，月，日和年</td></tr><tr><td style="text-align:left">toTimeString()</td><td>以特定于实现的格式显示时，分，秒和时区</td></tr><tr><td style="text-align:left">toLocaleDateString()</td><td>以特定于地区的格式显示星期几，月，日和年</td></tr><tr><td style="text-align:left">toLocaleTimeString()</td><td>以特定于地区的格式显示时，分，秒和时区</td></tr></tbody></table><h3 id="4-RegExp类型"><a href="#4-RegExp类型" class="headerlink" title="4. RegExp类型"></a>4. RegExp类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var expression = / pattern / flags</span><br></pre></td></tr></table></figure><p>4.1</p><table><thead><tr><th style="text-align:left">flags</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">g</td><td>即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止</td></tr><tr><td style="text-align:left">i</td><td>匹配时忽略模式与字符串的大小写</td></tr><tr><td style="text-align:left">m</td><td>表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项</td></tr></tbody></table><hr><p>4.2 RegExp对象的主要方法是<strong>exec()</strong>,该方法专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组。返回的数组包含两个额外的属性：index和input。index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。</p><p>4.3 RegExp的第二个方法是<strong>text()</strong>,他接受一个字符串参数，在模式与该参数匹配的情况下返回true，否则返回false。</p><h3 id="5-Function类型"><a href="#5-Function类型" class="headerlink" title="5.Function类型"></a>5.Function类型</h3><p>5.1 函数实际也是对象，每个函数都是Function类型的实例。<strong>函数是对象，函数名是指针。</strong></p><p>5.2 <strong>JavaScript的函数没有重载</strong></p><p>5.3 JS中即使声明函数的代码在调用它的代码后面，JS也能把函数声明提升到顶部。</p><p>5.4 在函数内部，有两个特殊的对象：arguments和this。arguments的主要用途是保存函数的参数，但是它还有一个属性名叫<strong>callee</strong>，该属性是一个指针，指向拥有该arguments对象的函数。<strong>this引用的是函数据以执行的环境对象</strong></p><p>5.5 函数的对象的属性<strong>caller</strong>这个属性保存着调用当前函数的函数的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function outer()&#123;</span><br><span class="line">    inner();</span><br><span class="line">    &#125;</span><br><span class="line">function inner()&#123;</span><br><span class="line">    alert(inner.caller);//也可以是alert(arguments.callee.caller)</span><br><span class="line">    &#125;</span><br><span class="line">outer();//会弹出outer()函数的源代码</span><br></pre></td></tr></table></figure><p>5.6 每个函数都包含两个属性：length和prototype。其中length属性表示函数希望接收的命名参数的个数。<strong>prototype是保存函数所有实例方法（toString(),valueOf()）的真正所在</strong>。</p><p>5.7 每个函数都包含两个非继承而来的方法：<strong>apply()和call(),这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this的值</strong>，实际上，传递参数并非apply()和call()真正的用武之地，它们真正的强大的地方是能够扩充函数赖以运行的作用域。详细用例请点击<a href="http://blog.csdn.net/didiaidada/article/details/45558793" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">window.color = &apos;red&apos;;</span><br><span class="line">var o = &#123; colar: &apos;blue&apos; &#125;;</span><br><span class="line"></span><br><span class="line">function sayColor()&#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">sayColor();                //red</span><br><span class="line">sayColor.call(this);       //red</span><br><span class="line">sayColor.call(window);     //red</span><br><span class="line">sayColor.call(o);          //blue</span><br></pre></td></tr></table></figure><p><strong><em>使用call()或者apply()的最大好处是：对象不需要和方法有任何耦合关系。</em></strong></p><p>5.8 ECMAScript还定义了一个方法：bind(),这个方法会创建一个函数实例，其this的值会被绑定到传给bind()函数的参数值。</p><h3 id="6-基本包装类型"><a href="#6-基本包装类型" class="headerlink" title="6. 基本包装类型"></a>6. 基本包装类型</h3><blockquote><p>为了便于操作基本类型值，ECMAScript还提供了三个特殊引用类型：Boolean，Number和String。<br>引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这就意味着我们不能再运行时为基本类型添加属性和方法。</p></blockquote><p>6.1 使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var val = &apos;25&apos;;</span><br><span class="line">var val1 = Number(val);</span><br><span class="line">alert(typeof val1);          //number</span><br><span class="line"></span><br><span class="line">var val2 = new Number(val);</span><br><span class="line">alert(typeof val2);          //object  val2中保存的是Number的实例。</span><br></pre></td></tr></table></figure><p>6.2 <strong>字符串大小写转换方法</strong>，toLowerCase(),toLocalLowerCase(),toUpperCase(),toLocalUpperCase();</p><hr><p>2015年8月28号回家，今天9月6号，昨天到学校，刚刚写了好多，但是不小心按了backspace,全删了！！！消失的部分以后有心情再写吧</p><hr><p>6.3 <code>indexOf()</code>和<code>lastIndexOf()</code>返回待查找字符在字符串中的位置。</p><p>6.4 <code>trim()</code>方法会创建一个字符串副本，删除前置及后缀的所有空格，然后返回结果。</p><p>6.5 <strong>字符串模式匹配方法</strong></p><table><thead><tr><th style="text-align:left">方法名</th><th>参数</th><th>返回值</th><th>备注</th></tr></thead><tbody><tr><td style="text-align:left"><code>match()</code></td><td>一个，正则表达式或者RegExp对象</td><td>匹配的结果构成的数组</td><td></td></tr><tr><td style="text-align:left"><code>search()</code></td><td>同上</td><td>返回字符串中第一个匹配项的索引</td><td></td></tr><tr><td style="text-align:left"><code>replace()</code></td><td>两个，第一个参数和上面的参数一样（也可以是字符串），第二参数是代替换的字符串（也可以是函数）</td><td>返回替换后的字符串</td><td></td></tr><tr><td style="text-align:left"><strong><code>split()</code></strong></td><td>两个，第一个参数可以是字符串，也可以是RegExp对象，是指定的分隔符。第二个参数用于指定数组的大小</td><td>通过字符串内包含的指定的分隔符，将字符串分割个多个子字符串，将结果返回在一个数组中</td><td>可以想象为将铅笔遮住字符串中所以与第一个参数匹配的字符，剩下没有被遮住的部分分别作为数组的每一项返回（可能包括字符串前后的空格）</td></tr><tr><td style="text-align:left"><code>localeCompare()</code></td><td>一个字符串</td><td>1（字符串参数在字母表中排在调用函数的字符串前面）；0（相等）；-1</td><td></td></tr><tr><td style="text-align:left"><code>fromCharCode()</code></td><td>一个或多个字符编码</td><td>返回对应的字符或字符串</td><td>—</td></tr></tbody></table><h3 id="7-单体内置对象"><a href="#7-单体内置对象" class="headerlink" title="7.单体内置对象"></a>7.单体内置对象</h3><p>7.1 <strong>内置对象</strong>：不必显示地实例化内置对象，因为他们已经实例化了。例如Object，Arrary，String。</p><p>7.2 <strong>单体内置对象</strong>：Globle，Math。</p><p>7.3 <strong>Globle对象</strong>：从某种意义上作为一个终极的“兜底儿对象”，事实上，没有全局变量和全局对象，所有在全局中定义的属性和方法，都是Globle对象的属性。</p><blockquote><p>URL编码方法</p><ol><li>encodeURL()和encodeURLComponent()方法可以对URL进行编码，以便发送给浏览器，有效的URL中不能包含某些字符，例如，空格。这两个方法用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。</li><li>两个方法中前者用于整个URL（一般只处理空格），后者用于URL的一段（处理所有非字母数字字符）</li><li>两个对应的解码分别为decodeURL()和decodeURLComponent()。</li></ol></blockquote><blockquote><p>eval()方法</p><p>eval()方法就像一个完整的ECMAScript解析器。</p></blockquote><blockquote><p>ECMAScript没有指出如何访问Globle()对象，但web浏览器都是将这个全局对象作为window对象的一部分加以实现。因此在全局作用域中声明的所有变量和函数，就都成了window对象的属性。</p></blockquote><p>7.4 <strong>Math()对象</strong></p><blockquote><p>Math对象的属性大都是数学计算中可能用到一些特殊值，例如：Math.PI</p></blockquote><blockquote><p>min()和max()</p><p>eg: <code>var max = Math.max(3,14,2,14);</code></p><p>eg: <code>var values = [1,2,3,4,5,6,7,8,9]; var max = Math.max.apply(Math, values); //Math作为第一个参数，从而正确的设置this的值</code></p></blockquote><blockquote><p>舍入方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;         alert(Math.ceil(25.9));</span><br><span class="line">&gt;         alert(Math.ceil(25.5));</span><br><span class="line">&gt;         alert(Math.ceil(25.1));</span><br><span class="line">&gt;         //以上均输出26</span><br><span class="line">&gt;         alert(Math.floor(25.9));</span><br><span class="line">&gt;         alert(Math.floor(25.5));</span><br><span class="line">&gt;         alert(Math.floor(25.1));</span><br><span class="line">&gt;         //以上均输出25</span><br><span class="line">&gt;         alert(Math.round(25.9));</span><br><span class="line">&gt;         alert(Math.round(25.5));</span><br><span class="line">&gt;         alert(Math.round(25.1));</span><br><span class="line">&gt;         //前两项输出26，最后一项输出25，遵循四舍五入</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Math.random()方法：返回一个大于0小于1的随机数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; function selectFrom(lowValue, upperValue)&#123;</span><br><span class="line">&gt;             var choice = upperValue - lowValue + 1;</span><br><span class="line">&gt;             return Math.floor(Math.random()*choice + lowValue);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>以上的这个 selectFrom(lowValue, upperValue)可以生成两个参数之间的任意一个随机整数。也可以用于返回数组中的任意一项。</p></blockquote><blockquote><p>其他方法<br>eg：Math.abs(num) 返回num的绝对值。</p></blockquote><p>内容出处: <a href="https://blog.csdn.net/didiaidada/article/details/48007449" target="_blank" rel="noopener">https://blog.csdn.net/didiaidada/article/details/48007449</a></p><p>因为最近也在读js高程 看了觉得总结的很好 自己也修改补充了一部分。可以没事的时候多看看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章，JavaScript简介&quot;&gt;&lt;a href=&quot;#第一章，JavaScript简介&quot; class=&quot;headerlink&quot; title=&quot;第一章，JavaScript简介&quot;&gt;&lt;/a&gt;第一章，JavaScript简介&lt;/h2&gt;&lt;p&gt;1.JavaScript包含
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="js高程读书笔记" scheme="http://yoursite.com/tags/js%E9%AB%98%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>双向数据绑定的原理</title>
    <link href="http://yoursite.com/2018/06/09/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/06/09/双向数据绑定的原理/</id>
    <published>2018-06-09T08:10:33.000Z</published>
    <updated>2018-09-02T11:43:14.416Z</updated>
    
    <content type="html"><![CDATA[<h3 id="双向数据绑定的原理"><a href="#双向数据绑定的原理" class="headerlink" title="双向数据绑定的原理"></a>双向数据绑定的原理</h3><p>在学习vue和angular过程中都有一个双向数据绑定的一个东西，vue中是v-model ,angular中是ng-model,那他们是怎么实现的，<br>先说是怎么实现的吧，自己也网上找了一下实现的方法，找到了一个比较简洁的实现方法(可能不是vue或者angular源码的实现方法)，仅自己理解的实现方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">     &lt;input type=&quot;text&quot; id=&quot;model&quot;&gt;</span><br><span class="line">     &lt;span id=&quot;bind&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>js代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        model=document.getElementById(&quot;model&quot;);</span><br><span class="line">        bind=document.getElementById(&quot;bind&quot;);</span><br><span class="line">        </span><br><span class="line">        window.onload=function()&#123;</span><br><span class="line">            model.oninput=function()&#123;</span><br><span class="line">                bind.innerHTML=model.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>定义和用法<br>oninput 事件在用户输入时触发。<br>该事件在 <code>&lt;input&gt;</code>或 <code>&lt;textarea&gt;</code>元素的值发生改变时触发。<br>提示： 该事件类似于 onchange 事件。不同之处在于 oninput 事件在元素值发生变化是立即触发， onchange 在元素失去焦点时触发。另外一点不同是 onchange 事件也可以作用于 <code>&lt;keygen&gt;</code> 和 <code>&lt;select&gt;</code> 元素。</p></blockquote><p><strong>逻辑就是使用oninput事件获取每次输入input的value的值，然后使用innerHTML赋给span</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;双向数据绑定的原理&quot;&gt;&lt;a href=&quot;#双向数据绑定的原理&quot; class=&quot;headerlink&quot; title=&quot;双向数据绑定的原理&quot;&gt;&lt;/a&gt;双向数据绑定的原理&lt;/h3&gt;&lt;p&gt;在学习vue和angular过程中都有一个双向数据绑定的一个东西，vue中是v-mo
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="angular" scheme="http://yoursite.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>在小程序中调用一言API</title>
    <link href="http://yoursite.com/2018/05/21/%E5%9C%A8%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%B0%83%E7%94%A8%E4%B8%80%E8%A8%80API/"/>
    <id>http://yoursite.com/2018/05/21/在小程序中调用一言API/</id>
    <published>2018-05-21T09:20:14.000Z</published>
    <updated>2018-09-02T11:49:18.686Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在小程序中调用一言API"><a href="#在小程序中调用一言API" class="headerlink" title="在小程序中调用一言API"></a>在小程序中调用一言API</h3><p>某一次在csdn看博客，看到了一个功能，就是可以随机显示一句话，都是特别经典的句子，后来便发挥了厚面皮的精神，就去私信问是怎么做的，二话没说那兄弟发给我一个网站，</p><p><a href="https://hitokoto.cn/" target="_blank" rel="noopener">一言</a></p><blockquote><p>这个网站是干什么的？<br>一言网(Hitokoto.cn)创立于2016年，隶属于萌创Team，目前网站主要提供一句话服务。<br>动漫也好、小说也好、网络也好，不论在哪里，我们总会看到有那么一两个句子能穿透你的心。我们把这些句子汇聚起来，形成一言网络，以传递更多的感动。如果可以，我们希望我们没有停止服务的那一天。<br>简单来说，一言指的就是一句话，可以是动漫中的台词，也可以是网络上的各种小段子。<br>或是感动，或是开心，有或是单纯的回忆。来到这里，留下你所喜欢的那一句句话，与大家分享，这就是一言存在的目的。<em></em>:本段文本源自hitokoto.us.</p></blockquote><p>在<strong><a href="https://hitokoto.cn/" target="_blank" rel="noopener">一言网</a></strong>上提供了可调用的API</p><p><a href="https://hitokoto.cn/api" target="_blank" rel="noopener">一言API接口说明</a><br>按照他给的参数和返回json数据，成功的在网页中调用了出来<br><a href="http://zhangningle.gitee.io/javascript-demo/%E4%B8%80%E8%A8%80.html" target="_blank" rel="noopener">我的一言deom</a><br>代码展示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;一言&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">      width: 500px;</span><br><span class="line">      margin: auto;</span><br><span class="line">      text-align: center;</span><br><span class="line">    &#125;</span><br><span class="line">    #hitokoto&#123;</span><br><span class="line">      font-size: 27px;</span><br><span class="line">    &#125;</span><br><span class="line">    p &#123;</span><br><span class="line">      font-size: 20px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #btn &#123;</span><br><span class="line">      padding: 15px 50px;</span><br><span class="line">      border: 0;</span><br><span class="line">      background: #00caeb;</span><br><span class="line">      color: #fff;</span><br><span class="line">      font-size: 22px;</span><br><span class="line">      border-radius: 5px;</span><br><span class="line">      cursor: pointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .cc&#123;</span><br><span class="line">      display: block;</span><br><span class="line">      text-align: right;</span><br><span class="line">      padding-right: 20px;</span><br><span class="line">      font-size: 25px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p id=&quot;hitokoto&quot;&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p class=&quot;cc&quot;&gt;『</span><br><span class="line">      &lt;span id=&quot;from&quot;&gt;&lt;/span&gt;』&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button id=&quot;btn&quot; onclick=&quot;window.location.reload();&quot;&gt;</span><br><span class="line">      换一换</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;!-- 以下写法，选取一种即可 --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 现代写法，推荐 --&gt;</span><br><span class="line">  &lt;!-- 兼容低版本浏览器 (包括 IE)，可移除 --&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;!--End--&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    fetch(&apos;https://v1.hitokoto.cn&apos;)</span><br><span class="line">      .then(function (res) &#123;</span><br><span class="line">        return res.json();</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(function (data) &#123;</span><br><span class="line">        var hitokoto = document.getElementById(&apos;hitokoto&apos;);</span><br><span class="line">        hitokoto.innerText = data.hitokoto;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(function (err) &#123;</span><br><span class="line">        console.error(err);</span><br><span class="line">      &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 老式写法，兼容性最忧 --&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    </span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&apos;get&apos;, &apos;https://v1.hitokoto.cn&apos;);</span><br><span class="line">    xhr.onreadystatechange = function () &#123;</span><br><span class="line">      if (xhr.readyState === 4) &#123;</span><br><span class="line">        var data = JSON.parse(xhr.responseText);</span><br><span class="line">        var hitokoto = document.getElementById(&apos;hitokoto&apos;);</span><br><span class="line">        var from = document.getElementById(&apos;from&apos;);</span><br><span class="line">        hitokoto.innerText = data.hitokoto;</span><br><span class="line">        from.innerText = data.from;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 新 API 方法， 十分简洁 --&gt;</span><br><span class="line">  &lt;script src=&quot;https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto&quot; defer&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>正好最近也在开发小程序，就心里痒痒。<br>想试试小程序中可不可以调用这个api，<br>小程序中</p><blockquote><p>url：这个是要请求的接口地址<br>data：一个入参<br>method：请求方式，如果是POST请求必须按上面写，默认是get请求，不用处理。<br>complete：页面请求完成后的方法，通过that.setData将数据传递给WXML页面。<br>success：页面加载成功后的执行方法。</p></blockquote><p>如图：<br><img src="http://p0bnwspy9.bkt.clouddn.com/yiyxcv.gif"><br>js代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 生命周期函数--监听页面加载</span><br><span class="line">   */</span><br><span class="line">  onLoad: function () &#123;</span><br><span class="line">    var that=this</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: &apos;https://v1.hitokoto.cn&apos;,</span><br><span class="line">      header:&#123;</span><br><span class="line">        &apos;content-type&apos;: &apos;application/json&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">      success: function (res)&#123;</span><br><span class="line">        console.log(res.data)</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">          list: res.data</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>看完这个代码，你会想，根据微信小程序的绑定原理，这里边的代码哪里调用了onLoad（）这个函数，不用多想，微信小程序给你省略了这些步骤。直接调用list这个数组就行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;在小程序中调用一言API&quot;&gt;&lt;a href=&quot;#在小程序中调用一言API&quot; class=&quot;headerlink&quot; title=&quot;在小程序中调用一言API&quot;&gt;&lt;/a&gt;在小程序中调用一言API&lt;/h3&gt;&lt;p&gt;某一次在csdn看博客，看到了一个功能，就是可以随机显示一句
      
    
    </summary>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
      <category term="json" scheme="http://yoursite.com/tags/json/"/>
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>jquery-ajax调用showAPI(历史上的今天)的接口</title>
    <link href="http://yoursite.com/2018/05/14/jquery-json%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/05/14/jquery-json调用接口/</id>
    <published>2018-05-14T09:20:14.000Z</published>
    <updated>2018-09-02T11:49:42.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="jquery-json调用接口"><a href="#jquery-json调用接口" class="headerlink" title="jquery-json调用接口"></a>jquery-json调用接口</h3><p>回顾一次面试经历，有一次面试人家问我会不会使用后端的接口（API）<br>因为当时学的都是写的静态页面 所以自然不知了，虽然那次面试很糟糕，但是收获也是很多的。<br>面试官后来告诉我一个网站就是这个网站：<a href="https://www.showapi.com/" target="_blank" rel="noopener">showAPI</a>;<br>上面有很多的免费的API接口可以试着调用 ，很感谢那位面试我的大佬。<br>今天有时间就顺便试了一下，调用了一个API “历史上的今天”<br>使用的jQuery解析的发送的ajax请求，然后他的服务器会返回一个json数据，使用  <code>$.each</code>在循环解析到页面中，虽然很小的一个小练习，但是对前后端数据交互有个更深的理解，<br>可能对于大家来说还是挺lou的 ，但对我自己来说确实很大的进步了。不喜勿喷。</p><p>先放预览地址吧：<a href="http://zhangningle.gitee.io/javascript-demo/%E5%8E%86%E5%8F%B2%E4%B8%8A%E7%9A%84%E4%BB%8A%E5%A4%A9.html" target="_blank" rel="noopener">历史上的今天</a></p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function Jdeta() &#123;</span><br><span class="line">           //alert(typeof dataNum)</span><br><span class="line">           $.ajax(&#123;</span><br><span class="line">               type: &apos;post&apos;,</span><br><span class="line">               url: &apos;http://route.showapi.com/119-42&apos;,</span><br><span class="line">               dataType: &apos;json&apos;,</span><br><span class="line">               data: &#123;</span><br><span class="line">                   &quot;showapi_timestamp&quot;: formatterDateTime(),</span><br><span class="line">                   &quot;showapi_appid&quot;: &apos;61967&apos;, //这里需要改成自己的appid</span><br><span class="line">                   &quot;showapi_sign&quot;: &apos;efc7d95dafb14c9dabf3867072d12b28&apos;,  //这里需要改成自己的应用的密钥secret</span><br><span class="line">                   &quot;date&quot;: &quot;&quot;</span><br><span class="line">               &#125;,</span><br><span class="line">               error: function (XmlHttpRequest, textStatus, errorThrown) &#123;</span><br><span class="line">                   alert(&quot;操作失败!&quot;);</span><br><span class="line">               &#125;,</span><br><span class="line">               success: function (result) &#123;</span><br><span class="line">                   console.log(result) //console变量在ie低版本下不能用</span><br><span class="line">                   //alert(result.showapi_res_code + &quot;调用成功&quot;)</span><br><span class="line">                   var title = document.getElementById(&quot;title&quot;);</span><br><span class="line">                   title.innerHTML = result.showapi_res_body.list[0].title;</span><br><span class="line">                   var img = document.getElementById(&quot;img&quot;);</span><br><span class="line">                   img.src = result.showapi_res_body.list[0].img;</span><br><span class="line">                   var day = document.getElementById(&quot;day&quot;);</span><br><span class="line">                   day.innerHTML = result.showapi_res_body.list[0].day;</span><br><span class="line">                   var month = document.getElementById(&quot;month&quot;);</span><br><span class="line">                   month.innerHTML = result.showapi_res_body.list[0].month;</span><br><span class="line">                   var year = document.getElementById(&quot;year&quot;);</span><br><span class="line">                   year.innerHTML = result.showapi_res_body.list[0].year;</span><br><span class="line">                   var json = eval(result.showapi_res_body.list); //数组     </span><br><span class="line">                   var result = &quot;&quot;;</span><br><span class="line">                   $.each(json, function (index) &#123;</span><br><span class="line">                       //循环获取数据    </span><br><span class="line">                       var title = json[index].title;</span><br><span class="line">                       var year = json[index].year;</span><br><span class="line">                       var month = json[index].month;</span><br><span class="line">                       var day = json[index].day;</span><br><span class="line">                       var img = json[index].img</span><br><span class="line">                       result += &quot;标题：&quot;+title +&quot;&lt;br/&gt;时间：&quot;+ year + &quot;年-&quot; + month + &quot;月-&quot; + day + &quot;日&lt;br/&gt;&lt;img src=&quot;+img+&quot; alt/&gt;&quot;+&quot;&lt;br&gt;&lt;br&gt;&quot;;</span><br><span class="line">                   &#125;);</span><br><span class="line">                   $(&quot;#list&quot;).html(&apos;&apos;);</span><br><span class="line">                   $(&quot;#list&quot;).html(result);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;jquery-json调用接口&quot;&gt;&lt;a href=&quot;#jquery-json调用接口&quot; class=&quot;headerlink&quot; title=&quot;jquery-json调用接口&quot;&gt;&lt;/a&gt;jquery-json调用接口&lt;/h3&gt;&lt;p&gt;回顾一次面试经历，有一次面试人家问我
      
    
    </summary>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
      <category term="json" scheme="http://yoursite.com/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>vue笔记一</title>
    <link href="http://yoursite.com/2018/04/24/vue001/"/>
    <id>http://yoursite.com/2018/04/24/vue001/</id>
    <published>2018-04-24T11:20:14.000Z</published>
    <updated>2018-09-02T11:45:51.126Z</updated>
    
    <content type="html"><![CDATA[<p>一、vue的基本概念<br>          1.同jquery，都是js框架<br>          2.jquery更适合做页面(网页效果)，vue更适合做web应用(博客，论坛)<br>          3.jquery同原生js一样，都需要操作繁琐的Dom元素，而vue简化了Dom操作<br>          vue的一个缺点：不支持IE8 safari 还有一些手机<br>  案例:使用原生js和vue操作元素的一个区别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.原生js </span><br><span class="line">      &lt;h1 id=&apos;h1&apos;&gt;&lt;/h1&gt; </span><br><span class="line">     &lt;script&gt;</span><br><span class="line">     document.querySelector(&apos;#h1&apos;).innerHTML=&apos;你好世界&apos;;</span><br><span class="line">     &lt;/script&gt;</span><br><span class="line">           &lt;div id=&apos;itany&apos;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; </span><br><span class="line">            &lt;script src=&apos;vue.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">            &lt;script&gt;</span><br><span class="line">            new Vue(&#123;</span><br><span class="line">                    el:&apos;#itany&apos;,</span><br><span class="line">                     data:&#123;</span><br><span class="line">                      message:&apos;你好世界&apos;</span><br><span class="line">                      &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!-- </span><br><span class="line">               注：使用&#123;&#123;&#125;&#125;就相当于解析变量</span><br><span class="line">             --&gt;</span><br><span class="line">            &lt;hr&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、vue的基本概念&lt;br&gt;          1.同jquery，都是js框架&lt;br&gt;          2.jquery更适合做页面(网页效果)，vue更适合做web应用(博客，论坛)&lt;br&gt;          3.jquery同原生js一样，都需要操作繁琐的Dom元素
      
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>小程序学习记录二</title>
    <link href="http://yoursite.com/2018/04/06/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/04/06/小程序学习记录二/</id>
    <published>2018-04-06T12:20:14.000Z</published>
    <updated>2018-06-10T08:43:40.665Z</updated>
    
    <content type="html"><![CDATA[<p>在写小程序的过程中会发现里面的有些使用和vue很相似，有相关基础上手并不是很难，难点主要在于js的逻辑交互，</p><h2 id="小程序的启动"><a href="#小程序的启动" class="headerlink" title="小程序的启动"></a>小程序的启动</h2><p>微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。</p><p>紧接着通过 app.json 的 pages 字段就可以知道你当前小程序的所有页面路径:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;  &quot;pages&quot;:[    &quot;pages/index/index&quot;,    &quot;pages/logs/logs&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个配置说明在 QuickStart 项目定义了两个页面，分别位于 pages/index/index 和 pages/logs/logs 目录。而写在 pages 字段的第一个页面就是这个小程序的首页(打开小程序看到的第一个页面)。</p><p>于是微信客户端就把首页的代码装载进来，通过小程序底层的一些机制，就可以渲染出这个首页。</p><p>小程序启动之后，在 app.js 定义的 App 实例的 onLaunch 回调会被执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">  onLaunch: function () &#123;    // 小程序启动之后 触发</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>整个小程序只有一个 App 实例，是全部页面共享的，更多的事件回调参考文档 注册程序 App 。</p><p>接下来我们简单看看小程序的一个页面是怎么写的。</p><p>程序与页面</p><p>你可以观察到 pages/logs/logs 下其实是包括了4种文件的，微信客户端会先根据 logs.json 配置生成一个界面，顶部的颜色和文字你都可以在这个 json 文件里边定义好。紧接着客户端就会装载这个页面的 WXML 结构和 WXSS 样式。最后客户端会装载 logs.js，你可以看到 logs.js 的大体内容就是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  data: &#123; // 参与页面渲染的数据</span><br><span class="line">    logs: []</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: function () &#123;    // 页面渲染后 执行</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>Page 是一个页面构造器，这个构造器就生成了一个页面。在生成页面的时候，小程序框架会把 data 数据和 index.wxml 一起渲染出最终的结构，于是就得到了你看到的小程序的样子。</p><p>在渲染完界面之后，页面实例就会收到一个 onLoad 的回调，你可以在这个回调处理你的逻辑。</p><p>有关于 Page 构造器更多详细的文档参考 注册页面 Page 。</p><p>组件</p><p>小程序提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼合成自己的小程序。</p><p>就像 HTML 的 div, p 等标签一样，在小程序里边，你只需要在 WXML 写上对应的组件标签名字就可以把该组件显示在界面上，例如，你需要在界面上显示地图，你只需要这样写即可：</p><p><map>map&gt;<br>使用组件的时候，还可以通过属性传递值给组件，让组件可以以不同的状态去展现，例如，我们希望地图一开始的中心的经纬度是广州，那么你需要声明地图的 longitude(中心经度) 和 latitude(中心纬度) 两个属性:</map></p><p><map longitude="广州经度" latitude="广州纬度">map&gt;<br>组件的内部行为也会通过事件的形式让开发者可以感知，例如用户点击了地图上的某个标记，你可以在 js 编写 markertap 函数来处理：</map></p><p><map bindmarkertap="markertap" longitude="广州经度" latitude="广州纬度">map&gt;<br>当然你也可以通过 style 或者 class 来控制组件的外层样式，以便适应你的界面宽度高度等等。</map></p><p>需要注意的是：多数 API 的回调都是异步，你需要处理好代码逻辑的异步问题。</p><p>更多的 API 能力见 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/?t=20171227" target="_blank" rel="noopener">小程序的API</a> 。<br>其实小程序的官网教程讲的也很明白透彻，看官方教程就可以了，而且小程序有丰富的组件，使用时很方便的，<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://mp.weixin.qq.com/debug/wxadoc/dev/image/demo.png?t=201842" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>更多的组件可以参考 小程序的组件 。</p><h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h2><p>为了让开发者可以很方便的调起微信提供的能力，例如获取用户信息、微信支付等等，小程序提供了很多 API 给开发者去使用。</p><p>要获取用户的地理位置时，只需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wx.getLocation(&#123;</span><br><span class="line">  type: &apos;wgs84&apos;,</span><br><span class="line">  success: (res) =&gt; &#123;    var latitude = res.latitude // 经度</span><br><span class="line">    var longitude = res.longitude // 纬度</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>调用微信扫一扫能力，只需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wx.scanCode(&#123;</span><br><span class="line">  success: (res) =&gt; &#123;    console.log(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。</p><p>什么是组件：</p><p>组件是视图层的基本组成单元。<br>组件自带一些功能与微信风格的样式。<br>一个组件通常包括开始标签和结束标签，属性用来修饰这个组件，内容在两个标签之内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;tagname property=&quot;value&quot;&gt;</span><br><span class="line">  Content goes here ...</span><br><span class="line">&lt;/tagname&gt;</span><br></pre></td></tr></table></figure></p><p>注意：所有组件与属性都是小写，以连字符-连接</p><p>属性类型</p><p>类型    描述    注解<br>Boolean    布尔值    组件写上该属性，不管该属性等于什么，其值都为true，只有组件上没有写该属性时，属性值才为false。如果属性值为变量，变量的值会被转换为Boolean类型<br>Number    数字    1, 2.5<br>String    字符串    “string”<br>Array    数组    [ 1, “string” ]<br>Object    对象    { key: value }<br>EventHandler    事件处理函数名    “handlerName” 是 Page中定义的事件处理函数名<br>Any    任意属性<br>共同属性类型</p><p>所有组件都有的属性：</p><p>属性名    类型    描述    注解<br>id    String    组件的唯一标示    保持整个页面唯一<br>class    String    组件的样式类    在对应的 WXSS 中定义的样式类<br>style    String    组件的内联样式    可以动态设置的内联样式<br>hidden    Boolean    组件是否显示    所有组件默认显示<br>data-<em>    Any    自定义属性    组件上触发的事件时，会发送给事件处理函数<br>bind</em> / catch*    EventHandler    组件的事件    详见事件<br>特殊属性</p><p>几乎所有组件都有各自定义的属性，可以对该组件的功能或样式进行修饰，请参考各个组件的定义。</p><p>视图容器(View Container)：<br>view    视图容器<br>scroll-view    可滚动视图容器</p><h2 id="swiper-滑块视图容"><a href="#swiper-滑块视图容" class="headerlink" title="swiper    滑块视图容"></a>swiper    滑块视图容</h2><p>基础内容(Basic Content)：<br>icon    图标<br>text    文字</p><h2 id="progress-进度条"><a href="#progress-进度条" class="headerlink" title="progress    进度条"></a>progress    进度条</h2><p>表单(Form)：<br>button    按钮<br>form    表单<br>input    输入框<br>checkbox    多项选择器<br>radio    单项选择器<br>picker    列表选择器<br>picker-view    内嵌列表选择器<br>slider    滚动选择器<br>switch    开关选择器</p><h2 id="label-标签"><a href="#label-标签" class="headerlink" title="label    标签"></a>label    标签</h2><p>导航(Navigation)：</p><h2 id="navigator-应用链接"><a href="#navigator-应用链接" class="headerlink" title="navigator    应用链接"></a>navigator    应用链接</h2><p>多媒体(Media)：<br>audio    音频<br>image    图片</p><h2 id="video-视频"><a href="#video-视频" class="headerlink" title="video    视频"></a>video    视频</h2><p>地图(Map)：</p><h2 id="map-地图"><a href="#map-地图" class="headerlink" title="map    地图"></a>map    地图</h2><p>画布(Canvas)：<br>canvas    画布</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在写小程序的过程中会发现里面的有些使用和vue很相似，有相关基础上手并不是很难，难点主要在于js的逻辑交互，&lt;/p&gt;
&lt;h2 id=&quot;小程序的启动&quot;&gt;&lt;a href=&quot;#小程序的启动&quot; class=&quot;headerlink&quot; title=&quot;小程序的启动&quot;&gt;&lt;/a&gt;小程序的启动
      
    
    </summary>
    
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="微信" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>华强北商城</title>
    <link href="http://yoursite.com/2018/04/01/%E5%8D%8E%E5%BC%BA%E5%8C%97%E5%95%86%E5%9F%8E/"/>
    <id>http://yoursite.com/2018/04/01/华强北商城/</id>
    <published>2018-04-01T09:20:14.000Z</published>
    <updated>2018-06-10T08:42:22.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="华强北商城电子商务网站"><a href="#华强北商城电子商务网站" class="headerlink" title="华强北商城电子商务网站"></a>华强北商城电子商务网站</h2><p>github地址：<a href="https://github.com/AnsonZnl/HuaQiangBei" target="_blank" rel="noopener">https://github.com/AnsonZnl/HuaQiangBei</a><br>模板文件放在织梦cms的theme下，然后导入数据库即可。<br>主要功能有：</p><ol><li>搜索，</li><li>添加购物车</li><li>后天管理商品</li><li>js轮播图和css3特效。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;华强北商城电子商务网站&quot;&gt;&lt;a href=&quot;#华强北商城电子商务网站&quot; class=&quot;headerlink&quot; title=&quot;华强北商城电子商务网站&quot;&gt;&lt;/a&gt;华强北商城电子商务网站&lt;/h2&gt;&lt;p&gt;github地址：&lt;a href=&quot;https://github.c
      
    
    </summary>
    
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
      <category term="织梦cms" scheme="http://yoursite.com/tags/%E7%BB%87%E6%A2%A6cms/"/>
    
      <category term="cms" scheme="http://yoursite.com/tags/cms/"/>
    
      <category term="后台" scheme="http://yoursite.com/tags/%E5%90%8E%E5%8F%B0/"/>
    
      <category term="电商" scheme="http://yoursite.com/tags/%E7%94%B5%E5%95%86/"/>
    
  </entry>
  
  <entry>
    <title>fixe 布局</title>
    <link href="http://yoursite.com/2018/04/01/fixe%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/04/01/fixe布局/</id>
    <published>2018-04-01T09:20:14.000Z</published>
    <updated>2018-09-02T11:46:43.250Z</updated>
    
    <content type="html"><![CDATA[<p>寻根溯源话布局<br>一切都始于这样一个问题：怎样通过 CSS 简单而优雅的实现水平、垂直同时居中。记得刚开始学习 CSS 的时候，看到 float 属性不由得感觉眼前一亮，顺理成章的联想到 Word 文档排版中用到的的左对齐、右对齐和居中对齐，然而很快就失望的发现 CSS 中并不存在 float: center 的写法，那么 text-align: center、verticle-align: center 是否可行呢？答案也是否定的。这两个属性只能用于行内元素，对于块级元素的布局是无效的。<br>在网页布局没有进入 CSS 的时代，排版几乎是通过 table 元素实现的，在 table 的单元格里可以方便的使用 align、valign 来实现水平和垂直方向的对齐，随着 Web 语义化的流行，这些写法逐渐淡出了视野，CSS 标准为我们提供了 3 种布局方式：标准文档流、浮动布局和定位布局。这几种方式的搭配使用可以轻松搞定 PC 端页面的常见需求，比如实现水平居中可以使用 margin: 0 auto，实现水平垂直同时居中可以如下设置：<br>.dad {<br>    position: relative;<br>}<br>.son {<br>    position: absolute;<br>    margin: auto;<br>    top: 0;<br>    right: 0;<br>    bottom: 0;<br>    left: 0;<br>}<br>.dad {<br>    position: relative;<br>}<br>.son {<br>    width: 100px;<br>    height: 100px;<br>    position: absolute;<br>    top: 50%;<br>    left: 50%;<br>    margin-top: -50px;<br>    margin-left: -50px;<br>}<br>然而，这些写法都存在一些缺陷：缺少语义并且不够灵活。我们需要的是通过 1 个属性就能优雅的实现子元素居中或均匀分布，甚至可以随着窗口缩放自动适应。在这样的需求下，CSS 的第 4 种布局方式诞生了，这就是我们今天要重点介绍的 flex 布局。<br>flex 基本概念<br>使用 flex 布局首先要设置父容器 display: flex，然后再设置 justify-content: center 实现水平居中，最后设置 align-items: center 实现垂直居中。</p><p>#dad {<br>    display: flex;<br>    justify-content: center;<br>    align-items: center<br>}</p><p>就是这么简单，大功告成。等等，好像哪里不对，justify-content 和 align-items 是啥？哪里可以看出横向、竖向的语义？是的，flex 的确没有那么简单，这就要从两个基本概念说起了。</p><p>说来也不难，flex 的核心的概念就是 容器 和 轴。容器包括外层的 父容器 和内层的 子容器，轴包括 主轴 和 交叉轴，可以说 flex 布局的全部特性都构建在这两个概念上。flex 布局涉及到 12 个 CSS 属性（不含 display: flex），其中父容器、子容器各 6 个。不过常用的属性只有 4 个，父容器、子容器各 2 个，我们就先从常用的说起吧。<br>容器<br>容器具有这样的特点：父容器可以统一设置子容器的排列方式，子容器也可以单独设置自身的排列方式，如果两者同时设置，以子容器的设置为准。</p><p>父容器<br>设置子容器沿主轴排列：justify-content<br>justify-content 属性用于定义如何沿着主轴方向排列子容器。</p><p>flex-start：起始端对齐</p><p>flex-end：末尾段对齐</p><p>center：居中对齐</p><p>space-around：子容器沿主轴均匀分布，位于首尾两端的子容器到父容器的距离是子容器间距的一半。</p><p>space-between：子容器沿主轴均匀分布，位于首尾两端的子容器与父容器相切。</p><p>设置子容器如何沿交叉轴排列：align-items<br>align-items 属性用于定义如何沿着交叉轴方向分配子容器的间距。</p><p>flex-start：起始端对齐</p><p>flex-end：末尾段对齐</p><p>center：居中对齐</p><p>baseline：基线对齐，这里的 baseline 默认是指首行文字，即 first baseline，所有子容器向基线对齐，交叉轴起点到元素基线距离最大的子容器将会与交叉轴起始端相切以确定基线。</p><p>stretch：子容器沿交叉轴方向的尺寸拉伸至与父容器一致。</p><p>子容器<br>在主轴上如何伸缩：flex</p><p>子容器是有弹性的（flex 即弹性），它们会自动填充剩余空间，子容器的伸缩比例由 flex 属性确定。<br>flex 的值可以是无单位数字（如：1, 2, 3），也可以是有单位数字（如：15px，30px，60px），还可以是 none 关键字。子容器会按照 flex 定义的尺寸比例自动伸缩，如果取值为 none 则不伸缩。<br>虽然 flex 是多个属性的缩写，允许 1 – 3 个值连用，但通常用 1 个值就可以满足需求，它的全部写法可参考下图。</p><p>单独设置子容器如何沿交叉轴排列：align-self</p><p>每个子容器也可以单独定义沿交叉轴排列的方式，此属性的可选值与父容器 align-items 属性完全一致，如果两者同时设置则以子容器的 align-self 属性为准。<br>flex-start：起始端对齐</p><p>flex-end：末尾段对齐</p><p>center：居中对齐</p><p>baseline：基线对齐</p><p>stretch：拉伸对齐</p><p>轴<br>如图所示，轴 包括 主轴 和 交叉轴，我们知道 justify-content 属性决定子容器沿主轴的排列方式，align-items 属性决定子容器沿着交叉轴的排列方式。那么轴本身又是怎样确定的呢？在 flex 布局中，flex-direction 属性决定主轴的方向，交叉轴的方向由主轴确定。</p><p>主轴<br>主轴的起始端由 flex-start 表示，末尾段由 flex-end 表示。不同的主轴方向对应的起始端、末尾段的位置也不相同。<br>向右：flex-direction: row</p><p>向下：flex-direction: column</p><p>向左：flex-direction: row-reverse</p><p>向上：flex-direction: column-reverse</p><p>交叉轴<br>主轴沿逆时针方向旋转 90° 就得到了交叉轴，交叉轴的起始端和末尾段也由 flex-start 和 flex-end 表示。<br>上面介绍的几项属性是 flex 布局中最常用到的部分，一般来说可以满足大多数需求，如果实现复杂的布局还需要深入了解更多的属性。<br>flex 进阶概念<br>父容器设置换行方式：flex-wrap<br>决定子容器是否换行排列，不但可以顺序换行而且支持逆序换行。</p><p>nowrap：不换行</p><p>wrap：换行</p><p>wrap-reverse：逆序换行<br>逆序换行是指沿着交叉轴的反方向换行。</p><p>轴向与换行组合设置：flex-flow<br>flow 即流向，也就是子容器沿着哪个方向流动，流动到终点是否允许换行，比如 flex-flow: row wrap，flex-flow 是一个复合属性，相当于 flex-direction 与 flex-wrap 的组合，可选的取值如下：<br>1、row、column 等，可单独设置主轴方向<br>2、wrap、nowrap 等，可单独设置换行方式<br>3、row nowrap、column wrap 等，也可两者同时设置<br>多行沿交叉轴对齐：align-content<br>当子容器多行排列时，设置行与行之间的对齐方式。</p><p>flex-start：起始端对齐</p><p>flex-end：末尾段对齐</p><p>center：居中对齐</p><p>space-around：等边距均匀分布</p><p>space-between：等间距均匀分布</p><p>stretch：拉伸对齐</p><p>子容器设置基准大小：flex-basis<br>flex-basis 表示在不伸缩的情况下子容器的原始尺寸。主轴为横向时代表宽度，主轴为纵向时代表高度。</p><p>设置扩展比例：flex-grow<br>子容器弹性伸展的比例。如图，剩余空间按 1:2 的比例分配给子容器。</p><p>设置收缩比例：flex-shrink<br>子容器弹性收缩的比例。如图，超出的部分按 1:2 的比例从给子容器中减去。</p><p>设置排列顺序：order<br>改变子容器的排列顺序，覆盖 HTML 代码中的顺序，默认值为 0，可以为负值，数值越小排列越靠前。</p><p>以上就是 flex 布局的全部属性，一共 12 个，父容器、子容器各 6 个，可以随时通过下图进行回顾。</p><p>参考资料：<br>MDN: CSS Flexible Box LayoutFlex 布局教程：语法篇Flex 布局学习笔记30 分钟学会 Flex 布局弹性盒模型Flex指南原文地址：<a href="https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb" target="_blank" rel="noopener">https://juejin.im/post/58e3a5a0a0bb9f0069fc16bb</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;寻根溯源话布局&lt;br&gt;一切都始于这样一个问题：怎样通过 CSS 简单而优雅的实现水平、垂直同时居中。记得刚开始学习 CSS 的时候，看到 float 属性不由得感觉眼前一亮，顺理成章的联想到 Word 文档排版中用到的的左对齐、右对齐和居中对齐，然而很快就失望的发现 CSS
      
    
    </summary>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>bootrtsp常用的类</title>
    <link href="http://yoursite.com/2018/03/21/bootrtsp4/"/>
    <id>http://yoursite.com/2018/03/21/bootrtsp4/</id>
    <published>2018-03-21T09:20:14.000Z</published>
    <updated>2018-06-10T08:37:31.819Z</updated>
    
    <content type="html"><![CDATA[<p>Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷<br>使用它可以快速开发一个适应手机、平板、电脑的网站，<br>比如我的<br>法标珠光卫浴  <a href="http://zhangningle.gitee.io/fabiaozhuguangweiyv/" target="_blank" rel="noopener">http://zhangningle.gitee.io/fabiaozhuguangweiyv/</a><br><br><br>手机显示：<br><img src="http://p0bnwspy9.bkt.clouddn.com/%7DK3U_6LDR5QMILUN%5BGIW9NJ.png" alt="法标珠光卫浴" style="width:75%;" class="about_img"><br>电脑显示：<br><img src="http://p0bnwspy9.bkt.clouddn.com/LX6N$A@_FRZYV4%5B0%25K5IV_5.jpg" alt="法标珠光卫浴" style="width:100%;" class="about_img"></p><p>bootstrap常用类记录：<br>记录一下bootrtsp常用的类，下次使用方便快速查阅！<br>1.起步<br>2.全局css样式<br>    1)按钮相关class<br>     .btn                按钮基础样式<br>     .btn-danger         红色按钮<br>     .btn-warming        黄色按钮<br>     .btn-success        绿色按钮<br>     .btn-info           浅蓝色按钮<br>     .btn-primary        深蓝色按钮<br>     .btn-lg             大号按钮<br>     .btn-sm             小号按钮<br>     .btn-xs             超小号按钮<br>     .btn-block          块级按钮<br>    注：用button写按钮时，必须要写type属性</p><pre><code>2)图片相关class  .img-circle        圆形图片  .img-rounded       圆角图片  .img-thumbnail     缩略图片  .img-responsive    响应式图片3)文本相关class  .text-danger/warming/success/info/primary   文本的5种颜色  .bg-danger/warming/success/info/primary     5种背景颜色  .text-uppercase    转大写  .text-lowercase    转小写  .text-capitalize   转首字母大写  .text-left         文本左对齐  .text-right        文本右对齐  .text-center       文本居中对齐  .text-justify      两端调整对齐4)辅助类   .caret            三角符号   .close            关闭按钮   .pull-left        左浮动   .pull-right       右浮动5)表格（小重点）    .table           基础表格    .table-borderd   带边框的表格    .table-striped   隔行变色的表格    .table-hover     带鼠标悬停效果的表格    .table-responsive  响应式表格，必须使用在table的父元素div上    注：.table-responsive的正确使用方法。如果想让某一行或某一列变背景，直接在tr或td上加class属性即可6)栅格布局系统(重点)    a.最外层必须是容器类.container或.container-fluid    b.容器中必须放置行:.row    c.行中必须放置列:.col    &lt;div class=&apos;container&apos;&gt;        &lt;div class=&apos;row&apos;&gt;            &lt;div class=&apos;col-md-3 col-sm-6 col-xs-12&apos;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    针对不同的屏幕有不同的列    .col-lg-*          适用于超大pc屏幕    .col-md-*          适用于中等pc屏幕    .col-sm-*          适用于pad屏幕    .col-xs-*          适用于phone屏幕    .col-md-offset-1/2/3....     pc屏幕中向右偏移多少个    .col-sm-offset-1/2/3....     pad屏幕中向右偏移多少个    .col-xs-offset-1/2/3....     phone屏幕中向右偏移多少个    不同的列在不同屏幕下哟不同的适用性    .col-lg-*                     只适用于lg屏幕    .col-md-*                     适用于lg/md屏幕    .col-sm-*                     适用于lg/md/sm屏幕    .col-xs-*                     适用于lg/md/sm/xs屏幕    可以指定某列在特定尺寸的屏幕下隐藏    .hidden-lg                    在lg屏幕下隐藏    .hidden-md                    在md屏幕下隐藏    .hidden-sm                    在sm屏幕下隐藏    .hidden-xs                    在xs屏幕下隐藏    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;row&quot;&gt;            &lt;div class=&quot;col-xs-6&quot;&gt;                &lt;div class=&quot;row&quot;&gt;                    &lt;div class=&quot;col-xs-6&quot;&gt;&lt;/div&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;7)表单(难点)    a.默认表单        &lt;form&gt;            &lt;div class=&quot;form-group&quot;&gt;                &lt;label&gt;用户名&lt;/label&gt;                &lt;input class=&quot;form-control&quot;&gt;                &lt;span class=&quot;help-block&quot;&gt;用户名可以包含数字，字母和下划线&lt;/span&gt;            &lt;/div&gt;        &lt;/form&gt;    b.行内表单        &lt;form class=&apos;form-inline&apos;&gt;            &lt;div class=&apos;form-group&apos;&gt;                &lt;label class=&apos;sr-only&apos;&gt;用户名&lt;/label&gt;                &lt;input class=&apos;form-control&apos; placeholder=&quot;请输入用户名&quot;&gt;            &lt;/div&gt;        &lt;/form&gt;        注：.sr-only是 除了屏幕阅读器外，其他设备上隐藏该元素，这个是用于屏幕阅读器的，帮助残障人士更好的访问网站。    c.水平表单(难点)        &lt;form class=&apos;form-horizontal&apos;&gt;            &lt;div class=&apos;form-group&apos;&gt;                &lt;div class=&apos;col-**-**&apos;&gt;                    &lt;label&gt;用户名&lt;/label&gt;                &lt;/div&gt;                &lt;div class=&apos;col-**-**&apos;&gt;                    &lt;input class=&apos;form-control&apos;&gt;                &lt;/div&gt;                &lt;div class=&apos;col-**-**&apos;&gt;                    &lt;span class=&quot;help-block&quot;&gt;用户名可以包含数字字母和下划线&lt;/span&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/form&gt;</code></pre><p>3.组件<br>    1.图标字体<br>         使用方法<br>         <span class="glyphicon glyphicon-*"></span><br>         注：span中不能有任何文本或子标签</p><pre><code>2.按钮组     .btn-group     .btn-group-justified         占满屏幕的按钮组     .btn-group-lg/sm/xs          不同型号的按钮     .btn-group-vertical          竖直按钮3.下拉菜单    &lt;div class=&apos;dropdown&apos;&gt;        &lt;a data-toggle=&apos;dropdown&apos;&gt;触发元素&lt;/a&gt;        &lt;ul class=&apos;dropdown-menu&apos;&gt;            &lt;li&gt;小鸡&lt;/li&gt;            &lt;li&gt;小鸭&lt;/li&gt;            &lt;li&gt;小狗&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;4.导航    a.标签页式导航        &lt;ul class=&apos;nav nav-tabs&apos;&gt;            &lt;li class=&apos;active&apos;&gt;                &lt;a data-toggle=&apos;tab&apos;&gt;详情信息&lt;/a&gt;            &lt;/li&gt;            &lt;li&gt;                &lt;a&gt;评论&lt;/a&gt;            &lt;/li&gt;        &lt;/ul&gt;        .nav        去除了li默认的样式        .nav-tabs   浮动，并增加了下边框        .active     显示当前页        .data-toggle  每个li可以来回切换    b.胶囊式导航        &lt;ul class=&apos;nav nav-pills&apos;&gt;            &lt;li class=&apos;active&apos;&gt;                &lt;a data-toggle=&apos;tab&apos;&gt;详情信息&lt;/a&gt;            &lt;/li&gt;            &lt;li&gt;                &lt;a data-toggle=&apos;tab&apos;&gt;评论&lt;/a&gt;            &lt;/li&gt;        &lt;/ul&gt;    c.导航条中的导航        &lt;ul class=&apos;nav navbar-nav&apos;&gt;            &lt;li class=&apos;active&apos;&gt;                &lt;a data-toggle=&apos;tab&apos;&gt;详情信息&lt;/a&gt;            &lt;li&gt;            &lt;li&gt;                &lt;a data-toggle=&apos;tab&apos;&gt;评论&lt;/a&gt;            &lt;li&gt;        &lt;/ul&gt;5.警告框        &lt;div class=&apos;alert alert-dismiss alert-danger&apos;&gt;            &lt;span class=&apos;close&apos;  data-dismiss=&apos;alert&apos;&gt;$times;&lt;/span&gt;        &lt;/div&gt;6.进度条    //普通进度条    &lt;div class=&apos;progress&apos;&gt;        &lt;div class=&apos;progress-bar&apos; style=&apos;width:30%&apos;&gt;&lt;/div&gt;    &lt;/div&gt;    //带条纹的进度条    &lt;div class=&apos;progress&apos;&gt;        &lt;div class=&apos;progress-bar progress-bar-striped&apos; style=&apos;width:30%&apos;&gt;&lt;/div&gt;    &lt;/div&gt;    //带条纹会动的进度条    &lt;div class=&apos;progress&apos;&gt;        &lt;div class=&apos;progress-bar progress-bar-striped active&apos; style=&apos;width:30%&apos;&gt;&lt;/div&gt;    &lt;/div&gt;7.路径导航(面包屑)    &lt;ul class=&quot;breadcrumb&quot;&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;&quot;&gt;国内新闻&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;&quot;&gt;泊头新闻&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;8.分页条(pagination)    &lt;ul class=&quot;pagination&quot;&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;前一页&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;当前页&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#&quot;&gt;后一页&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    注：li里面必须要有a9.分页器(pager)    &lt;ul class=&quot;pager&quot;&gt;        &lt;li&gt;&lt;a href=&quot;&quot;&gt;前一页&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;&quot;&gt;后一页&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;10.徽章(badge)    &lt;a href=&quot;#&quot; class=&quot;btn btn-warning&quot;&gt;        收件箱        &lt;span class=&quot;badge&quot;&gt;4&lt;/span&gt;    &lt;/a&gt;11.标签(label)    &lt;span class=&quot;label label-danger&quot;&gt;danger&lt;/span&gt;    &lt;span class=&quot;label label-warning&quot;&gt;warning&lt;/span&gt;    &lt;span class=&quot;label label-success&quot;&gt;success&lt;/span&gt;    &lt;span class=&quot;label label-info&quot;&gt;info&lt;/span&gt;    &lt;span class=&quot;label label-primary&quot;&gt;primary&lt;/span&gt;12.巨幕    &lt;div class=&quot;jumbotron&quot;&gt;        &lt;h1&gt;hello world&lt;/h1&gt;        &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Modi obcaecati possimus voluptas! Accusantium aperiam,            autem dolor dolorem eaque molestiae necessitatibus nihil nobis perspiciatis praesentium quidem reiciendis            sapiente soluta sunt voluptas.&lt;/p&gt;        &lt;p&gt;&lt;a href=&quot;#&quot; class=&quot;btn btn-warning&quot;&gt;按钮&lt;/a&gt;&lt;/p&gt;    &lt;/div&gt;13.页头    &lt;div class=&quot;page-header&quot;&gt;        &lt;h1&gt;hello world hello world&lt;/h1&gt;    &lt;/div&gt;14.水井（well）    &lt;div class=&quot;well&quot;&gt;        i have a good idea    &lt;/div&gt;15.列表组：    使用ul&gt;li实现列表组    &lt;ul class=&quot;list-group&quot;&gt;        &lt;li class=&quot;list-group-item&quot;&gt;首页&lt;/li&gt;        &lt;li class=&quot;list-group-item&quot;&gt;详情页&lt;/li&gt;        &lt;li class=&quot;list-group-item&quot;&gt;联系我们&lt;/li&gt;    &lt;/ul&gt;    使用div&gt;a实现列表组(有默认的鼠标悬停效果)    &lt;div class=&quot;list-group&quot;&gt;        &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;首页&lt;/a&gt;        &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;详情页&lt;/a&gt;        &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;联系我们&lt;/a&gt;    &lt;/div&gt;16.缩略图(缩略图一般配合栅格布局系统使用，实现批量的商品展示)    &lt;div class=&quot;thumbnail&quot;&gt;        &lt;img src=&quot;img/1.jpg&quot; alt=&quot;&quot;/&gt;        &lt;div class=&quot;caption&quot;&gt;            &lt;p&gt;国画&lt;/p&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-warning&quot;&gt;加入购物车&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;17.媒体对象    &lt;div class=&quot;media&quot;&gt;        &lt;div class=&quot;media-left&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;media-body&quot;&gt;&lt;/div&gt;    &lt;/div&gt;18.面板和面板组(面板组内容分为三部分:头，主体，尾部)，多个面板组合(称为面板组)可以实现手风琴的效果    &lt;div class=&quot;panel panel-success&quot;&gt;        &lt;div class=&quot;panel-heading&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;panel-body&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;panel-footer&quot;&gt;&lt;/div&gt;    &lt;/div&gt;</code></pre><p>4.插件<br>    1.折叠效果<br>        <div class="collapse" id="collapseExample"><br>            <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Accusamus deleniti ea expedita fugiat ipsum, natus<br>                optio recusandae vitae. Assumenda autem doloremque dolores ipsam ipsum modi molestias perferendis placeat, ut<br>                vero!</p><br>        </div></p><pre><code>    折叠效果的两个重要扩展        1.手风琴----重点            面板组+折叠效果插件        2.响应式导航条---重点&amp;&amp;难点        “响应式导航条”必须配合折叠效果插件使用。           响应式导航条在PHONE中只显示一个LOGO + 一个汉堡包按钮，其他菜单项全在折叠下拉菜单中；PAD和PC中，下拉菜单要实现绝对对位，定位到LOGO后面去。              “响应式导航条”必须配合折叠效果插件使用。                 响应式导航条在PHONE中只显示一个LOGO + 一个汉堡包按钮，其他菜单项全在折叠下拉菜单中；PAD和PC中，下拉菜单要实现绝对对位，定位到LOGO后面去。                Bootstrap中导航条分类：                (1)按颜色分：                      白底黑字：  .navbar-default                      黑底白字：  .navbar-inverse                (2)按定位方式分：                      相对定位：    默认                      固定定位：  .navbar-fixed-*                (3)按所在位置分：                      固定在顶部：  .navbar-fixed-top                      固定在底部：  .navbar-fixed-bottom                &lt;div class=&quot;navbar navbar-default&quot;&gt;                &lt;div class=&quot;container&quot;&gt;                  &lt;!--导航条头部 = brand + toggle--&gt;                  &lt;div class=&quot;navbar-header&quot;&gt;                  &lt;/div&gt;                  &lt;!--导航条折叠部分 = 导航 + 链接 + 表单 + 按钮 ...--&gt;                  &lt;div id=&quot;my-menu&quot; class=&quot;collapse navbar-collapse&quot;&gt;                  &lt;/div&gt;                &lt;/div&gt;              &lt;/div&gt;          Bootstrap中导航条分类：          (1)按颜色分：                白底黑字：  .navbar-default                黑底白字：  .navbar-inverse          (2)按定位方式分：                相对定位：    默认                固定定位：  .navbar-fixed-*          (3)按所在位置分：                固定在顶部：  .navbar-fixed-top                固定在底部：  .navbar-fixed-bottom          &lt;div class=&quot;navbar navbar-default&quot;&gt;          &lt;div class=&quot;container&quot;&gt;            &lt;!--导航条头部 = brand + toggle--&gt;            &lt;div class=&quot;navbar-header&quot;&gt;            &lt;/div&gt;            &lt;!--导航条折叠部分 = 导航 + 链接 + 表单 + 按钮 ...--&gt;            &lt;div id=&quot;my-menu&quot; class=&quot;collapse navbar-collapse&quot;&gt;            &lt;/div&gt;          &lt;/div&gt;        &lt;/div&gt;2.补充：列偏移 vs 列排序      列偏移：控制一列出现的位置，某列偏移后，后续的列都会随之偏移——只能往右偏移        col-lg/md/sm/xs-offset-*      列排序：控制一列出现的位置，某列可以往左拉或往右推——可以往右往左调整——某列排序后，其他列没有任何影响！        col-lg/md/sm/xs-push-*        col-lg/md/sm/xs-pull-*2.Boostrap第四部分：jQuery插件      Bootstrap基于jQuery提供了十几个插件函数，可以有两种调用方法：        (1)JS调用方式：  $(&apos;a&apos;).dropdown( );        (2)data-*调用方式： &lt;a data-toggle=&quot;dropdown&quot;&gt;&lt;/a&gt;      提示：官方推荐使用方式2！但有两个插件提交特别：需要方式1和2同时使用才能奏效。3.Boostrap第四部分：jQuery插件——下拉菜单    &lt;div class=&quot;dropdown&quot;&gt;        &lt;a data-toggle=&quot;dropdown&quot;&gt;触发元素&lt;/a&gt;        &lt;ul class=&quot;dropdown-menu&quot;&gt;    &lt;/div&gt;4. Boostrap第四部分：jQuery插件——导航     &lt;ul class=&quot;nav nav-tabs&quot;&gt;        &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;二十元套餐&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a data-toggle=&quot;tab&quot; href=&quot;#&quot;&gt;二十元套餐&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;5. Boostrap第四部分：jQuery插件——警告框  &lt;div class=&quot;alert&quot;&gt;    &lt;span class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/span&gt;  &lt;/div&gt;6. Boostrap第四部分：jQuery插件——折叠    &lt;a data-toggle=&quot;collapse&quot; href=&quot;#box&quot;&gt;展开收起&lt;/a&gt;    &lt;div id=&quot;box&quot; class=&quot;collapse&quot;&gt;&lt;/div&gt;7. Boostrap第四部分：jQuery插件——工具提示      对HTML元素的title属性的呈现效果加以改观。          &lt;ANY title=&quot;工具提示的内容&quot; data-toggle=&quot;tooltip&quot;&gt;          &lt;script&gt;            $(&apos;[data-toggle=&quot;tooltip&quot;]&apos;).tooltip();          &lt;/script&gt;      注意：此插件必须同时声明data-*和js调用！还有一些可选参数，参考手册即可。8. Boostrap第四部分：jQuery插件——弹出框      &lt;ANY title=&quot;弹出框的标题&quot; data-content=&quot;弹出框的内容&quot; data-toggle=&quot;popover&quot;&gt;      &lt;script&gt;        $(&apos;[data-toggle=&quot;popover&quot;]&apos;).popover();      &lt;/script&gt;  注意：此插件必须同时声明data-*和js调用！还有一些可选参数，参考手册即可。Module：模块Model：模型Modal：模态对话框9.Boostrap第四部分：jQuery插件—— 模态框 —— 重点  Modal：模态对话框——在父窗口中弹出的子窗口，只要不关闭，则父窗口无法再获得输入焦点。      &lt;a data-toggle=&quot;modal&quot; href=&quot;#mid&quot;&gt;打开模态框&lt;/a&gt;      &lt;button data-toggle=&quot;modal&quot; data-target=&quot;#mid&quot;&gt;打开模态框&lt;/button&gt;  模态框必需的HTML结构：  &lt;div id=&quot;mid&quot; class=&quot;modal&quot;&gt;  半透明遮罩层    &lt;div class=&quot;modal-dialog&quot;&gt;  尺寸位置        &lt;div class=&quot;modal-content&quot;&gt;  背景/边框/倒角/阴影            &lt;div class=&quot;modal-header&quot;&gt;                &lt;span data-dismiss=&quot;modal&quot; class=&quot;close&quot;&gt;&amp;times;&lt;/span&gt;            &lt;/div&gt;            &lt;div class=&quot;modal-body&quot;&gt;&lt;/div&gt;            &lt;div class=&quot;modal-footer&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;10. jQuery插件——轮播广告 —— 重点      提示：轮播广告的结构比较复杂！只要记得根元素 div.carousel（旋转木马），剩余的全靠Bootlint的错误提示。      &lt;div class=&quot;carousel&quot; data-ride=&quot;carousel&quot;&gt;        &lt;div class=&quot;carousel-inner&quot;&gt;            &lt;div class=&quot;item active&quot;&gt;                &lt;img&gt;            &lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;     练习：    (1)为每个广告添加说明文字    (2)添加“上一条”、“下一条”按钮    (3)添加序号指示器</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷&lt;br&gt;使用它可以快速开发一个适应手机、平板、电脑的网站，&lt;br&gt;比如我的&lt;br&gt;法标珠光卫浴  &lt;a href=&quot;http://zhangningle.gitee
      
    
    </summary>
    
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
      <category term="bootrtsp" scheme="http://yoursite.com/tags/bootrtsp/"/>
    
      <category term="移动端" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>css3动画</title>
    <link href="http://yoursite.com/2018/03/17/css3/"/>
    <id>http://yoursite.com/2018/03/17/css3/</id>
    <published>2018-03-17T09:20:14.000Z</published>
    <updated>2018-06-10T08:38:10.309Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在做H5的微场景，用到很多css3的特效，在这里把常用的总结一下吧，</p><ul><li><code>border-radius</code>创建圆角边框</li><li><code>box-shadow</code> 添加阴影</li><li><code>background-size</code> 属性规定背景图片的尺寸。</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transform: rotateX(120deg);</span><br><span class="line">-webkit-transform: rotateX(120deg);/* Safari 和 Chrome */</span><br><span class="line">-moz-transform: rotateX(120deg);</span><br></pre></td></tr></table></figure></li></ul><p>3d转换</p><ul><li><code>transition</code> css3过渡<br>CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。<br>要实现这一点，必须规定两项内容：<br>规定把效果添加到哪个 CSS 属性上<br>规定效果的时长 </li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSS3 @keyframes 规则</span><br><span class="line">如需在 CSS3 中创建动画，您需要学习 @keyframes 规则。</span><br><span class="line"></span><br><span class="line">@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。</span><br></pre></td></tr></table></figure></li></ul><p>创建css3动画，可代替一些js效果，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一直在做H5的微场景，用到很多css3的特效，在这里把常用的总结一下吧，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;border-radius&lt;/code&gt;创建圆角边框&lt;/li&gt;
&lt;li&gt;&lt;code&gt;box-shadow&lt;/code&gt; 添加阴影&lt;/li&gt;
&lt;li&gt;&lt;code
      
    
    </summary>
    
    
      <category term="css3" scheme="http://yoursite.com/tags/css3/"/>
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>火锅鸡网</title>
    <link href="http://yoursite.com/2018/03/11/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%80%20/"/>
    <id>http://yoursite.com/2018/03/11/小程序学习记录一 /</id>
    <published>2018-03-11T09:20:14.000Z</published>
    <updated>2018-06-10T08:43:48.957Z</updated>
    
    <content type="html"><![CDATA[<p>火锅鸡网，终于做完了，我做的是移动端，晓哥做的pc端，做的时候感觉移动端坑也好多，中间经理吩咐的细节部分老是忘记改，还好我从哥记忆力好，哈哈，这两天改了n次，终于算是过了自己这关了，<br>好，下边总结一下自己的这次的项目心得，</p><h2 id="没听清楚需求"><a href="#没听清楚需求" class="headerlink" title="没听清楚需求"></a>没听清楚需求</h2><p>一开始讲需求的时候没认真听，所以做完以后修改的时候比做的时间都多，所以下次一定要注意，用户需求才是项目的方向主导，<br>了解了用户需求，清楚了项目的层级结构，才能高效的快速的完成工作，不要觉得前期规划很慢，其实前期吧项目规划的越清楚，后期做的时候就会越迅速，</p><h2 id="swiper-问题"><a href="#swiper-问题" class="headerlink" title="swiper 问题"></a>swiper 问题</h2><p>又是swiper  没办法 一做移动端就想到了他，谁让他是移动端最好的轮播呢（00）<br>这个问题主要出在我没搞清楚swiper 的函数就修改人家的代码，导致一个轮播浪费了很多的时间，最后还是自己写出的…</p><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><p>中间用到一个返回的功能，想到了BOM，可是就是实现不了 ，果然百度是强大的，<br><code>&lt;a class=&quot;fl clearfix&quot; href=&quot;javascript:history.back(-1)&quot;&gt;</code><br>js调用浏览器的历史记录 无刷新返回 就是类似的浏览器历史记录 缺点是不能刷新 优点是 速度快</p><p>做了这么多项目后觉得自己的JavaScript有所提高了，</p><h2 id="分享功能"><a href="#分享功能" class="headerlink" title="分享功能"></a>分享功能</h2><p>由于客户喜欢的分享功能比较奇葩，别人都是分享网页或网址，他想让分享APP，着急上火的我去找了百度、segmentfault、博客园、csdn，最终在我的大知乎上找到了一个，<br>这是一个github的开源项目，感觉超级良心 ，<br>示例：<a href="https://fa-ge.github.io/NativeShare/demo/index.html" target="_blank" rel="noopener">https://fa-ge.github.io/NativeShare/demo/index.html</a><br>放出git地址<a href="https://github.com/fa-ge/NativeShare" target="_blank" rel="noopener">https://github.com/fa-ge/NativeShare</a><br>技术点主要是JavaScript（又是我强大的js）调用手机系统的分享功能<br>自我觉得对于div+css越发越熟练，JavaScript也上了一个台阶！！ 加油张宁乐！<br>点击–&gt;火锅鸡网演示：<a href="http://zhangningle.gitee.io/m.huoguoji.net/" target="_blank" rel="noopener">http://zhangningle.gitee.io/m.huoguoji.net/</a><br>我懂代码–&gt;点击查看源码：<a href="https://gitee.com/zhangningle/m.huoguoji.net" target="_blank" rel="noopener">源码</a><br><img src="http://p0bnwspy9.bkt.clouddn.com/6B4146D081BAE220634689C69DC76C57.png" alt="火锅鸡网" style="width:75%;" class="about_img"><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;火锅鸡网，终于做完了，我做的是移动端，晓哥做的pc端，做的时候感觉移动端坑也好多，中间经理吩咐的细节部分老是忘记改，还好我从哥记忆力好，哈哈，这两天改了n次，终于算是过了自己这关了，&lt;br&gt;好，下边总结一下自己的这次的项目心得，&lt;/p&gt;
&lt;h2 id=&quot;没听清楚需求&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
      <category term="移动端" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
</feed>
