{"meta":{"title":"Anson's Blog","subtitle":"种一棵树最好的时间在十年前，其次是现在。","description":"张宁乐,博客","author":"张宁乐","url":"http://yoursite.com"},"pages":[{"title":"","date":"2018-06-10T04:05:06.957Z","updated":"2017-12-03T07:07:29.831Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2017-12-03T01:07:23.000Z","updated":"2019-02-16T09:49:08.225Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"@card{ 前方的路 为什么学前端——如果能靠兴趣挣钱，我为什么不做的更好！ 就要毕业了，从学校到实习直至毕业，这一路走来，总想写点什么，记录这过程中的点滴，以后老了再来回味！ 进入大学，选择了计算机2016年高考，考的不太理想，按我自己的打算是不愿意上大学的，总觉得读书无用，无奈家人都一致要求，我也就硬着头皮来了。填自愿的时候，可以填六个学校，由于分数低，又想在河北，最后被河北沧州一个学校录取了，计算机网络技术专业。 读书无用 —— 一群同龄人在一个叫作学校的组织机构里，以几十不等划分为班级，参加一场由已经经历过‘读书’的长者组织的，以‘考试’为目的的活动。但是学习是有用的，吾生也有涯，而知无涯！ 为什么学计算机，一个农村的里的孩子，连打字都不打不溜。很大部分原因，应该是我有个邻居家的孩子是做这行的，感觉很挣钱。从小他就是那种别人家的孩子，家里人各种比较，夸赞。可能就是这样，想向他看齐吧。 摸爬滚打，确立学习方向在大学里，也教过一些html，因此对前端很感兴趣，正巧网上资源丰厚，利用网络也获取到很多的学习资料。后来经常切图的需要，还跟随着一位老师学过PS，随后发现自己确实没有设计这方面的天赋。也学习过一段时间的php，使用WordPress搭建过一些简单的网站，觉得很有趣。还在阿里云上学生认证买了9.9元的学生机，一直使用到现在。最后我还是选择了前端。因为当我编写的代码在浏览器中渲染成了炫酷的效果、当漂亮的网页在自己手中制作完成向同学朋友炫耀时、当我经过几天实现一个复杂的功能，这些都会带给我成就感，令我感到兴奋不已。明确了方向之后，从此开启了我的前端之路！ 在前端这条路上摸索前进… 实习，开始我的职业生涯大二下学期时，学校有招聘会，我就去试了一试，公司经理看了我以前写过的几个Demo很满意，所以我就得到了一个利用假期时间去他们公司实习的机会，现在想想也就是做一些切图的工作，就是把设计稿编写成网页，期间也做过了一个完整的项目，虽然不大，但是这也是我第一个上线的完整的项目，在这个项目里学到很多的东西~随着工作中的需要，jQuery、BootStrap这些已经用的越来越熟练的，当时在公司使用这两样基本就可以解决90%问题了。当时我坐在电脑前看着网上炒的火热的Vue、React、Angular、webpage、gulp、Node.js等新技术，虽然自己也在网上学习过一些简单的使用，但是实际开发中根本用不到，眼看自己所在的行业在迅速迭代技术。当时我就想，我也要参加进入这场变革之中。第一次踏出校门，坐班实习大三的时候要实习我就离开了沧州，因为比较向往大城市，就来到了北京。在实习老师的帮助下找完房子，之后就边学习边到处投简历，四处碰壁。没有985、211的光环，在找工作上确实缺少先天优势。有时候去面试，来回路上四个小时，面试时间10分钟，很多的面试都是有头无尾，每次等上一两周还在幻想自己有机会，只是别人忙，现在想起来，感觉自己卑微的可笑。有时候遇到不情理的面试官还会嘲笑我的技术很渣，难以找到一份工作。也有很聊得来的面试官会告知我的缺点和一些应该掌握的技能，有些甚至还会给我推荐一些网站、学习资料给我，真的非常的感谢他们，每一次面试的经历都让我获益匪浅，明确了自己的不足之后，就开始着重的补充学习，之后又开始新的征程..现在上班的这家公司，在中关村，说来也算是运气好吧。面试的时候我好像是第一个到场的，上午面试，一轮Hr，一轮技术，其中Hr面没聊太多，解了一下基本情况，技术面就问了一些常见的技术问题，有回答上来的有回答不上了的，面试官很聊得来，结束后。第二天就通知我复试，我才知道自己我面试通过了，心中暗喜。在这里主要用的是Vue、Angular，这正是我想要的。 毕业，写给自己在做完毕业设计之后，我的大学生涯算是画上了一个圆满的句号。一路走来，自己的艰辛只有自己知道，风雨兼程，砥砺前行。这一路走来我的技术库里增加不少武器：从一开始简单的html、css到后来的JavaScript、jQuery、BootStrap 到现在的Vue、Angular、webpack、Node.js、Express、Mongodb。未来还会增加许多技能，技术的路，永无止尽。接下来我打算好好深入学习一下原生Javascript、Node.js、数据结构算法、设计模式。 我的：segmentfault我的： 掘金 }"},{"title":"简历","date":"2019-02-14T12:55:14.000Z","updated":"2019-02-22T12:49:46.340Z","comments":true,"path":"resume/index.html","permalink":"http://yoursite.com/resume/index.html","excerpt":"","text":"@card{ 如果你想了解更多，请查看About me } @card{ 基本信息 姓&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;名： 张宁乐 性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;别： 男 年&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;龄： 22岁 毕业学校： 泊头职业学院 所学专业： 计算机网络技术 现居住地： 北京-昌平 联系电话： 18201607466 求职意向： Web前端 联系邮箱： zhangningle2017@163.com } @card{ 我的技能 熟练使用Photoshop切图，熟练使用HTML+CSS编写网页。 熟练使用原生JavaScript、熟练使用jQuery、Bootstrap、Swiper、zepto.js。 熟练使用Vue（vue-router/vuex）和Angular.JS语法。 熟练使用Webpack、Gulp打包工具，熟悉Sass、ES6等语法。 熟练使用Ajax、Axios获取数据，操作json数据。 熟练使用ECharts.js 做图表，进行数据可视化。 了解微信小程序开发、移动端开发。 了解Node.js、Express、MongoDB等，并实现一些小功能。 熟练使用Git管理代码 } @card{ 工作经历2018 / 5 – 至今 | 北京清软时代科技有限公司 | 技术部 | web前端（实习）1.使用Angular、Vue等前端技术实现前端动态交互效果和前端功能开发。2.与UI设计师沟通并根据设计图稿，还原设计图。3.与后端工程师协作，完成系统的数据交互、动态信息展示。4.负责现有项目和新项目的更新、维护和开发工作。5.参与开发规范的制订和技术文档的编写，定期汇报工作进度。 2017 / 7 – 2017 / 9 | 沧州博川网络技术有限公司 | 技术部 | web前端（假期实习）1.与设计师沟通，使用HTML+CSS进行页面制作，还原设计图。2.使用JavaScript、jQuery、Bootstrap等编写页面的交互、特效等。3.兼容移动端设备，兼容主流浏览器，修改bug和网站的代码优化。4.与产品经理沟通确定开发需求。 } @card{ 项目经验2018.5 - 至今 博物馆预防性保护文物系统 - 北京清软时代科技有限公司项目地址：http://gx.chingsoft.com项目描述：以互联网为基础，将监测设备联网，对设备各项指标进行监控和分析。项目职责：1.后台系统使用Angular.JS + Bootstrap 搭建，Ajax获取数据解析并显示。2.负责与后台交互，输出动态页面。3.使用Echarts.js进行数据可视化处理，制作项目文档、接口文档等。项目业绩：数据显示延迟低于2s，运行过程中无bug，整体项目缩短10%。 2017.7 - 2017.9 火锅鸡网 - 沧州博川网络技术有限公司项目地址： http://www.huoguoji.net项目描述：火锅鸡网是美食类网站，提供全面的火锅鸡店加盟招商、招工求职、开店指南等信息。项目职责：1.与设计师沟通，根据UI设计图稿，用代码还原设计图。2.使用原生JavaScript等技术实现网页交互，使用Swiper库完成网页特效。3.使用rem布局适配移动端。4.通用的类库开发，提升代码重用率，减少http请求，加快访问速度。项目业绩：适配移动端，实现按需加载，公共模块抽离等功能，加载速度快了近2倍。 } @card{ 自我介绍 热爱技术，具有良好的团队意识和执行力，较强自学能力，良好的编码习惯，对工作负责。 责任心强，注重细节，追求完美，具有良好的沟通能力和团队合作精神。 喜欢运动，喜欢夜跑喜欢打乒乓球。有总结回顾的学习习惯。 下载张宁乐的简历 } 致谢@card{ 感谢您花时间阅读我的简历，期待能有机会与您有共事。 }"},{"title":"导航","date":"2018-08-15T01:07:23.000Z","updated":"2018-09-06T13:15:40.116Z","comments":true,"path":"nav/index.html","permalink":"http://yoursite.com/nav/index.html","excerpt":"","text":"前端常用网址整合技术论坛 知乎 stackoverflow 掘金git网站 GitHub 码云 coding 缓解疲劳的网站 Calm donothingfor2minute A Soft Murmur 时间笔记项目管理 高效学习英语 Anki | 暗记 记忆卡片 时间管理 墨刀 线上原型图 写文档 用语雀 落霞小说 大前端 前端网 充电 很好玩 免费的编程中文书籍 boot中文网 全栈开发教程 技术胖 廖雪峰的博客 百度前端技术学院 小马视频 奇舞团 fundebug showdoc 为知笔记 番茄时间管理 奇妙清单-解决问题：明确每日工作目标和清单 trello-清单管理系统 高效To Do-解决问题：每日待办的轻重缓急一目了然 坚果云-解决问题：工作资料的同步备份和快速搜索 永硕e盘：在线网络硬盘–拥有自己独立二级域名，小额存储数据非常方便 Pocket-解决问题：工作时间看到的好内容收集 XMind 百度脑图 processon 幕布：便捷的在线思维工具–简直不能再爱 Teambition-项目管理 小书匠 stackedit vue 源码解析 webGL 3D建模文件下载 参考类 秀米 XIUMI | 秀米 XIUMI 易企秀|免费移动场景应用自营销管家 云来·中国最大的移动APP云服务提供商 导航类 一个很酷炫的前端网站搜集器–推荐 最牛前端 前端网址导航 - WHYCSS 大前端 前端导航网址 前端网址导航 - WHYCSS 前端圈 - 江湖录 - 前端导航 前端开发仓库 前端收藏夹 F2E 前端导航 - 前端工程师专用的导航 菜鸟教程 菜鸟导航 前端工程师专用的导航站 各种框架汇总 伯乐在线 fks_chart 前端工具汇集 面试图谱InterviewMap 冷子欲前端导航 极客导航 大前端导航 小呆导航 web前端导航 开发者速查表 Linux命令搜索引擎 大数据工具导航 设计 Vant 轻量、可靠的移动端 Vue 组件库 设计导航 admire-每天发现一个好链接 优设网导航 专注于PPT设计的导航站 图灵创意导航 网站设计-自动给出最佳配色 配色网 用户体验导航 产品经理运营导航 图标管理 综合 优秀网站集结地 静态网页生成工具-把md文件生成网页在线学习好去处 可能是让你受益匪浅的英语进阶指南 无广告、免费、清爽的视频网站 实验楼 慕课网 网易云课堂 极客学院 可汗学院 coursera codeschool Edx 在线工具 Resource 以下是分类 ToolBox Front-End-develop-Tools Blog-国内前端博客 HTML CSS Javascript UED UI VPN IP-Info 设计-ICON资源 前端工程构建 实用参考手册 兼容性 移动前端开发 性能 数据管理 在线代码运行 插件库 常用组件 sublime专题 Sublime常用插件总结 速查表 常用库与框架的使用文档 编码规范 Git–SVN-Github 开发工具类 各大公司开源项目 作品集 程序员简历模板系列简历类 面试图谱–InterviewMap 不错的个人简历 简历 超级酷炫的HTML5互动式程序员求职简历 Haorooms博客-前端博客-前端技术 Web前端开发工程师林卿的个人简历 flqin aaageekweb fullpage love jianli momeakl zhangwenli 动画简历技术博客 磨蹭先生 千寻啊千寻–csdnAPI接口开放 聚合数据 showAPI 一个非常适合IT团队的在线API文档、技术文档工具 Trello完全免费，灵活性高，可视化，和任何人一起管理任何事情。 更好的企业协作平台 深受用户喜爱的团队协作工作 MDN ES6 入门 阮一峰 JavaScript秘密花园 阿里巴巴 icon Mockplus是一款免费的原型软件 mock 地址 ElementUI 谷歌插件 划词翻译 免费在线文件转换器"},{"title":"","date":"2018-06-10T04:05:06.973Z","updated":"2017-12-09T13:38:17.735Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"作品","date":"2017-12-05T10:47:34.000Z","updated":"2018-04-11T08:18:41.230Z","comments":true,"path":"works/index.html","permalink":"http://yoursite.com/works/index.html","excerpt":"","text":"p{ width:50%;} 项目经历 H5简历模板（移动端） 2018.03 独立制作完成H5简历模板点击–&gt;H5简历演示：http://zhangningle.gitee.io/resume我懂代码–&gt;点击查看源码：源码 visibook（响应式） 2018.03 独立制作完成visibook点击–&gt;visibook演示：http://zhangningle.gitee.io/bt_visibook我懂代码–&gt;点击查看源码：源码 马克森官网（企业、响应式） 2018.03 独立制作完成马克森官网点击–&gt;马克森官网演示：http://zhangningle.gitee.io/makesen/我懂代码–&gt;点击查看源码：源码 火锅鸡网（仅移动端） 2018.01 - 2018.03 独立制作完成火锅鸡网点击–&gt;大连罗森演示：http://zhangningle.gitee.io/m.huoguoji.net/我懂代码–&gt;点击查看源码：源码 大连罗森（仅移动端） 2018.01 - 2018.03 独立制作完成大连罗森点击–&gt;大连罗森演示：http://zhangningle.gitee.io/m.luosen/我懂代码–&gt;点击查看源码：源码 起点中文网 （仅移动端） 2018.01 - 2018.02 独立制作完成起点中文网点击–&gt;起点中文网演示：https://ansonznl.coding.me/QiDian/我懂代码–&gt;点击查看源码：源码 邀请函 （仅移动端） 2017.12 - 2018.01 独立制作完成泊头职业学院双选会邀请函点击–&gt;邀请函在线演示：https://ansonznl.github.io/Swiper-demo/swiper-dome02/我懂代码–&gt;点击查看源码：源码 靓装网购官网（pc端）2017.12 - 至今 靓装网购官网 独立开发靓装网购是一个美妆商城类网站，主要产品有美妆、护肤、面膜等产品，网站主题色调是以女性爱的粉红、淡黄等暖色系为网站主色调。首页已经完成，目前正在开发副页中。主要使用的技术有：HTML/CSS/JavaScript/gulp点击–&gt;靓装网购在线演示：http://ansonznl.coding.me/LiangZhuangWangGou/我懂代码–&gt;点击查看源码：源码 法标珠光卫浴（响应式） 2017.04 - 2017.05 法标珠光卫浴 独立开发点击–&gt;法标珠光卫浴在线演示：http://zhangningle.gitee.io/fabiaozhuguangweiyv/我懂代码–&gt;点击查看源码：源码 承德选房网（响应式） 2017.04 - 2017.05 承德选房网 团队合作完成房产类网站，我负责网站[租房]版块的设计与制作，先后总结多家房产类网站的[租房]版块的设计并制作的，功能信息齐全增加用户体验，使用Bootstrap兼容移动端、压缩CSS，增加网站访问速度。使用技术有：HTML/CSS/JavaScript/jQuery/Bootstrap/gulp等前端技术和工具，并且可以相应移动端设备，使用Git管理代码。点击–&gt;[承德选房网[租房]在线演示：http://zhangningle.gitee.io/chengdexvanfangwang/%E7%A7%9F%E6%88%BF/zufang.html我懂代码–&gt;点击查看源码：源码 李维斯官网 （pc端） 2016.11 - 2016.12 李维斯官网 独立完成电商类网站，模仿李维斯官网制作，增加了商品模块商品介绍的交互效果，提高了用户体验。点击–&gt;[李维斯官网在线演示：http://zhangningle.gitee.io/levi/我懂代码–&gt;点击查看源码：源码 Dave的博客 （兼容移动端）2017.03 Dave的博客 独立制作完成Dave的博客，一个技术人的博客，我是用css提供的媒体查询的方法来适应的手机端点击–&gt;Dave的博客在线演示:http://zhangningle.gitee.io/dave/我懂代码–&gt;点击查看源码：源码 点击张宁乐的博客进入我的博客首页点击张宁乐的关于进入我的关于点击张宁乐的Github进入Github"}],"posts":[{"title":"我对JavaScript中this的一些理解","slug":"我对JavaScript中this的一些理解","date":"2019-02-21T10:34:03.000Z","updated":"2019-02-21T12:38:31.483Z","comments":true,"path":"2019/02/21/我对JavaScript中this的一些理解/","link":"","permalink":"http://yoursite.com/2019/02/21/我对JavaScript中this的一些理解/","excerpt":"","text":"因为日常工作中经常使用到this，而且在JavaScript中this的指向问题也很容易让人混淆一部分知识。这段时间翻阅了一些书籍也查阅了网上一些资料然后结合自己的经验，为了能让自己更好的理解this，进而总结一篇文章。 this 是什么this是 JavaScript 语言的一个关键字。它是函数运行时，在函数体内部自动生成的一个对象，只能在函数体内部使用。实际是在函数被调用时才发生的绑定，也就是说this具体指向什么，取决于你是怎么调用的函数。 this 指向的四种情况这四种情况基本涵盖了JavaScript中常见的this指向问题 1. 全局的函数调用，this指向window12345var a = 1;function fn() &#123; console.log(this.a);&#125;fn(); // 1 这种 情况下的this其实就是window对象，这个很好理解。但是还有一种情况，就是匿名函数的this也会指向window。123456789var a= &apos;window&apos;;var obj=&#123;a: &apos;object&apos;&#125;obj.fn=function()&#123; console.log(this.a);//Object +function()&#123; console.log(this.a)//window &#125;()&#125;obj.fn() 匿名函数的执行环境具有全局性，因此它的this对象通常指向windows。如果对此有疑惑，可以看知乎上的答案：知乎 - 匿名函数的this指向为什么是window? 2. 作为对象方法的调用，this指向该对象123456789var a =&apos;window&apos;var obj=&#123; a: &apos;object&apos;, fn: function()&#123; console.log(this.a); &#125;&#125;obj.fn(); // object 当函数作为某个对象的方法调用时，this就指这个函数所在的对象。 3. 作为构造函数调用，this指向实例12345function fn() &#123; this.x = 1;&#125;var obj = new fn();console.log(obj.x) // 1 构造函数中的this，在通过new之后会生成一个新对象，this就指这个新对象。对new有疑问的话，可以看 冴羽的博客 JavaScript深入之new的模拟实现 4. 使用call/apply/bind调用, this指向第一个参数12345678910111213141516171819var obj1=&#123; a: &apos;boj1&apos;&#125;var obj2=&#123; a: &apos;obj2&apos;&#125;var obj3=&#123; a: &apos;obj3&apos;&#125;function fn()&#123; console.log(this.a);&#125;// applyfn.apply(obj1);// &apos;obj1&apos;// callfn.call(obj2);// &apos;obj2&apos;// bindvar fnBind= fn.bind(obj3);fnBind();// &apos;obj3&apos; call/ apply / bind都有一个共同的特点，就是改变this的指向，使用这种方法可以把别人的方法拿过来用到自己身上。 第一个参数为 null 的时候，视为指向 window.12345678var a=&apos;window&apos;var obj=&#123; a: &apos;boj&apos;, fn: function ()&#123; console.log(this.a); &#125;&#125;obj.fn.call(null);// &apos;window&apos; 在这里如果是obj.fn()调用的fn()方法，this应该指向obj没错。但是因为call(null)的存在，改变了指向，所以this指向了window。 深入理解正因为比较难理解，所以this指向也是面试时最容易遇到的问题，比如下面这道我曾遇到的一个面试题：123456789101112var length = 10;function fn()&#123; console.log(this.length);&#125;var obj = &#123; length: 5, method: function(fn)&#123; fn();//10 arguments[0]();//2 这里的this指向的arguments，所以获取的是arguments.length &#125;&#125;;obj.method(fn, 1); 在这道题里，不仅考察了对this熟悉程度，还考察了函数的传参形式、作用域、以及arguments这种特殊的数组的理解。只有真正理解了这些才能正确的判断this究竟指向了谁。所以，只有对JavaScript中的各项知识点深入理解，才会对this的概念越加清晰。 参考：阮一峰 - Javascript 的 this 用法前端开发博客 - 深入理解JavaScript this","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"理解JS 原型链","slug":"理解JS原型链","date":"2019-01-18T14:21:55.000Z","updated":"2019-01-18T15:08:50.007Z","comments":true,"path":"2019/01/18/理解JS原型链/","link":"","permalink":"http://yoursite.com/2019/01/18/理解JS原型链/","excerpt":"","text":"一直以来对于JavaScript 的原型链的概念，始终有些东西有一种模糊感，最近刚好有时间就塌下心认真的把《JavaScript高级程序设计》中相关内容认真读了一遍，也查看了很多网上很多资料，以前很多不明白的地方也渐渐明白了起来。写一篇文章记录一下最近学习的感悟。 字面量创建对象我们通常创建一个对象无非就两种方式：121. var obj= new Object();//new 一个Object的实例2. var obj= &#123;&#125;;//对象字面量 使用对象字面量 和使用new的方式是一样的。为了简便，一般推荐使用使用字面量：var o= {}; 构造函数创建对象当我们想要创建自定义的对象时，需要用到构造函数。构造函数和普通函数有两个区别： 1. 便于和普通函数区分，函数名首字母大写。 2. 使用 `new` 操作符调用，返回一个实例对象。 除此之外和普通函数一摸一样。我们使用构造函数Person来创建两个实例对象：12345678function Person(name)&#123; this.name = name; this.sayName= function ()&#123; alert(this.name) &#125; &#125;var person1 = new Person(&apos;小明&apos;);var person2 = new Person(&apos;小红&apos;);console.log(person1);//&#123;name: &quot;小明&quot;, sayName: fun&#125;console.log(person2);//&#123;name: &quot;小红&quot;, sayName: fun&#125; 上面的例子不难理解，虽然这两个实例对象都有sayName方法，而且他们两个的作用也是一样的，但却是两个方法，只是名字和作用一样。 画个图表示一下： 131547802804_.pic.jpg 如果还不明白，我在打个比喻：就像A街上有一间麦当劳，在B街上也开了一间麦当劳，它们都叫麦当劳，作用也是一样的。但是你总不能说他们是一间麦当劳吧？ 1person1.sayName === person2.sayName;//false 如果这样的话，我们每构造出来一个对象，都要单独为这个对象创建出一个专属于它自己使用的sayName，这是很占用内存的。 那我们能不能让所有的实例对象都共同使用一个sayName方法，来节省内存，提升效率呢？这需要我们先理解原型对象的概念。 原型对象我们先了解原型对象的概念。 每个对象都有原型对象（null除外），我们用__proto__表示，每个函数都有prototype属性，指向实例的原型对象。 对照这句话，按照我们上面的例子，也就是说Person.prototype指向person1的原型对象(__proto__),1Person.prototype === person1.__proto__; // true 为了便于理解，来看一张图。 71547797523_.pic.jpg 恩~他们的关系大概就是这样。 原型链原型链简单用一句话概括就是： 原型链就是 对象的__proto__所连接的链状结构 为了方便我们理解原型链，举一个简单的例子：1234567891011121314151617181920212223242526function F()&#123; this.a = 1; this.b = 2;&#125;F.prototype.b = 3;F.prototype.c = 4;var o = new F();// &#123;a: 1, b: 2&#125;//原型链：//o --&gt; o.__proto__ --&gt; o.__proto__.__proto__ --&gt; null// 其中的 --&gt; 就表示 __proto__ 也就是原型链console.log(o.a); // 1// o上有a这个属性吗？有的，该属性的值为1console.log(o.b); // 2// o上有b这个属性吗？有的，该属性的值为2// 原型上也有一个&apos;b&apos;属性,但是它不会被访问到.这种情况称为&quot;属性遮蔽 &quot;console.log(o.c); // 4// o上有c这个属性吗？没有，那看看原型上有没有// o.__proto__上有c这个属性吗？有的，该属性的值为4console.log(o.d); // undefined// o上有d这个属性吗？没有,那看看原型上有没有// o.__proto__ 上有d这个属性吗？没有，那看看它的原型上有没有// o.__proto__.__proto__ 为 null，停止搜索// 没有找到d属性，返回undefined。 我们画张图来表示： 91547800262_.pic_hd.jpg 图中这条红色的线就是原型链。由此可见，实例对象可访问自己原型对象上的属性和方法，额..准确来说是: 当一个对象 查找属性或方法时，自己有，停止查找，返回结果。 自己没有，顺着__proto__一直向上查找，如找到，停止查找，返回结果。 如果一直找到了原型链的最顶端(null)，还没有找到，返回undefined。 我们先回顾一下那个sayName的问题：怎么让所有的实例对象都是用一个sayName方法呢。现在我们可以使用原型对象来解决这个问题了。我们把sayName方法放到实例的原型对象上面，也就是Person.prototype上面来供所有实例使用：123456789function Person(name)&#123; this.name = name; &#125;Person.prototype.sayName=function ()&#123; alert(this.name);&#125;var person1 = new Person(&apos;小明&apos;);var person2 = new Person(&apos;小红&apos;);person1.sayName === person2.sayName;//true 用图表示： 101547801223_.pic.jpg 补充constructor说一下我的经历，一开始理解原型链时，一直在prototype、__proto__、constructor在这个三个属性中绕来绕去。 为了便于理解，我把constructor放在最后了。constructor字面意思就很容易理解，构造函数的意思。一句话解释: 每个原型对象都有一个 constructor 属性指向 关联的构造函数。 还是上面那个例子：1console.log(Person.prototype.constructor);//Person()&#123; fun &#125; 需要注意的一点是，实例对象上没有constructor属性。但是：1console.log(person1.constructor) ;//Person()&#123; fun &#125; 得出这个结果很简单:实例上查找不到constructor属性 –&gt; 顺着__proto__在原型对象上找 –&gt; 找到并返回。 Object.prototype刚才我们说了创建对象的两种方式：字面量创建对象和使用new操作符创建对象。这两种方式创建出来的对象都会继承Object.prototyoe上的方法。比如，我们使用字面量新创建一个对象o:1234var o = &#123;value: 1&#125;;o.toString();//&quot;[object Object]&quot;//查找过程： o --&gt; o.__proto__ 找到返回o.__proto__ === Object.prototype;//true o这个的对象本身并没有toString这个方法，但它却可以使用toString方法。因为它继承了Object.prototyoe上的toString的方法。 null既然对象都会继承自Object.prototype上面的方法，那它自己的原型又是什么呢。答案是null1Object.prototype.__prototype__ === null;//true 以上仅自己学习所得，如有不当之处 望指出。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"使用Express搭建一个简单的服务器","slug":"使用Express搭建一个简单的服务器","date":"2019-01-04T14:21:55.000Z","updated":"2019-01-04T15:27:50.960Z","comments":true,"path":"2019/01/04/使用Express搭建一个简单的服务器/","link":"","permalink":"http://yoursite.com/2019/01/04/使用Express搭建一个简单的服务器/","excerpt":"","text":"Express框架Web 应用程序Express 是一个保持最小规模的灵活的 Node.js Web 应用程序开发框架，为 Web 和移动应用程序提供一组强大的功能。 API使用您所选择的各种 HTTP 实用工具和中间件，快速方便地创建强大的 API。 性能Express 提供精简的基本 Web 应用程序功能，而不会隐藏您了解和青睐的 Node.js 功能。 Express-路由基本使用下载：npm install express --save Hello world新建一个server.js文件，然后输入：123456789const express = require(&apos;express&apos;);const app= express();app.get(&apos;/&apos;, (req, res)=&gt;&#123; req.send(&apos;Hello world&apos;);&#125;);app.listen(8083, ()=&gt;&#123; console.log(&apos;Server is running at http://localhost:8083&apos;)&#125;) 然后运行：node server.js打开：http://localhost:8083/就出现： 11546413582_.pic.jpg 请求和响应Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。123app.get(&apos;/&apos;, function (request, response) &#123; // --&#125;) request 和 response 对象的具体介绍： Request 对象 request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有： req.app：当callback为外部文件时，用req.app访问express的实例req.baseUrl：获取路由当前安装的URL路径req.body / req.cookies：获得「请求主体」/ Cookiesreq.fresh / req.stale：判断请求是否还「新鲜」req.hostname / req.ip：获取主机名和IP地址req.originalUrl：获取原始请求URLreq.params：获取路由的parametersreq.path：获取请求路径req.protocol：获取协议类型req.query：获取URL的查询参数串req.route：获取当前匹配的路由req.subdomains：获取子域名req.accepts()：检查可接受的请求的文档类型req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages：返回指定字符集的第一个可接受字符编码req.get()：获取指定的HTTP请求头req.is()：判断请求头Content-Type的MIME类型 Response 对象 response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有： res.app：同req.app一样res.append()：追加指定HTTP头res.set()在res.append()后将重置之前设置的头res.cookie(name，value [，option])：设置Cookieopition: domain / expires / httpOnly / maxAge / path / secure / signedres.clearCookie()：清除Cookieres.download()：传送指定路径的文件res.get()：返回指定的HTTP头res.json()：传送JSON响应res.jsonp()：传送JSONP响应res.location()：只设置响应的Location HTTP头，不设置状态码或者close responseres.redirect()：设置响应的Location HTTP头，并且设置状态码302res.render(view,[locals],callback)：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的页面，这样就不会自动输出了。res.send()：传送HTTP响应res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定Content-Typeres.set()：设置HTTP头，传入object可以一次设置多个头res.status()：设置HTTP状态码res.type()：设置Content-Type的MIME类型 Express-路由 我们已经了解了 HTTP 请求的基本应用，而路由决定了由谁(指定脚本)去响应客户端请求。在HTTP请求中，我们可以通过路由提取出请求的URL以及GET/POST参数。 路由的基本形式：app.METHOD(PATH, HANDLER) app 表示的是一个Express的实例 METHOD 是http请求的方法（get, psot..） PATH 服务器上的路径 HANDLER请求之后的执行函数 下面的示例说明了如何定义路由：123456789101112// 对/news 页面进行get请求app.get(&apos;news&apos;, (req, res)=&gt;&#123; res.send(&apos;Hello news&apos;);&#125;);// 对/about 页面进行post请求app.post(&apos;about&apos;, (req, res)=&gt;&#123; res.send(&apos;Hello about&apos;);&#125;);// 对/list* 可匹配 /list+任意字符app.get(&apos;/list*&apos;, (req, res)=&gt;&#123; res.send(&apos;Hello list pages&apos;);&#125;) 然后运行：node server.js打开：http://localhost:8083/ 21546417068_.pic.jpg 31546417103_.pic.jpg 41546417120_.pic.jpg Express-搭建静态资源库 Express 提供了内置的中间件 express.static 来设置静态文件如：图片， CSS, JavaScript 等。 你可以使用 express.static 中间件来设置静态文件路径。例如，如果你将图片， CSS, JavaScript 文件放在 public 目录下，你可以这么写：app.use(express.static(&#39;public&#39;)); 现在，你就可以访问 public 目录中的所有文件了：12345public/index.htmlpublic/imagespublic/images/bg.jpegpublic/css... 如果要使用多个静态资源目录，请多次调用 express.static 中间件函数：12app.use(express.static(&apos;public&apos;))app.use(express.static(&apos;files&apos;)) Express 在静态目录查找文件，因此，存放静态文件的目录名不会出现在 URL 中。但是您可以给静态目录添加一个路由：app.use(&#39;/static&#39;, express.static(path.join(__dirname, &#39;public&#39;)))设置/static为/public目录的路由。现在，你就可以通过带有 /static 前缀地址来访问 public 目录中的文件了。12345http://localhost:8083/static/csshttp://localhost:8083/static/css/index.csshttp://localhost:8083/static/imagehttp://localhost:8083/static/images/bg.jpeghttp://localhost:8083/static/index.html 为了安全，最好使用绝对路由：app.use(&#39;/static&#39;, express.static(path.join(__dirname, &#39;public&#39;)))然后运行：node server.js打开：http://localhost:8083/static就可以访问public下的所有文件，如图： 61546420083_.pic_hd.jpg Express-模板引擎之EJS EJS 是一套简单的模板语言，帮你利用普通的 JavaScript 代码生成 HTML 页面。 下载Ejs: npm install ejs --save同目录下新建myejs.js:1234567891011121314const express= require(&apos;express&apos;);const app = express();//设置模板文件的目录,并且新建一个viwes的目录app.set(&apos;views&apos;, &apos;./views&apos;);//注册模板引擎app.set(&apos;view engine&apos;, &apos;ejs&apos;);//使用res.render()来渲染一个视图并将呈现的HTML字符串发送给客户端；app.get(&apos;/&apos;, function(req, res,) &#123; res.render(&apos;index&apos;, &#123; title: &apos;测试&apos; &#125;);&#125;);//监听8083端口app.listen(8083, ()=&gt;&#123; console.log(&apos;Server is running at http://localhost:8083&apos;)&#125;) 在新建views目录中新建index.ejs:1&lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; 然后运行：node myejs.js打开：http://localhost:8083即可看到： 当然，也可以返回一个json文件来渲染视图：在同目录下新建一个data.json:12345678&#123; &quot;list&quot;: [ &#123; &quot;name&quot;:&quot;小明&quot; , &quot;age&quot;:&quot;6&quot;, &quot;sex&quot;: &quot;男&quot;&#125;, &#123; &quot;name&quot;:&quot;小红&quot; , &quot;age&quot;:&quot;4&quot; ,&quot;sex&quot;: &quot;女&quot;&#125;, &#123; &quot;name&quot;:&quot;小亮&quot; , &quot;age&quot;:&quot;5&quot; ,&quot;sex&quot;: &quot;男&quot;&#125; ], &quot;source&quot;:&quot;神奇二班&quot;&#125; 然后更改myejs.js:123456789101112131415161718192021222324252627282930const express= require(&apos;express&apos;);const fs= require(&apos;fs&apos;);const app = express();//设置模板文件的目录,并且新建一个viwes的目录app.set(&apos;views&apos;, &apos;./views&apos;);//注册模板引擎app.set(&apos;view engine&apos;, &apos;ejs&apos;);//使用res.render()来渲染一个视图并将呈现的HTML字符串发送给客户端；app.get(&apos;/&apos;, function(req, res,) &#123; getDataJson((dataJson)=&gt;&#123; console.log(dataJson); res.render(&apos;index&apos;, dataJson); &#125;)&#125;);//访问data.json 拿到数据解析并返回const getDataJson=(callBack)=&gt;&#123; fs.readFile(&apos;./data.json&apos;, (err, data)=&gt;&#123; if(!err)&#123; let jsonData= JSON.parse(data); callBack(jsonData); &#125;else&#123; throw err; &#125; &#125;)&#125;//监听8083端口app.listen(8083, ()=&gt;&#123; console.log(&apos;Server is running at http://localhost:8083&apos;)&#125;) 然后更改index.ejs:123456&lt;h4&gt;&lt;%=source %&gt;&lt;/h4&gt;&lt;ul&gt; &lt;% for(var i=0; i&lt;list.length; i++)&#123; %&gt; &lt;li&gt;&lt;%= list[i].name %&gt; | &lt;%= list[i].age %&gt; | &lt;%= list[i].sex %&gt;&lt;/li&gt; &lt;% &#125; %&gt; &lt;/ul&gt; 然后在运行：然后运行：node myejs.js打开：http://localhost:8083 参考：GitHub源码Express官方文档EJS 模板引擎","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"使用NodeJS 搭建静态服务器","slug":"使用Node.js 搭建静态服务器","date":"2018-12-21T08:21:55.000Z","updated":"2018-12-21T08:22:28.256Z","comments":true,"path":"2018/12/21/使用Node.js 搭建静态服务器/","link":"","permalink":"http://yoursite.com/2018/12/21/使用Node.js 搭建静态服务器/","excerpt":"","text":"我们可以使用Node设定一个目录，然后让Web程序变成一个文件服务器。要实现这一点，我们只需要解析request.url中的路径，然后在本地找到对应的文件，把文件内容发送出去就可以了。 解析URL需要用到Node.js提供的url模块，它使用起来非常简单，通过parse()将一个字符串解析为一个Url对象：12var url= require(&apos;url&apos;);console.log(url.parse(&apos;http://user:pass@host.com:8080/path/to/file?query=string#hash&apos;)); 解析之后是：123456789101112131415Url &#123; protocol: &apos;http:&apos;, slashes: true, auth: &apos;user:pass&apos;, host: &apos;host.com:8080&apos;, port: &apos;8080&apos;, hostname: &apos;host.com&apos;, hash: &apos;#hash&apos;, search: &apos;?query=string&apos;, query: &apos;query=string&apos;, pathname: &apos;/path/to/file&apos;, path: &apos;/path/to/file?query=string&apos;, href: &apos;http://user:pass@host.com:8080/path/to/file?query=string#hash&apos; &#125; 处理本地文件目录需要使用Node.js提供的path模块，它可以方便地构造目录：123456789var path = require(&apos;path&apos;);// 解析当前目录:console.log(path(__dirname));//__dirname 表示当前所在目录 &apos;/Users&apos;// 组合完整的文件路径:当前目录+&apos;pub&apos;+&apos;index.html&apos;:var filePath = path.join(__dirname, &apos;fileServer&apos;, &apos;index.html&apos;);// &apos;/Users/fileServer/index.html&apos; 使用path模块可以正确处理操作系统相关的文件路径。在Windows系统下，返回的路径类似于C:\\Users\\fileServer\\index.html，这样，我们就不关心怎么拼接路径了。 最后，我们实现一个文件服务器file_server.js：123456789101112131415161718192021222324252627282930313233343536var http= require(&apos;http&apos;), fs= require(&apos;fs&apos;), url= require(&apos;url&apos;), path= require(&apos;path&apos;); // 从命令行参数获取root目录，默认是当前目录:var root= path.join(__dirname, &apos;static&apos;, &apos;index.html&apos;);//创建服务器var server= http.createServer(function(request, response)&#123; //获得ur的path 类似&apos;/css/index.css&apos; var pathName= url.parse(request.url).pathname; //获得对应的本地文件路径 类似’static/css/index.css‘ var filePath= path.join(root); //获取文件状态 console.log(filePath); fs.stat(filePath, function (err, stats) &#123; if (!err &amp;&amp; stats.isFile()) &#123; // 没有出错并且文件存在: console.log(&apos;200 &apos; + request.url); // 发送200响应: response.writeHead(200); // 将文件流导向response: fs.createReadStream(filePath).pipe(response); &#125; else &#123; // 出错了或者文件不存在: console.log(&apos;404 &apos; + request.url); // 发送404响应: response.writeHead(404); response.end(&apos;404 Not Found&apos;); &#125; &#125;);&#125;);server.listen(8080);console.log(&apos;Server is running at http://127.0.0.1:8080/&apos;); 当你的html文件是这样的时候：12345678910&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Road&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;/images/bg.jpeg&quot; alt=&quot;11&quot;&gt; &lt;h1&gt;书山有路勤为径,学海无涯苦做舟。&lt;/h1&gt; &lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 然后请求http://127.0.0.1:8080/index.html就会打印出： 101544689152_.pic.jpg 当然他只能发起请求，想要请求到并且正确返回还需要设置文件的ContentType属性。我们可以使用path.extname获取请求文件的后缀：12let extname = path.extname(&apos;css/index.css&apos;);// .css 我们获取到后缀之后就可以根据后缀来设置它的ContentType，这里需要用到一个mime.json文件，然后使用一个函数去匹配:12345678910111213141516171819//mime 读取mime.json 里面存储了常见的文件的ContentType 为请求的对应的文件设置对应的 ContentType 属性function getContentType(extName, callBack)&#123; // 文件后缀 回调函数 //读取mime.json fs.readFile(&apos;./mime.json&apos;, (err, data)=&gt;&#123; if(err)&#123; //读取失败 抛出错误 throw err; return; &#125; // 读取成功 let mimeJson = JSON.parse(data); //转码 将json字符串转化成对象 let contentType = mimeJson[extName] || &apos;text/plain&apos;; //取出对应json中 对应的 请求的后缀的相匹配的 ContentType 属性 callBack(contentType); //执行这个回调函数 并传参contentType &#125;)&#125; 搭建静态服务器的步骤应该是： 先拿到请求文件的后缀名(extname) 引入mime.json 文件并读取-&gt;转码 匹配和后缀对应的ContentType 使用回调函数 所有请求的文件 都会拿到后缀 然后自动匹配相应的ContentType 执行getContentType函数 1234getContentType(extname, (contentType)=&gt;&#123; res.writeHead(200, &#123;&quot;Content-Type&quot;: contentType + &apos;;charset=UTF-8&apos;&#125;) res.end(data)&#125;) 常见文件的mime类型GitHub-Node 学习笔记参考-Node path模块相关方法","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"使用NodeJS写一个简单的api接口","slug":"使用Node.js写一个简单的api接口","date":"2018-12-15T03:55:55.000Z","updated":"2018-12-21T08:22:22.459Z","comments":true,"path":"2018/12/15/使用Node.js写一个简单的api接口/","link":"","permalink":"http://yoursite.com/2018/12/15/使用Node.js写一个简单的api接口/","excerpt":"","text":"引入Http模块默认你已经安装了Node.jsNode当中内置了Http模块；可以使用1var http= require(&quot;http&quot;); 引入http模块； Hello world用Node.js实现一个HTTP服务器程序非常简单。我们实现一个最简单的Web程序，它对于所有请求，都返回Hello world!，新建一个文件夹apiDemo 在里面新建一个server.js写入：1234567891011121314151617// 导入http模块:var http = require(&apos;http&apos;);// 创建http server，并传入回调函数:var server = http.createServer(function (request, response) &#123; // 回调函数接收request和response对象, // 获得HTTP请求的method和url: console.log(request.method + &apos;: &apos; + request.url); // 将HTTP响应200写入response, 同时设置Content-Type: text/html: response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/html&apos;&#125;); // 将HTTP响应的HTML内容写入response: response.end(&apos;Hello world!&apos;);&#125;);// 让服务器监听8080端口:server.listen(8080);console.log(&apos;Server is running at http://127.0.0.1:8080/&apos;); 然后在当前目录命令提示符下(cmd等)运行， 输入：1node server.js 然后打开浏览器输入：http://127.0.0.1:8080/ 就可以看到： 91544605447_.pic.jpg 同时可以看到命令行中有打印的信息：12GET: /GET: /favicon.ico 主要需要了解的是：1http.createServer(function(request, response)&#123;&#125;) 它的作用是创建一个http服务，里面传一个回调函数，函数中包含两个参数分别是（request，response）。其中request是请求对象，response是响应对象。可以根据request对象拿到请求头的一些信息，如: request.url–返回请求路径响应成功后：response.writeHead()————发送一个响应头给请求response.end(&#39;xxx&#39;)————响应成功 返回xxx参考 Nodez中文网-HTTP 路由我们是想当访问http://127.0.0.1:8080/的时候返回当前目录的index.html。也就是说当request.url === &#39;/&#39;是true时就可以确定当前请求的是根目录了，123var url = request.url;console.log(url);// &apos;/&apos; 我们能创建一个服务，并且能使用response.end(&#39;Hello world!&#39;);返回“Hello world!”。如果想返回一个文件则需要用到Node.js的一个模块了——fs 文件系统。它是Node当中处理文件的模块，首先引入：1var fs= require(&apos;fs&apos;); 可以使用fs.readFile()来读取文件12345fs.readFile(&apos;./index.html&apos;, function(err, data) &#123; if (err) throw err; console.log(data);// &lt;Buffer 3c 21 44 4f 4...&gt;&#125;); 回调函数 有两个参数 (err, data)，其中 data 是文件的内容，以二进制形式返回。 然后我们就可以编写代码了，当访问根目录时，返回index.html文件123456789101112131415161718var http= require(&apos;http&apos;);var fs= require(&apos;fs&apos;);var server= http.createServer(function(request, response)&#123; var url = request.url; if(url === &apos;/&apos;)&#123; fs.readFile(&apos;./index.html&apos;, function(err, data)&#123; if(!err)&#123; response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/html;charset=UTF-8&quot;&#125;); response.end(data) &#125;else&#123; throw err; &#125; &#125;); &#125;else&#123; console.log(&quot;错误&quot;); &#125;&#125;);server.listen(8080, &apos;127.0.0.1&apos;); 然后在当前目录下新建index.html，在这里我们可以写一个ajax请求，一会我们点击按钮来实现ajax请求一组数据：1234567891011121314151617&lt;div id=&quot;box&quot;&gt;看不到看不到&lt;/div&gt; &lt;button onclick=&quot;success()&quot;&gt;我是按钮&lt;/button&gt; &lt;script&gt; function success()&#123; var http= new XMLHttpRequest(); http.onreadystatechange= function()&#123; if(http.status == 200 &amp;&amp; http.readyState == 4)&#123; var msg= http.responseText; var box= document.getElementById(&apos;box&apos;); box.innerHTML= JSON.parse(msg).name; &#125; &#125; //发送请求 http.open(&apos;GET&apos;, &apos;/data&apos;); http.send(); &#125; &lt;/script&gt; 这段代码是点击按钮的时候 会向/data发起一个ajsx请求, 实现简单的API接口既然能访问根目录时可以返回html文件，那我们可以自己设定一个url，当请求这个url是我们就给它返回一组json数据。正常来讲这些数据应该是从数据库读取的，在这里只模拟一组json数据，在当前目录新建一个data.json：1&#123;&quot;name&quot;: &quot;尼古拉丁 * 赵四&quot;&#125; 所以当前的目录结构是： 41544775041_.pic.jpg 然后我们可以在server.js中判断一下，当请求的url是/data时，则返回data.json：12345678910if(url === &apos;/data&apos;)&#123; fs.readFile(&apos;./data.json&apos;, function(err, data)&#123; if(!err)&#123; response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;application/json&quot;&#125;); response.end(data); &#125;else&#123; throw err; &#125; &#125;) &#125; 然后打开浏览器 http://127.0.0.1:8080 后，就会出现index.html页面，点击出现的按钮就会触发一个对 /data的ajax请求，当server.js接受到请求后，就会判断url === &#39;/data&#39;，然后它就会吧 data.json返回给我们。 最后的实现是点击按钮出现尼古拉丁 * 赵四，GItHub源码：node-apiDemo参考：廖雪峰-http详解Node-fs","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"JavaScript的预编译过程分析","slug":"JavaScript的预编译过程分析","date":"2018-12-11T08:05:55.000Z","updated":"2018-12-11T08:43:37.929Z","comments":true,"path":"2018/12/11/JavaScript的预编译过程分析/","link":"","permalink":"http://yoursite.com/2018/12/11/JavaScript的预编译过程分析/","excerpt":"","text":"一、JavaScript概念JavaScript ( JS ) 是一个单线程、解释型的编程语言。 二、JavaScript语言特点2.1 单线程JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。 2.2 解释型语言自上而下，解释一行，执行一行；不会通篇编译为一个文件再执行。 三、 JavaScript执行过程3.1 语法分析 顾名思义 就是检查一遍js代码内有没有出现语法错误（比如少些个分号，多写个括号等）；语法分析期间不会执行代码 3.2 预编译预编译发生在函数执行的前一刻全局下：全局的变量声明和函数声明则会存放在全局对象内（Global Object 简称GO，它是window的一部分，你可以直接把他理解成window对象）中函数体内：预编译会提前把函数里的变量声明和函数声明依据规则存放在该活动对象内（Activation Object，简称AO）， 预编译简单理解就是在内存中开辟一些空间，存放一些变量与函数 。 预编译大致可分为4步： 创建AO(GO)对象 找形参和变量声明，将形参和变量名作为AO(GO)属性名，值为undefined 将实参值和形参统一 在函数体里面找函数声明，值赋予函数体。 所以如果遇到下面这种情况，当函数声明和变量声明名称相同时：123console.log(a); var a= 1;function a()&#123;&#125;; 编译后的代码其实是：1234var a;function a()&#123;&#125;;console.log(a);a= 1; 所以最后输出的是：1function a() &#123;&#125; 预编译小节预编译两个小规则 函数声明整体提升—(具体点说，无论函数调用和声明的位置是前是后，系统总会把函数声明移到调用前面） 变量 声明提升—(具体点说，无论变量调用和声明的位置是前是后，系统总会把声明移到调用前，注意仅仅只是声明，所以值是undefined），只有在解释执行阶段才会进行变量初始化，匿名函数不参与预编译。 预编译前奏 imply global 即任何变量，如果未经声明就赋值，则此变量就位全局变量所有(全局域就是window) 。 一切声明的全局变量，全是window的属性。1234&lt;script&gt; var a=2; console.log(window.a);//2&lt;/script&gt; 3.3 解释执行预编译完毕之后，JavaScript 脚本开始执行，执行顺序按照从上到下的顺序执行。 总结JavaScript执行顺序 语法分析 预编译2.1. 创建AO(GO)对象2.2. 找形参和变量声明，将形参和变量名作为AO(GO)属性名，值为undefined2.3. 将实参值和形参统一2.4. 在函数体里面找函数声明，值赋予函数体。 解释执行 练习：123456789function a(a)&#123; console.log(a); a= 2; console.log(b); var b= 3; console.log(a);&#125;a(1);console.log(a); 你可以先试想一下结果，然后复制代码到控制台去验证你的答案是否正确。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"初试MongoDB学习之Mongoose的使用","slug":"MongoDB学习之Mongoose的使用","date":"2018-11-23T09:28:55.000Z","updated":"2018-12-21T08:20:27.716Z","comments":true,"path":"2018/11/23/MongoDB学习之Mongoose的使用/","link":"","permalink":"http://yoursite.com/2018/11/23/MongoDB学习之Mongoose的使用/","excerpt":"","text":"mongoose简介mongoose官网：https://mongoosejs.com/ 为什么要用Mongoose Mongoose就是一个让我们可以通过Node来操作MongoDB的一个模块。Mongoose本质是一个对象文档模型（ODM）库，他对Node原生的MongoDB模块进行了一部优化封装，并且提供了更多的功能。 Mongoose的优势 可以像操作对象一样操作数据库 可以为文档创建一个模式结构（Schema） 可以对模型中的文档/文档进行验证 数据可以通过类型转换为对象模型 可以使用中间件来应用业务逻辑挂钩 比Node原生的MongoDB驱动更容易 使用Mongoose 下载安装mongoose模块cnpm install mongoose --save 引用mongoose：var mongoose =require(&quot;mongoose&quot;); 使用”mongoose”连接数据库：var db =mongoose.connect(&quot;mongodb://user:pass@localhost:port/database&quot;); 执行下面代码检查默认数据库test，是否可以正常连接成功?1234567891011var mongoose =require(&quot;mongoose&quot;);var db =mongoose.connect(&quot;mongodb://localhost/m_data&quot;);db.connection.on(&quot;error&quot;,function (error) &#123; console.log(&quot;数据库连接失败：&quot; + error);&#125;);db.connection.on(&quot;open&quot;,function () &#123; console.log(&quot;数据库连接成功！&quot;);&#125;);db.connection.once(&apos;close&apos;, ()=&gt;&#123; console.log(&apos;连接已经断开成功！&apos;)&#125;) mongoose基本使用mongoose的几个新的对象在MongoDB中，多个Document可以组成Collection(以下简称集合)，多个集合又可以组成数据库。我们想要操作MongoDB数据，那就得先要具备上面所说的包含数据的“文档”，文档又是什么意思呢，请看如下介绍。 文档 —— 是MongoDB的核心概念，是键值对的一个有序集，在JavaScript里文档被表示成对象。同时它也是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行，但更具表现力。 集合 —— 由一组文档组成，如果将MongoDB中的一个文档比喻成关系型数据库中的一行，那么一个集合就相当于一张表。 Schema—— 一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅只是定义数据的类型，可以说是数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架。mongoose中任何任何事物都是从Schema开始的。每一个Schema对应MongoDB中的一个集合(collection)。Schema中定义了集合中文档(document)的样式。定义一个Schema（表/ 模式对象）123456789//新建Schema 定义规则/字段的规则let Schema= mongoose.Schema;//定义personSchema的字段（规则）需要new一下 有点像构造函数的样子let personSchema= new Schema(&#123; name: String, sex: String, age: Number&#125;);` 基本属性类型有： String Number Date Boolean Buffer ObjectId Mixed Array Model—— 由Schema构造生成的模型，根据Schema定义的数据类型规则，可操作具体的符合改规则的数据。 创建model（集合）1let personModel= mongoose.model(&apos;person&apos;, personSchema); person：数据库中的集合名称,当我们对其添加数据时如果person已经存在，则会保存到其目录下，如果未存在，则会创建person集合，然后在保存数据。123456789101112//4. 插入文档personModel.create(&#123; name: &apos;张宁乐&apos;, sex: &apos;男&apos;, age: 18&#125;, (err)=&gt;&#123; if(!err)&#123; console.log(&apos;插入成功！&apos;) &#125;else&#123; throw err; &#125;&#125;); mongoose 插入和查询mongoose查找数据的一些方法：https://mongoosejs.com/docs/api.html#model_Model.find 插入多条数据12345678910personModel.create([ &#123;name:&apos;张逗逗&apos;,age: 2,sex: &apos;男&apos;&#125;, &#123;name:&apos;牛嘻嘻&apos;,age: 2,sex: &apos;女&apos;&#125;], (err)=&gt;&#123; if(!err)&#123; console.log(&apos;插入成功！&apos;) &#125;else&#123; throw err; &#125;&#125;) 查询 Model.find() 1234567personModel.find(&#123;name: &apos;张宁乐&apos;&#125;, (err, data)=&gt;&#123; if(!err)&#123; console.log(data) &#125;else&#123; throw err; &#125;&#125;) 查询所有 Model.find({}, callback) 1234567personModel.find(&#123;&#125;, (err, data)=&gt;&#123; if(!err)&#123; console.log(data) &#125;else&#123; throw err; &#125;&#125;) 也可以选择查找数据的条件（0隐藏 1显示 id默认显示） 和MongoDB在命令行中的使用方法一样12345678//查询时只显示name personModel.find(&#123;&#125;, &#123;name: 1, _id: 0&#125;, (err,data)=&gt;&#123; if(!err)&#123; console.log(data) &#125;else&#123; throw err; &#125;&#125;) 在find()中 skip（查询开始的位置）和limit（增加的条数）也可以使用12345678personModel.find(&#123;&#125;, &#123;name: 1, _id: 0, age: 1&#125;, &#123;skip: 0, limit: 2&#125;, (err, data)=&gt;&#123; //只显示name 和 age 从第1开始 每次查询2条 if(!err)&#123; console.log(data) &#125;else&#123; throw err; &#125;&#125;) MongoDB的find()、findOne() 等命令在 mongoose里都可以使用具体可参考 ：https://mongoosejs.com/docs/api.html#model_Model.find mongoose 修改和删除参考： https://mongoosejs.com/docs/api.html#model_Model.update 修改方法： Model.update() Model.updateMany() Model.updateOne() Model.watch() 12345678personModel.update(&#123;name: &apos;张宁乐&apos;&#125;, &#123;$set: &#123;age: 20&#125;&#125;, (err, data)=&gt;&#123; if(!err)&#123; console.log(&apos;修改成功！&apos;) console.log(data) &#125;else&#123; throw err; &#125;&#125;) 4a9f49d480f66c5a64cb9a833459fdd.png 删除方法 Model.remove() Model.deleteMany() Model.deleteOne()1234567personModel.remove(&#123;name:&apos;牛嘻嘻&apos;&#125;, (err)=&gt;&#123; if(!err)&#123; console.log(&apos;删除成功！&apos;) &#125;else&#123; throw err; &#125;&#125;) 统计文档条数 Model.count() 1234567personModel.count(&#123;&#125;, (err,count)=&gt;&#123; if(!err)&#123; console.log(&apos;查询条数成功！ 一共：&apos; + count + &apos;条&apos;); &#125;else&#123; throw err; &#125;&#125;) 2b7684dc310af51ac7fb50e5daa1123.png Entity Entity—— 由Model创建的实体，使用save方法保存数据，Model和Entity的操作都能影响数据库的操作，但Model比Entity更具操作性。使用Model创建Entity，如下示例:12345678910111213141516171819202122232425let mongoose= require(&apos;mongoose&apos;);let db= mongoose.connection(&apos;mongodb://localhost/m_data&apos;);db.on(&apos;open&apos;, ()=&gt;&#123; console.log(&apos;连接成功！&apos;)&#125;)let Schema= mongoose.Schema;let personSchema= new Schema(&#123; name: String, sex: String, age: Number&#125;);let personModel= mongoose.model(&apos;person&apos;, personSchema);let personEntity = new personModel(&#123; name: &apos;许巍&apos;, sex: &apos;男&apos;, age: 38&#125;)personEntity.save((err, person)=&gt;&#123; if(!err)&#123; console.log(&apos;保存成功！&apos;) console.log(person); &#125;else&#123; console.log(&apos;保存失败！&apos;) &#125;&#125;) c85c9b12f87f890e10e74f23555c802.png 参考：https://blog.csdn.net/swimming_in_IT_/article/details/80723866","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"}]},{"title":"MongoDB中常用语句","slug":"MongoDB中常用语句","date":"2018-11-17T14:23:20.000Z","updated":"2018-12-21T08:24:33.861Z","comments":true,"path":"2018/11/17/MongoDB中常用语句/","link":"","permalink":"http://yoursite.com/2018/11/17/MongoDB中常用语句/","excerpt":"","text":"MOngoDB 删除语句delete()删除 删除一个集合db.collection.deleteOne() 删除多个集合db.collection.deletMany(); remove()删除 删除所有的name：李四的数据db.student.remove({name:&quot;李四&quot;}); 只删除一条sex:男的数据 仅删除一条db.student.remove({sex:&quot;男&quot;},true); 删除全部db.student.remove({}); 数据库假删除有时候用户删除操作的时候，需求是这样的，仅是隐藏这条数据，并不是真的从数据库中删除。这时候就用到假删除了，比如这个是张三发的两篇微博：1234db.student.insert([ &#123;name:&quot;张三&quot;,content:&quot;今天心情好&quot;,isDel:0&#125;, &#123;name:&quot;张三&quot;,content:&quot;今天心情一般&quot;,isDel:0&#125;,]); b21d2b7140562e21fcbe9c168e02da9.png 用户增加两条数据，但只保留后一条，删除前一条，这时候用到假删除 ，在添加数据时加上一个字段isDel:0所以当用户删除数据时候 执行的不是remove方法而是update方法12345db.student.update(&#123;&quot;_id&quot; : ObjectId(&quot;5bd6a46f1eb7a22fa07cb382&quot;)&#125;,&#123; $set:&#123; isDel:1 &#125;&#125;); 98cf763807e662cd724e6d65f1638fb.png 当isDel:0是表示用户没有删除 为1是表示用户已经删除 所以在查询的时候要筛选name和isDel条件即可1db.student.find(&#123;name:&quot;张三&quot;,isDel:0&#125;); 查询到用户没有删除的数据: 121b7fc4d6f40af1de843359cdbf585.png 然后就可以实现假删除了。 批量数据的操作和修改 向集合中插入10000个文档 123456var arr= [];for(var i=0;i&lt;10000;i++)&#123; arr.push(&#123;counter:i&#125;);&#125;db.demos.insert(arr);db.demos.find(); 查询demos中counter为666的文档db.demos.find({counter:666}); 查询demos中counter小于66的文档db.demos.find({counter:{$lt:666}}); 查询demos中counter大T666的文档db.demos.find({counter:{$gt:666}}); 查询demos中counter大于66小于666的文档1120查吉demos集合中的前10余数据db.demos.find({counter:{$gt:66, $lt:666}}); 查石demos集合中的第1字到20条数据db.demos.find().limit(10); 查春demos集合中的第2 1条到30条数据 分页功能 skip从多少条开始 limit每次查询多少条 123db.demos.find().skip(0).limit(10);//第一页 从0条开始 每查询10条db.demos.find().skip(10).limit(10);//第二页 从10条开始 每查询10条db.demos.find().skip(20).limit(10);//第三页 从20条开始 每查询10条 集合中文档关系 一对一（noe to noe）:比如：人和身份证 老公和老婆 一对多（noe to many）:比如：父母和孩子 用户和物品 多对多（many to many）:比如：老师和学生 一对一以内嵌文档的形式体现，1234567//一对一db.aAndb.insert([ &#123;name:&quot;杨过&quot;,wife:&#123;name:&quot;小龙女&quot;,sex:&quot;女&quot;&#125;,sex:&quot;男&quot;&#125;, &#123;name:&quot;杨过&quot;,wife:&#123;name:&quot;小龙女&quot;,sex:&quot;女&quot;&#125;,sex:&quot;男&quot;&#125;])db.aAndb.find(); 一对多通过内嵌文档的形式实现或者通过集合的形式实现12345678//一对多 比如 微博 和 微博评论//添加微博db.weibo.insert([&#123;weibo:&quot;世界这么大，我想去看看&quot;&#125;,&#123;weibo:&quot;我要做一名web开发者！！！&quot;&#125;])db.weibo.find(); 添加评论1234567891011121314151617181920db.comments.insert([&#123;weibo_id: ObjectId(&quot;5bdd89e06a5e78f4cfc2b9c8&quot;),list:[ &quot;那你有钱吗&quot;, &quot;一个人吗？？去呢啊？？&quot;, &quot;加油！！&quot;]&#125;,&#123;weibo_id: ObjectId(&quot;5bdd89e06a5e78f4cfc2b9c9&quot;),list:[ &quot;那你要学习HTML&quot;, &quot;那还要你要学习css&quot;, &quot;加油！！&quot;]&#125;]);db.comments.find(); 查询一对多12var weibo_id= db.weibo.findOne(&#123;&quot;weibo&quot; : &quot;世界这么大，我想去看看&quot;&#125;)._id;db.comments.find(&#123;weibo_id: weibo_id&#125;); 多对多的关系比如：学生和老师可以通过多文档关联，123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//多对多 老师《------》学生//插入老师集合db.teachers.insert([&#123; name:&quot;语文老师&quot;, teacher_id: 1, student_id:[ 1001, 1002, 1003 ] &#125;,&#123; name:&quot;数学老师&quot;, teacher_id: 2, student_id:[ 1001, 1002, 1003 ] &#125;,&#123; name:&quot;英语老师&quot;, teacher_id: 3, student_id:[ 1001, 1002, 1003 ] &#125;])db.teachers.find();//插入学生集合db.students.insert([&#123; name:&quot;小明&quot;, student_id: 1001, teacher_id:[ 1, 2, 3 ] &#125;,&#123; name:&quot;小红&quot;, student_id: 1002, teacher_id:[ 1, 2, 3 ] &#125;,&#123; name:&quot;小刚&quot;, student_id: 1003, teacher_id:[ 1, 2, 3 ] &#125;])db.students.find();db.teachers.find(); 排序和索引排序：查询文档时，默认是按照_id的值进行排序的（升序）sort() 可以用来指定文档的排序规则，sort() 内部需要传递一个对象来指定文档的排序规则 ，其中1表示升序 ，-1表示降序limit skip sort 的顺序可以任意改变 ，运行时会自动调整。不希望它默认按照id排序 希望它按照工资来排序123456//按照工资升序排列db.section.find().sort(&#123;wages:1&#125;);//优先按照工资升序排列 如果遇到相同的就在 按照id升序排列db.section.find().sort(&#123;wages: 1&#125;,&#123;_id: -1&#125;); 索引：展示字段中 部分内容或者是提取这个字段内的部分内容在查询时 ，可以在第二个参数来设置查询的结果投影 索引： find({ 查询条件 }, { 检索范围（1显示 0隐藏）})注意： _id如果不设置默认是1（显示） 可手动隐藏 db.section.find({}, {name: 1});12//只显示name和wages字段`db.section.find(&#123;&#125;, &#123;name: 1, _id: 0, wages: 1&#125;);` a07a1f2945204ef671ddebc28871c00.png","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"}]},{"title":"初试MongoDB数据库","slug":"初试MongoDB数据库","date":"2018-11-15T06:04:55.000Z","updated":"2018-12-21T08:21:38.380Z","comments":true,"path":"2018/11/15/初试MongoDB数据库/","link":"","permalink":"http://yoursite.com/2018/11/15/初试MongoDB数据库/","excerpt":"","text":"数据库基本概念数据库（Database）基本概念： 数据库就是按照一定的数据结构来组织，储存和管理数据的仓库 我们写的程序都是在内存中运行的，一旦程序运行结束或者计算机断点，程序运行中的数据就会全部丢失；所以我们就需要将一些程序的数据持久化到键盘之中，以确保数据的安全性。 数据库则是大批量数据持久化的普遍选择，1.文件 2. 数据库 为什么都采用数据库来储存数据: 数据库是有结构的 数据库可以提供各种接口，让数据处理（增删改查）快捷方便 各种语言（PHP jsp .net..）提供了完善的接口 b6dde1cf95ae2a9ec8e68c0bf1719a3.png ###数据库分类 ROBMS（关系型数据库）： 比如MySql 、sql server Oracle 等 特点 通过一张张表来建立关联 基本都使用SQL语言来管理数据库， Nosql (非关系型数据库)： 没有行 、列的概念 用json类储存数据 集合相当于“表”，文档相当于“行” 标准化和非标准化的摩擦。 标准化限制创新，非标准话不能统一 特征： 使用键值（Key Value）储存数据；MongoDB的逻辑结构是一种层次结构，主要由：文档(document)、集合(collection)、数据库(database)这三部分组成的。 文档(document)：由键/值对构成，像{a:1}；{s:”abc”}等，它是MongoDB核心单元，MongoDB的文档（document），相当于关系数据库中的一行记录。 集合（Collection）：多个文档组成一个集合（collection），相当于关系数据库的表。 数据库（database）：多个集合（collection），逻辑上组织在一起，就是数据库（database）。一个MongoDB实例支持多个数据库（database）。 关系型数据库和非关系型数据库区别：关系型数据库比较结构化，操作不是很灵活，菲关系型数据库操作灵活，但不适合大型数据存储，比较适合微架构，两者是相辅相成的关系 8bc32dd95a923344fdc2710d2fcbeab.png 非关系型数据库使用方面： 数据模型比较简单 需要灵活性更强的后台系统 对数据库性能要求比较高 不需要高度的数据一致性 非关系型数据库主要适合小微型架构的使用 数据库MongoDB安装MongoDB（非关系型数据库）： 适合快速开发web应用而设计的数据库系统 设计目标是极简、灵活、经常在web应用栈的业务层被运用 它的数据模型是面向文档的，类似于json的结构 所以这个数据库中是各种各样的json, 并以键值形式对存储 安装：下载:https://www.mongodb.com/偶数是稳定版，奇数是开发版最好下载64位的系统版本的 配置环境变量: 新建—&gt;安装到bin路径复制到环境变量 创建data-&gt;db文件夹 打开命令行输入mongod启动DB服务器 指定端口号和路径 mongod –dbpath d:\\data\\db 将MongDB设置为系统服务，data\\log创建配置文件在bin下穿件文件mongod.cfg执行一段命令：1sc.exe create MongoDB binPath= &quot;\\&quot;F:\\MongoDB\\Server\\3.2\\bin\\mongod.exe\\&quot; --service --config= \\&quot;F:\\MongoDB\\Server\\3.2\\mongod.cfg\\&quot;&quot; DisplayName= &quot;MongoDB&quot; start= &quot;auto&quot; 主要是让MongoDB一直运行在内存中参考资料：https://www.cnblogs.com/wzlblog/p/6364045.htmlhttps://www.cnblogs.com/chenlq/p/6515876.html 在命令行中使用MongoDB插入命令MongoDB的组成： 数据库 数据库是一个仓库 在仓库里可以放集合 集合： 集合类似数组 在集合里可以放文档 文档：文档是数据库中最小的单位 我们储存和操作的内容都是文档。 基本指令：show dbs 显示当前所有的数据库use 数据库名 进入到指定数据库db 显示当前所在的数据库show collections 显示数据库中的所有集合 使用管理员打开 cmd输入 mongo进入MongoDB的环境进入MongoDB的环境才能执行MongoDB的命令然后使用命令行进行CRUD(增删改查)：db.&lt;collection&gt;.insert(doc) 举例子：想school数据库中的学生集合student中插入一个新的学生对象增加一条数据：db.student.insert({id:&quot;001&quot;,name:&quot;znl&quot;,age:18,sex:“男”})在当前的集合（school）中新建一条数据 查询一条数据：db.&lt;collection&gt;.find(); 如：db.student.find();回车 就能查询student下的所有数据插入多条数据：123456db.集合名.insert([ &#123;name:&quot;张三&quot;,age:18,sex:&quot;man&quot;&#125;, &#123;name:&quot;张三&quot;,age:18,sex:&quot;man&quot;&#125;, &#123;name:&quot;张三&quot;,age:18,sex:&quot;man&quot;&#125;, &#123;id:18，name:&quot;张三&quot;,age:18,sex:&quot;man&quot;&#125;]); 插入多条数据时把多条语句放在一个数组里插入可随便插入 不必拘泥于字段是否相同 当插入的字段不存在时会自动创建该字段 查看更多更多操作：http://www.mongodb.org.cn/manual/ MongoDB 可视化工具 【NOSQL】然而一直使用命令行操作是很麻烦的事情，所以推荐使用NOSQL可视化工具安装可视化工具下载地址：https://www.mongodbmanager.com/download 使用可视化工具可视化工具 查找功能：插入(insert)语句：1234db.student(集合名字).insert([&#123;id:1,name:&quot;znl&quot;,age:18&#125;,&#123;id:1,name:&quot;znl&quot;,age:18&#125;,]); 查询语句：db.student(集合name).find(); 设定条件查询：db.student.find({ &quot;_id&quot; : ObjectId(&quot;5bd01c825f0d528d36a2c06f&quot;)});查询id对应的数据db.student.find({age:18,name:&quot;张三&quot;});查询所有的age是18并且name是张三的人db.student.findOne({age:18,name:&quot;张三&quot;});查询单条符合条件的数据 操作符-查询有多少条数据：db.student.find().count();或db.student.find().length();返回数据总条数 查询符合条件数据的条数：db.student.find({name:&quot;张三&quot;}).length();返回符合name:”张三”的条数 数据库更新命令更新原有的字段的数据：1234db.student.update(&#123;&quot;name&quot;:&quot;张三&quot;&#125;,&#123;$set:&#123; name:&quot;刘五&quot;, age:45&#125;&#125;); 把匹配到的name:&quot;张三&quot;的数据都更新成 name:&quot;刘五&quot;, age:45也可以新增没有的字段 直接写入就可以$set ：有这个字段就修改 没有这个字段就新增 删除一个字段：123db.student.update(&#123;&quot;name&quot;:&quot;张三&quot;&#125;，&#123;$unset:&#123; age:1&#125;&#125;); 查询name:张三的一条数据 然后删除它的age字段 修改多条：123db.student.updateMany(&#123;&quot;sex&quot;:&quot;man&quot;&#125;,&#123;$set:&#123; aihao:&quot;玩游戏&quot;&#125;&#125;); 把符合sex:man的语句都新增（修改）一条aihao:&quot;玩游戏&quot;$set ：有则修改 无则新增 更新多条数据方法2：12345db.student.update(&#123;name:&quot;张三&quot;&#125;,&#123;$set:&#123; name:&quot;王五&quot;&#125;&#125;, &#123; multi:true&#125;); 参考文档：https://docs.mongodb.com/manual/tutorial/query-documents/","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"}]},{"title":"NodeJS文件系统（fs）与流（stream）","slug":"NodeJs文件系统（fs）与流（stream）","date":"2018-11-08T06:04:55.000Z","updated":"2018-12-21T08:22:45.054Z","comments":true,"path":"2018/11/08/NodeJs文件系统（fs）与流（stream）/","link":"","permalink":"http://yoursite.com/2018/11/08/NodeJs文件系统（fs）与流（stream）/","excerpt":"","text":"文件系统（File System）： 在Node中，文件系统的交互是非常重要的，服务器的本质就是将本地的文件发送给客户端， Node通过fs模块来和文件系统进行交互，该模块提供了一些标准的文件访问API类打开、读取、写入文件、以及与其交互。 要是用fs模块，首先要从核心模块中加载； 使用 const fs= require(‘fs’) ; 来引入 fs使用特点： fs模块中的所有操作都有两种形式可供选择同步和异步， 同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码。 异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回。 12345678910111213141516//1\\. 引入模块const fs= require(&quot;fs&quot;);// console.log(fs)//2\\. 打开文件// fs.open 异步读取（通常用异步 需设置回调函数） // fs.openSync 同步读取（读取时会阻塞线程）let hello = fs.openSync(&quot;hello.txt&quot;, &quot;w&quot;);// 不存在会自动新建//3\\. 写入内容fs.writeFileSync(hello,&apos;hello word!&apos;);//4\\. 保存并退出fs.closeSync(hello); 文件操作： 打开文件：fs.open(path,flags[,mode],callback)异步打开 异步都是回调 回调嵌套回调fs.openSync(path,flags[,mode])同步打开 文件标记（flags）： http://nodejs.cn/api/fs.html#fs_fs_open_path_flags_mode_callback 一、同步打开文件1234567891011//1\\. 引入模块 let fs = require(&apos;fs&apos;);//2.打开文件 同步var fd=fs.openSync(&apos;1.txt&apos;, &apos;w&apos;);//3.写入内容fs.writeFileSync(fd,&quot;hello world!&quot;); //4\\. 保存并关闭fs.closeSync(fd); 二、异步打开文件12345678910111213141516171819202122232425262728//1.引入模块let fs = require(&apos;fs&apos;);//2\\. 打开文件fs.open(&apos;1.txt&apos;, &apos;a&apos;, (err, fd)=&gt;&#123; //2.1判断是否出错 if(!err)&#123; //正确 2.2写入文件 fs.writeFile(fd, &quot;今天天.....气真好！&quot;, (err)=&gt;&#123; //2.2.1 写入成功 if(!err)&#123; console.log(&apos;写入成功&apos;); &#125;else&#123; throw err; &#125; //2.3 关闭文件 fs.close(fd, (err)=&gt;&#123; if(!err)&#123; console.log(&apos;文件以保存并关闭&apos;) &#125;else&#123; throw err; &#125; &#125;) &#125;) &#125;else&#123; throw err; &#125;&#125;) 使用文件流写入文件流写入： http://nodejs.cn/api/fs.html#fs_fs_createwritestream_path_options 123456789101112131415161718192021//同步操作//1\\. 引入模块let fs= require(&apos;fs&apos;);//2.建立通道let ws = fs.createWriteStream(&apos;fsw.txt&apos;)//3.打开通道ws.once(&apos;open&apos;, ()=&gt;&#123; console.log(&apos;通道已经打开&apos;);&#125;)ws.once(&apos;close&apos;, ()=&gt;&#123; console.log(&apos;通道已经关闭&apos;);&#125;)//4\\. 写入内容ws.write(&apos;我爱你，&apos;);ws.write(&apos;我爱你，&apos;);ws.write(&apos;我爱你，&apos;); 读写文件：文档地址：http://nodejs.cn/api/fs.html#fs_fs_readfile_path_options_callback读取文档： 123456789101112131415161718192021222324252627282930313233//1\\. 引入模块let fs = require(&apos;fs&apos;);//2\\. 读取文件fs.readFile(&apos;source/hello.txt&apos;,&apos;utf8&apos;,(err,data)=&gt;&#123; //判断是否成功 if(!err)&#123; console.log(data);// // console.log(data.toString()); //data 默认读取的是二进制 使用toString() 方法转换成 &#125;else&#123; throw err; &#125;&#125;)读取图片：//3\\. 读取图片fs.readFile(&quot;source/psb.jpg&quot;,(err,data)=&gt;&#123; //判断是否成功 if(!err)&#123; //写入图片 fs.writeFile(&apos;img.jpg&apos;, data, (err)=&gt;&#123; if(!err)&#123; console.log(&apos;写入成功！&apos;) &#125;else&#123; throw err; &#125; &#125;) &#125;else&#123; throw err; &#125;&#125;); 读取视频: 12345678910111213141516171819202122232425262728//1\\. 引入模块let fs= require(&apos;fs&apos;);//2\\. 读取视频fs.readFile(&apos;source/cddbb.mp4&apos;, (err, data)=&gt;&#123; if(!err)&#123; // 写入视频 fs.writeFile(&apos;nmx.mp4&apos;, data, (err)=&gt;&#123; if(!err)&#123; console.log(&apos;写入成功！&apos;); &#125;else&#123; throw err; &#125; &#125;) &#125;else&#123; throw err; &#125;&#125;)//3\\. 流式文件的读入（批量文件处理）let re= fs.createReadStream(&apos;source/cddbb.mp4&apos;);//建立读取流let ws= fs.createWriteStream(&apos;新建的视频.mp4&apos;);//建立写入流//4\\. 创建管道re.pipe(ws);//文件流传输console.log(&apos;文件流传输完成&apos;) 参考：详解NodeJS文件系统fs我的GitHub总结的NodeJS笔记","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"NodeJS中的Buffer","slug":"Node中的Buffer","date":"2018-11-05T06:04:55.000Z","updated":"2018-12-21T08:22:49.824Z","comments":true,"path":"2018/11/05/Node中的Buffer/","link":"","permalink":"http://yoursite.com/2018/11/05/Node中的Buffer/","excerpt":"","text":"Buffer介绍为什么要用Buffer？ 在Node/ES6 出现之前，前端工程师只需要进行一些简单的额字符串或者ODM操作就可以满足业务需求了，所有对二进制数据比较陌生。 在node出现之后，前端工程师面对的技术场景发送了变化，可以深入到网络传输、文件操作、图片处理等领域。而这些操作与二进制数据紧密相关。 在Node中的Buffer，是一个二进制数据容器，数据结构和数组类似，专门用于Node中的数据放。 新建BufferBuffer.alloc(size[, fil[,encoding]])size:新建的buffer期望的长度fill用来预填充新建的Buffer的值 默认0encoding: 编码格式 默认：utf-812345678910111213141516171819202122232425/* 十六进制：00- ff 十进制 ：0- 255 二进制： 00000000- 11111111 0 / 1 代表一位 == 比特 8bit = 1B 1kb = 1024 B 1mkb= 1024Kb 1GB = 1024m 1TB = 1024GB*/// 2. Buffer.alloc(size[, fill[, encoding]])/*类数组使用即可 可遍历 可选择下标等等初始化： 确定的长度 不能改变填充值*/let buffer2= Buffer.alloc(10);//创建了一个长度是10的bufferbuffer2[0]= 10;//可以像使用数组一样使用buffer buffer2[1]= oxfc;//传一个十六进制的直接取后两位 fcbuffer2[30]= 1;//这点和数组不同 溢出隐藏 console.log(buffer2); Buffer使用使用新方法使用Buffer Buffer.form(str):将一个字符串转换成buffer Buffer.alloc(size):创建一个指定大小的buffer Buffer.alloUnsafe(size):创建一个指定大小的buffer，但是可能包含敏感数据。1234567891011// 历史方法// let buffer = new Buffer(10);//类似 Array(10) 创建十个空间// console.log(buffer)// &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;//1. 字符串转成二进制let str= &apos;www.zhangningle.top&apos;;let buffer= Buffer.from(str);console.log(buffer);//&lt;Buffer 77 77 77 2e 7a 68 61 6e 67 6e 69 6e 67 6c 65 2e 74 6f 70&gt;//把buffer转成十进制的console.log(buffer.toString())//www.zhangningle.top// 汉字转换成二进制后 一个汉字要用三个字节表示 Buffer总结点： Buffer的结构和数组很像，操作方法也和数组很类似。 Buffer中是以二进制的方式储存数据的 Buffer是Node自带的，不需要引入，直接可以使用。","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"NodeJS中的CommonJS规范","slug":"CommonJS模块化开发","date":"2018-10-18T06:04:55.000Z","updated":"2018-12-21T08:24:19.287Z","comments":true,"path":"2018/10/18/CommonJS模块化开发/","link":"","permalink":"http://yoursite.com/2018/10/18/CommonJS模块化开发/","excerpt":"","text":"模块化的意义 在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Node环境中，一个.js文件就称之为一个模块（module）。 理解模块化最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括Node内置的模块和来自第三方的模块。使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。 每一个文件都可以看成一个模块，模块都可以相互暴露和相互引用1.在Node中 一个文件就是一个模块2.在Node中，通过require()函数来引入外部的模块，引入外部模块要加上 ./ 或者 ../3.在Node中，每一个js文件中js代码都是独立运行在一个小闭包中，而不是全局作用域，所以一个模块在不引用的情况下它的的变量和函数都在其他模块中无法访问，如果引用到其他模块中，则被引用的文件相当与在一个闭包内，相当与局部变量。目的：全局变量私有化，避免全局污染。4.暴露模块中的变量和函数：使用exports只需要将需要暴露给外部的变量或者方法设置为exports的属性就行，可以把exports看做一个全局对象，把所有暴露出来的函数和变量都存放在里面Node有一些自带的模块，成为核心模块，他的引用不需要加./ 或者../ 如fs http 引用：const moudel = require (&#39;./02.js&#39;)暴露：exports.str = srt; CommonJS案例先写一个01.js暴露出去：12345678let str = &quot;我是小二&quot;;let test = ()=&gt;&#123; console.log(&quot;今天天气很好!&quot;);&#125;exports.str = str;exports.test = test; 在写一个02.js把暴露的01.js引用过来, 然后暴露自身123456const module02 = require(&apos;./01.js&apos;);// [ ./ ../ ]exports.module02 = module02; //暴露console.log(module02.str);//我是小二 最后在写一个03.js 引用暴露的02.js， 这样在03.js 里就包含了 02.js 和01.js了：12const module03 = require(&apos;./02.js&apos;);console.log(module03.module02.str)//我是小二 所以最后是这样的： 161539764109_.pic.jpg 类似一个同心圆 案例：写一个求和 / 求平均数的模块123456789101112131415exports.sun = (...numbers)=&gt;&#123; let result = 0; numbers.forEach((itme)=&gt;&#123; result += itme; &#125;); return result;&#125;exports.avg= (...numbers)=&gt;&#123; let result = 0; numbers.forEach((itme)=&gt;&#123; result+= itme; &#125;); return result / numbers.length;&#125; 参考资料：廖雪峰的官网-模块开发视频资料：网易云课堂-叶建秋-从零玩转Node.js","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"NodeJS安装和使用","slug":"NodeJS安装和使用","date":"2018-10-11T02:04:55.000Z","updated":"2018-12-21T08:20:34.616Z","comments":true,"path":"2018/10/11/NodeJS安装和使用/","link":"","permalink":"http://yoursite.com/2018/10/11/NodeJS安装和使用/","excerpt":"","text":"了解NodeNodeJS :主要应用于开发服务器，做数据API ,设计路由，和前端的主要区别在于，前端主要负责效果和交互、node.js是追求性能极致的产物，主要的三个特点是：单线程、Non-blocking I/O、Event DrivenNodejs和其他后端语言的不同： 采用单线程， 所以 需要非阻塞I/O，所以 需要事件驱动。极大地提高了CPU的利用率： node没有自己的语法，使用V8引擎，用的是js，V8引擎解析js，效率非常高。并且V8中很多东西都是异步的，，Node就是站在巨人的肩膀上，把V8中的一些功能一直到服务器上 没有web容器 就是安装配置完成之后，也么有一个根目录。（使用路由） 模块：在Node.js中，以模块为单位划分所有的功能，并且提供了一个完成的模块加载机制，我们可以将应用程序划分为各个不同的部分。 Windows命令常用命令：dir 列出当下目录下面的所有文件cd 进入指定的目录md 创建文件夹rd 删除文件夹cd.. 返回上级目录 81539743638_.pic.jpg Mac命令cd ~进入我们的家目录ls 列出当下目录下面的所有文件cd 目录名 进入指定的目录touch 文件名.html创建一后缀是html的文件或者一次touch a.txt b.html一次创建多个文件mkdir 文件夹名 新建一个文件夹或者一次mkdir a b c新建三个文件夹rm 文件/文件夹删除文件/文件夹less index.html查看文本文件内容pwd看看自己在哪个目录下man 查看某个命令的详情cd.. 返回上级目录 小技巧用 Tab 键自动补齐命令比如想到 /System 目录中去，输入 cd /Sy 然后按一下Tab 键，命令就会自动补齐成 cd /System操作带名字中带有空格的文件和目录空格在命令中写成 空格， 比如要进入 My Documents，命令为 cd My Documents 进程和线程： 1.进程 系统进行资源分配和调度的基本单位 操作系统的基础，我们写的代码都是放在进程里的 相当于工厂的车间 如：任务管理器 2.线程 九三级的最小计量单位 负责执行进程中的程序，相当于车间里的操作工人，单线程： js是单线程，时间片分割多线程： 根据任务决定开起几条线程（耗内存）Node服务器： 单线程，但很健壮，后台拥有一个I/O线程池进行调度。分布式服务器部署。 91539744120_.pic.jpg 安装node.js 101539744899_.pic.jpg node.js 下载有些可能需要配置全局环境变量 121539745565_.pic.jpg node -v查看版本号 node 进入node环境，在这个环境中可以执行JavaScript语句 让node.js跑起来跑起来 node.js 1.node 命令行下写js代码 2.新建.js文件 &gt; cd 到指定目录 &gt; node index.js 131539747126_.pic.jpg 建议使用最新的编辑器 有代码提示 Node.js 的模块发开发Node 需要模块化开发：问题： js缺乏模块化的开发解决：后来出现了commonJs （内部） 和npm（外部 包管理系统）它提供了模块的复用和引用, CommonJs的出现 主要是为了弥补JavaScript没有模块化开发标准的缺陷， CommonJS对模块化的定义： 模块引用 require（“路径”）2.模块定义3.模块表识 141539756072_.pic.jpg 总结：1.从文件的角度看，每个js文件就是一个模块，从结构看，多个js文件之间可以相互require，共同实现一个功能，整体上也是一个模块。2.在Node.js中，一个模块中的定义的变量、函数等。都只能在这个文件内部有效；当需要从此文件外部引用这些变量、函数时，必须使用exports进行暴露，然后使用require引用。 A：我需要引用你 &gt;&gt; require BB: 那好 &gt;&gt; 我暴露 13课至17课笔记视频地址：https://study.163.com/course/courseMain.htm?courseId=1005269026","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"}]},{"title":"Vue.js 知识点总结","slug":"Vue知识点总结","date":"2018-09-17T06:04:54.000Z","updated":"2018-11-04T12:42:33.903Z","comments":true,"path":"2018/09/17/Vue知识点总结/","link":"","permalink":"http://yoursite.com/2018/09/17/Vue知识点总结/","excerpt":"","text":"基础知识： vue的生命周期： beforeCreate/created、beforeMount/mounted、beforeUpdate/updated、beforeDestory/destoryed vue常用指令： v-for、v-bind（缩写形式:prop）、v-on(缩写形式@click=’sss&#39;)、v-if/v-else/v-else-if、v-model、v-once、v-html、v-show… vue自定义组件：Vue.component(‘componentName&#39;,{ props:[‘p1’,’p2’], template: ‘&lt;li&gt;&lt;/li&gt;&#39; }) vue常用实例方法和属性: data/$data、methods/$methods、$el、computed(计算属性)、$watch、$set、$event、$emit… 如果需要更新的属性需要缓存，则使用计算属性的方式，否则可以使用methods里的方法来更新属性（methods里的方法每次重新渲染都会执行） 计算属性默认提供了getter，你还可以给它设置setter 当你数据变化是异步或者开销较大时，可以使用watch侦听器来响应数据的变化 v-bind:class的值可以是一个对象，可实现类似react中classnames模块的功能 自定义组件上的class会被渲染拼接到template的根节点的class属性上（自定义组件上可使用v-bind:class来做class的判断显示逻辑） v-bind:style可以用来绑定内联样式，这个内联样式的值可以由一个对象来定义（类似css in js的模式）,且可以被定义为数组(多个样式对象) v-bind:style可以使用多重值的形式：&lt;div :style=“display:[‘-webkit-box’,’-ms-flexbox’, ‘flex&#39;]&quot;&gt;&lt;/div&gt; v-if/v-else/v-else-if的时候，可以用key来管理可复用的元素 v-if是’真正’的渲染，它会确保在切换条件过程中条件块内的元素的事件监听器和子组件适时的销毁和重建 v-if是惰性的，初始为假，什么也不做，直到为真的时候才渲染元素 v-show总是渲染元素，只是简单的进行切换 v-if的切换开销大，v-show则是初始渲染开销大，频繁切换使用v-show，运行时经常改变则使用v-if v-if和v-for一起使用时，v-for的优先级更高 v-for可遍历数组，第二个参数是索引 v-for可遍历对象，第二个参数是key，第三个参数是索引 v-for和&lt;template&gt;搭配可减少渲染次数 v-for和自定义组件使用时，需要使用props来传递值 尽可能的为遍历子元素加上key，获得渲染优化 数组变异方法：push/pop/unshift/shift/splice/sort/reverse改变原始数组 数组非变异方法：filter/concat/slice 不改变原始数组，总是返回新数组 Vue不能检测到数组索引赋值（使用vm.$set解决）和修改length长度赋值(使用splice解决)的情况 Vue不能检测对象属性的添加和删除(使用vm.$set或Object.assign) is=“todo-item”这种属性的写法比较适合DOM模板 事件修饰符，它们可串联使用：.stop、.prevent、.capture、.self、.once、.passive(尤其适合移动端) .passive不用同时和.prevent使用，后者会被忽略 按键修饰符: .enter、.tab、.delete、.esc、.space、.up、.down、.left、.right 系统按键修饰符:.ctrl、.alt、.shift、.meta(⌘|⊞|◆)、.exact(允许精确控制系统修饰符组合键触发) 鼠标修饰符： .left、.right、.middle v-model会忽略表单元素的value、checked、selected，仅仅使用实例中的数据作为数据源 表单事件修饰符：.lazy、.number、.trim 组件是可复用的vue实例，具有vue实例大多数属性和方法 组件可复用，每个组件有独立的空间 组件上的data必须是一个函数，这样做避免影响了其他组件 通过Vue.component()全局注册的组件可在其被注册后的任何通过new Vue()创建的实例所使用，包含其组件树中的所有组件 通过插槽&lt;slot&gt;分发内容(其实就是类似于react的children) 动态组件&lt;component&gt;配合属性is来实现 解析DOM模板时需要注意下可能会有不生效的情况，需要使用is来传递组件 Vue组件 全局注册/局部注册 局部注册组件在子组件中不可用 全局注册的行为必须在根Vue实例创建之前发生 camelCase的属性可以在组件中使用kebab-case 可以以对象的模式指定每一个props属性的类型 父级props的更新会向下流动，反之则不行 由于JavaScript对象和数组是引用传入的，所以当子组件对props的改变将会影响到父组件 props类型校验可以是原生构造对象的中的任意一个，也可以自定义检验类型，通过instanceof检查 对于绝大多数特性来说，外部传入的值会替换掉组件内部设置好的值，如input的type属性，但有的属性则是会进行合并，如class inhertAttrs:false设置不希望根元素继承特性，可以使用$attrs属性来设置继承的目标元素 v-on在设置事件监听器时，会把事件名全部转换成小写，推荐始终使用kebab-case的事件名 v-model可以使用自定义组件中的model属性自定义 父组件模板的所有东西都会在父级作用域内编译，子组件的所有内容都会在子组件作用域内编译 插槽(&lt;slot&gt;&lt;/slot&gt;)/具名插槽(&lt;slot name=“header&quot;&gt;&lt;/slot&gt;)/作用域插槽(slot/slot-scope) &lt;keep-alive&gt;组件可用来缓存被切换后隐藏的组件的状态 $root访问根实例，$parent访问父组件实例(不推荐) 父组件访问子组件，使用$refs属性来获取设置了ref属性的子组件 provide属性允许我们指定要分享给后代组件使用的方法，然后后代组件使用inject属性来获得祖先组件分享的方法(依赖注入) 事件侦听器（$emit派发的事件） v-on 指令侦听 $on 侦听一个事件 $once 一次性侦听一个事件 $off 停止侦听一个事件 慎用递归组件 尽量避免组件的循环引用 优先使用template来定义模板，而不是inline-template $forceUpdate来强制更新view 组件包含大量静态内容时，可使用v-once来标记，缓存静态内容 过渡 &amp; 动画 transition组件控制过渡动画，可以给任何元素和组件添加进入/离开过渡 当插入或删除transition中的元素时，vue会做如下处理 自动嗅探元素是否使用了css过渡和动画，适当时机添加/删除类名 元素的钩子函数会在适当时机被调用 元素既没有钩子函数也没有css动画，插入和删除操作在下一帧立即执行（浏览器逐帧动画机制） 过渡的类名 v-enter/v-enter-active/v-enter-to v-leave/v-leave-active/v-leave-to css动画用法同css过渡，区别是类名v-enter不会在DOM插入后立即删除，而是在animationend事件触发时删除 自定义过渡类名，使用以下属性指定: enter-class/enter-active-class/enter-to-class leave-class/leave-active-class/leave-to-class 自定义类名优先级高于普通的类名 使用type属性设置transition或animation来申明vue使用的动画类型 transition组件上使用duration来设置动画执行的时间 可以使用钩子函数 beforeEnter/enter/afterEnter/enterCancelled beforeLeave/leave/afterLeave/leaveCancelled 钩子函数使用v-on指令绑定 钩子和结合过渡和动画使用，也可以单独使用 在enter/leave中，必须使用done()来进行回调，否则会同步调用，过渡或动画会立即完成 对于纯使用JavaScript来进行的动画，推荐使用v-bind:css=“false”来取消css的检测，减少css的影响 可使用apear设置初始渲染的过渡 apear/apear-active/apear-to beforeApear/apear/afterApear/apearCancelled 多元素过渡，设置唯一key 过渡模式: In-out 新元素先过渡，完成后当前元素过渡离开 out-in 当前元素先过渡，完成后新元素过渡进入 默认行为：进入和离开同时发生 多个组件过渡使用动态组件实现 列表过渡 &lt;transition-group&gt; 以真实元素呈现，默认为&lt;span&gt;，可使用tag更改呈现标签 过渡模式不可用 内部需要唯一key 列表排序过渡，使用的是FLIP动画，使用类名v-move来定义class 可复用性 &amp; 组合 mixins混入属性发生冲突时，以组件数据优先（一层属性深度浅合并） mixins混入方法发生冲突时，会将函数合并为一个数组，优先执行混入方法，其次执行组件方法 Vue.extend策略和mixins相同 慎用全局混入 合并策略可以自定义（参考vuex的具体实现：Vue.config.optionMergeStrategies） 全局自定义指令：Vue.directive() 局部自定义指令：属性directives，类型为Object 钩子函数 bind 指令第一次绑定到元素时调用，只执行一次，可用于一次性初始化设置 inserted 元素插入父节点时调用 update 所有VNode更新时调用，可能发生在子VNode之前 componentUpdated 指令所在组件在VNode和其子VNode更新后调用 unbind 指令与元素解绑时调用 钩子函数都会被传入以下参数： el 指令绑定元素，可操作DOM binding 指令描述对象 vnode Vue生成的虚拟节点 oldVnode 上一个Vnode，仅在update和componentUpdated中使用 指令接受所有合法的JavaScript表达式 渲染函数 &amp; JSX render函数接受createElement方法作为参数 createElement方法的作用是创建一个虚拟节点(VNode) createElement参数比较复杂，参照官网：参数 组件树中的VNodes必须唯一 render中的v-if/v-for可以使用if/else和map重写 插槽使用this.$slot.default访问，作用域插槽使用this.$scopeSlots.default访问和设置 可以使用插件babel-plugin-transform-vue-jsx支持JSX语法 将h作为createElement的别名是Vue生态的一个惯例，也是JSX要求的 函数式组件 关键词：functional 函数式组件渲染开销低，但相应的，它不会出现在Vue devtools的组件树里边 函数式组件要求你自己实现同名特性的替换与智能合并 Vue的模板实际编译成了render方法实现的VNode，可以使用Vue.compile()方法来输出编译结果 插件 插件会为vue提供全局的功能，包括但不限于以下几种： 添加全局的属性或方法，如vue-custom-element 添加全局的资源（指令、过滤器、过渡等），如：vue-touch 通过全局mixins添加一些组件选项，如：vue-router 添加Vue实例方法，通过添加到Vue.prototype上实现 一个独立的库，同时有自己的API，又实现以上部分功能，如：vue-router Vue插件有一个公开的方法install，第一个参数是Vue构造器，第二个参数是一个可选对象。 插件的使用通过全局方法Vue.use(MyPlugin)使用，只会注册一次插件 在CommonJS中，应该始终显式的调用Vue.use方法 社区插件列表awesome-vue 过滤器12&#123;&#123; msg | filter &#125;&#125;&lt;div v-bind=“msg | filter&quot;&gt;&lt;/div&gt; 全局过滤器使用Vue.filter()创建 局部过滤器使用对象属性filters创建 过滤器函数总是接收表达式的值作为第一个参数，过滤器可以有多个，值依次向后传递 过滤器可以接收额外的参数 构建 &amp; 部署 &lt;script&gt;标签引入[vue.min.js](https://vuejs.org/js/vue.min.js) 使用vue-cli webpack + vue-loader browserify + vueify rollup + rollup-plugin-vue 利用钩子函数Vue.config.errorHandler定义配置来跟踪运行时错误，可以搭配[Sentry](https://sentry.io/)使用（集成配置） 单文件组件（.vue文件）","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"}]},{"title":"Array的push与unshift方法性能比较分析","slug":"Array的push与unshift方法性能比较分析","date":"2018-09-01T12:45:23.000Z","updated":"2018-09-01T11:58:10.805Z","comments":true,"path":"2018/09/01/Array的push与unshift方法性能比较分析/","link":"","permalink":"http://yoursite.com/2018/09/01/Array的push与unshift方法性能比较分析/","excerpt":"","text":"从原理就可以知道，unshift的效率是较低的。原因是，它每添加一个元素，都要把现有元素往下移一个位置。但到底效率差异有多大呢？下面来测试一下。测试环境的主要硬件：CPU T7100（1.8G）；内存4G DDR2 667；硬盘5400转。主要软件：操作系统为Windows 7；浏览器为Firefox 3.6.9。测试代码：12345678910111213var arr = [ ], s = +new Date; // push性能测试 for (var i = 0; i &lt; 50000; i++) &#123; arr.push(i); &#125; console.log(+new Date - s); s = +new Date; arr = [ ]; // unshift性能测试 for (var i = 0; i &lt; 50000; i++) &#123; arr.unshift(i); &#125; console.log(+new Date - s); 这段代码分别执行了50000次push和unshift操作，运行一次以后，得出结果：121152可见，unshift比push要慢差不多100倍！因此，平时还是要慎用unshift，特别是对大数组。那如果一定要达到unshift的效果，有没有其他方法呢？答案是肯定的。Array有一个叫做reverse的方法，能够把一个数组反转。先把要放进数组的元素用push添加，再执行一次reverse，就达到了unshift的效果。比如：123456789101112for (var i = 0; i &lt; 50000; i++) &#123; arr.push(i); &#125; arr.reverse(); //reverse的性能又如何呢，下面再来测试：var arr = [ ], s = +new Date; for (var i = 0; i &lt; 50000; i++) &#123; arr.push(i); &#125; arr.reverse(); console.log(+new Date - s); 结果是：12可见，reverse性能极高，甚至于没有额外的消耗，可以放心使用。 当你的才华撑不起你的野心的时候、请潜下心、低下头、好好学习、","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"焦虑的汤药","slug":"焦虑的汤药","date":"2018-08-21T12:45:23.000Z","updated":"2018-10-19T09:23:57.174Z","comments":true,"path":"2018/08/21/焦虑的汤药/","link":"","permalink":"http://yoursite.com/2018/08/21/焦虑的汤药/","excerpt":"","text":"如何正确使用时间你是否时常会焦虑时间过的很快，没时间学习，本文将会分享一些个人的见解。 花时间补基础，读文档在工作中我们时常会花很多时间去 debug，但是你是否发现很多问题最终只是你基础不扎实或者文档没有仔细看。 基础是你技术的基石，一定要花时间打好基础，而不是追各种新的技术。一旦你的基础扎实，学习各种新的技术也肯定不在话下，因为新的技术，究其根本都是相通的。 文档同样也是一门技术的基础。一个优秀的库，开发人员肯定已经把如何使用这个库都写在文档中了，仔细阅读文档一定会是少写 bug 的最省事路子。 学会搜索如果你还在使用百度搜索编程问题，请尽快抛弃这个垃圾搜索引擎。同样一个关键字，使用百度和谷歌，谷歌基本完胜的。即使你使用中文在谷歌中搜索，得到的结果也往往是谷歌占优，所以如果你想迅速的通过搜索引擎来解决问题，那一定是谷歌。 学点英语说到英语，一定是大家所最不想听的。其实我一直认为程序员学习英语是简单的，因为我们工作中是一直接触着英语，并且看懂技术文章，文档所需要的单词量是极少的。我时常在群里看到大家发出一个问题的截图问什么原因，其实在截图中英语已经很明白的说明了问题的所在，如果你的英语过关，完全不需要浪费时间来提问和搜索。所以我认为学点英语也是节省时间中很重要的一点。 那么如何去学习呢，chrome 装个翻译插件，直接拿英文文档或文章读，不会的就直接划词翻译，然后记录下这个单词并背诵。每天花半小时看点英文文档和文章，坚持两个月，你的英语水平不说别的，看文档和文章绝对不会有难题了。这一定是一个很划算的个人时间投资，花点时间学习英语，能为你将来的技术之路铺平很多坎。 画个图，想一想再做你是否遇到过这种问题，需求一下来，看一眼，然后马上就按照设计稿开始做了，可能中间出个问题导致你需要返工。 如果你存在这样的问题，我很推荐在看到设计稿和需求的时候花点时间想一想，画一画。考虑一下设计稿中是否可以找到可以拆分出来的复用组件，是否存在之前写过的组件。该如何组织这个界面，数据的流转是怎么样的。然后画一下这个页面的需求，最后再动手做。 利用好下班时间学习说到下班时间，那可能就有人说了公司很迟下班，这其实是国内很普遍的情况。但是我认为正常的加班是可以的，但是强制的加班就是在损耗你的身体和前途。 可以这么说，大部分的 996 公司，加班的这些时间并不会增加你的技术，无非就是在写一些重复的业务逻辑。也许你可以拿到更多的钱，但是代价是身体还有前途。程序员是靠技术吃饭的，如果你长久呆在一个长时间加班的公司，不能增长你的技术还要吞噬你的下班学习时间，那么你一定会废掉的。如果你遇到了这种情况，只能推荐尽快跳槽到非 996 的公司。 那么如果你有足够的下班时间，一定要花上 1， 2 小时去学习，上班大家基本都一样，技术的精进就是看下班以后的那几个小时了。如果你能利用好下班时间来学习，坚持下去，时间一定会给你很好的答复。 列好 ToDo我喜欢规划好一段时间内要做的事情，并且要把事情拆分为小点。给 ToDo 列好优先级，紧急的优先级最高。相同优先级的我喜欢先做简单的，因为这样一旦完成就能划掉一个，提高成就感。 反思和整理每周末都会花上点时间整理下本周记录的笔记和看到的不错文章。然后考虑下本周完成的工作和下周准备要完成的工作。","categories":[],"tags":[{"name":"生活感悟","slug":"生活感悟","permalink":"http://yoursite.com/tags/生活感悟/"}]},{"title":"webpack4快速入门","slug":"Webpack 4 和单页应用入门（史上最全webpack4入门教程，看懂了你就入门了）","date":"2018-08-11T12:45:23.000Z","updated":"2018-10-19T09:35:36.267Z","comments":true,"path":"2018/08/11/Webpack 4 和单页应用入门（史上最全webpack4入门教程，看懂了你就入门了）/","link":"","permalink":"http://yoursite.com/2018/08/11/Webpack 4 和单页应用入门（史上最全webpack4入门教程，看懂了你就入门了）/","excerpt":"","text":"可以说是我目前看到最详细的 webpack 4 入门文章。基本看完这个，基本也算一个合格的初级webpack配置工程师了。 webpack 更新到了 4.0，官网还没有更新文档。因此把教程更新一下，方便大家用起 webpack 4。 webpack 写在开头先说说为什么要写这篇文章，最初的原因是组里的小朋友们看了 webpack 文档后，表情都是这样的：摘自 webpack 一篇文档的评论区） wtf 是的，即使是外国佬也在吐槽这文档不是人能看的。回想起当年自己啃 webpack 文档的血与泪的往事，觉得有必要整一个教程，可以让大家看完后愉悦地搭建起一个 webpack 打包方案的项目。 官网新的 webpack 文档现在写的很详细了，能看英文的小伙伴可以直接去看官网。 可能会有人问 webpack 到底有什么用，你不能上来就糊我一脸代码让我马上搞，我照着搞了一遍结果根本没什么用，都是骗人的。所以，在说 webpack 之前，我想先谈一下前端打包方案这几年的演进历程，在什么场景下，我们遇到了什么问题，催生出了应对这些问题的工具。了解了需求和目的之后，你就知道什么时候 webpack 可以帮到你。我希望我用完之后很爽，你们用完之后也是。 先说说前端打包方案的黑暗历史在很长的一段前端历史里，是不存在打包这个说法的。那个时候页面基本是纯静态的或者服务端输出的，没有 AJAX，也没有 jQuery。那个时候的 JavaScript 就像个玩具，用处大概就是在侧栏弄个时钟，用 media player 放个 mp3 之类的脚本，代码量不是很多，直接放在 &lt;script&gt; 标签里或者弄个 js 文件引一下就行，日子过得很轻松愉快。 随后的几年，人们开始尝试在一个页面里做更多的事情。容器的显示，隐藏，切换。用 css 写的弹层，图片轮播等等。但如果一个页面内不能向服务器请求数据，能做的事情毕竟有限的，代码的量也能维持在页面交互逻辑范围内。这时候很多人开始突破一个页面能做的事情的范围，使用隐藏的 iframe 和 flash 等作为和服务器通信的桥梁，新世界的大门慢慢地被打开，在一个页面内和服务器进行数据交互，意味着以前需要跳转多个页面的事情现在可以用一个页面搞定。但由于 iframe 和 flash 技术过于 tricky 和复杂，并没能得到广泛的推广。 直到 Google 推出 Gmail 的时候（2004 年），人们意识到了一个被忽略的接口，XMLHttpRequest, 也就是我们俗称的 AJAX, 这是一个使用方便的，兼容性良好的服务器通信接口。从此开始，我们的页面开始玩出各种花来了，前端一下子出现了各种各样的库，Prototype、Dojo、MooTools、Ext JS、jQuery…… 我们开始往页面里插入各种库和插件，我们的 js 文件也就爆炸了。 随着 js 能做的事情越来越多，引用越来越多，文件越来越大，加上当时大约只有 2Mbps 左右的网速，下载速度还不如 3G 网络，对 js 文件的压缩和合并的需求越来越强烈，当然这里面也有把代码混淆了不容易被盗用等其他因素在里面。JSMin、YUI Compressor、Closure Compiler、UglifyJS 等 js 文件压缩合并工具陆陆续续诞生了。压缩工具是有了，但我们得要执行它，最简单的办法呢，就是 windows 上搞个 bat 脚本，mac / linux 上搞个 bash 脚本，哪几个文件要合并在一块的，哪几个要压缩的，发布的时候运行一下脚本，生成压缩后的文件。 基于合并压缩技术，项目越做越大，问题也越来越多，大概就是以下这些问题： 库和插件为了要给他人调用，肯定要找个地方注册，一般就是在 window 下申明一个全局的函数或对象。难保哪天用的两个库在全局用同样的名字，那就冲突了。 库和插件如果还依赖其他的库和插件，就要告知使用人，需要先引哪些依赖库，那些依赖库也有自己的依赖库的话，就要先引依赖库的依赖库，以此类推。 恰好就在这个时候（2009 年），随着后端 JavaScript 技术的发展，人们提出了 CommonJS 的模块化规范，大概的语法是： 如果 a.js 依赖 b.js 和 c.js， 那么就在 a.js 的头部，引入这些依赖文件： 12var b = require(&apos;./b&apos;)var c = require(&apos;./c&apos;) 那么变量 b 和 c 会是什么呢？那就是 b.js 和 c.js 导出的东西，比如 b.js 可以这样导出： 123exports.square = function(num) &#123; return num * num&#125; 然后就可以在 a.js 使用这个 square 方法： 1var n = b.square(2) 如果 c.js 依赖 d.js， 导出的是一个 Number， 那么可以这样写： 12var d = require(&apos;./d&apos;)module.exports = d.PI // 假设 d.PI 的值是 3.14159 那么 a.js 中的变量 c 就是数字 3.14159，具体的语法规范可以查看 Node.js 的 文档。 但是 CommonJS 在浏览器内并不适用。因为 require() 的返回是同步的，意味着有多个依赖的话需要一个一个依次下载，堵塞了 js 脚本的执行。所以人们就在 CommonJS 的基础上定义了 Asynchronous Module Definition (AMD) 规范(2011 年），使用了异步回调的语法来并行下载多个依赖项，比如作为入口的 a.js 可以这样写： 1234require([&apos;./b&apos;, &apos;./c&apos;], function(b, c) &#123; var n = b.square(2) console.log(c)&#125;) 相应的导出语法也是异步回调方式，比如 c.js 依赖 d.js， 就写成这样： 123define([&apos;./d&apos;], function(d) &#123; return d.PI&#125;) 可以看到，定义一个模块是使用 define() 函数，define() 和 require() 的区别是，define() 必须要在回调函数中返回一个值作为导出的东西，require() 不需要导出东西，因此回调函数中不需要返回值，也无法作为被依赖项被其他文件导入，因此一般用于入口文件，比如页面中这样加载 a.js: 1&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/a&quot;&gt;&lt;/script&gt; 以上是 AMD 规范的基本用法，更详细的就不多说了（反正也淘汰了～），有兴趣的可以看 这里。 js 模块化问题基本解决了，css 和 html 也没闲着。什么 less，sass，stylus 的 css 预处理器横空出世，说能帮我们简化 css 的写法，自动给你加 vendor prefix。html 在这期间也出现了一堆模板语言，什么 handlebars，ejs，jade，可以把 ajax 拿到的数据插入到模板中，然后用 innerHTML 显示到页面上。 托 AMD 和 CSS 预处理和模板语言的福，我们的编译脚本也洋洋洒洒写了百来行。命令行脚本有个不好的地方，就是 windows 和 mac/linux 是不通用的，如果有跨平台需求的话，windows 要装个可以执行 bash 脚本的命令行工具，比如 msys（目前最新的是 msys2），或者使用 php 或 python 等其他语言的脚本来编写，对于非全栈型的前端程序员来说，写 bash / php / python 还是很生涩的。因此我们需要一个简单的打包工具，可以利用各种编译工具，编译 / 压缩 js、css、html、图片等资源。然后 Grunt 产生了（2012 年），配置文件格式是我们最爱的 js，写法也很简单，社区有非常多的插件支持各种编译、lint、测试工具。一年多后另一个打包工具 gulp 诞生了，扩展性更强，采用流式处理效率更高。 依托 AMD 模块化编程，SPA(Single-page application) 的实现方式更为简单清晰，一个网页不再是传统的类似 word 文档的页面，而是一个完整的应用程序。SPA 应用有一个总的入口页面，我们通常把它命名为 index.html、app.html、main.html，这个 html 的 &lt;body&gt; 一般是空的，或者只有总的布局（layout），比如下图： image 布局会把 header、nav、footer 的内容填上，但 main 区域是个空的容器。这个作为入口的 html 最主要的工作是加载启动 SPA 的 js 文件，然后由 js 驱动，根据当前浏览器地址进行路由分发，加载对应的 AMD 模块，然后该 AMD 模块执行，渲染对应的 html 到页面指定的容器内（比如图中的 main）。在点击链接等交互时，页面不会跳转，而是由 js 路由加载对应的 AMD 模块，然后该 AMD 模块渲染对应的 html 到容器内。 虽然 AMD 模块让 SPA 更容易地实现，但小问题还是很多的： 不是所有的第三方库都是 AMD 规范的，这时候要配置 shim，很麻烦。 虽然 RequireJS 支持通过插件把 html 作为依赖加载，但 html 里面的 &lt;img&gt; 的路径是个问题，需要使用绝对路径并且保持打包后的图片路径和打包前的路径不变，或者使用 html 模板语言把 src 写成变量，在运行时生成。 不支持动态加载 css，变通的方法是把所有的 css 文件合并压缩成一个文件，在入口的 html 页面一次性加载。 SPA 项目越做越大，一个应用打包后的 js 文件到了几 MB 的大小。虽然 r.js 支持分模块打包，但配置很麻烦，因为模块之间会互相依赖，在配置的时候需要 exclude 那些通用的依赖项，而依赖项要在文件里一个个检查。 所有的第三方库都要自己一个个的下载，解压，放到某个目录下，更别提更新有多麻烦了。虽然可以用 npm 包管理工具，但 npm 的包都是 CommonJS 规范的，给后端 Node.js 用的，只有部分支持 AMD 规范，而且在 npm 3 之前，这些包有依赖项的话也是不能用的。后来有个 bower 包管理工具是专门的 web 前端仓库，这里的包一般都支持 AMD 规范。 AMD 规范定义和引用模块的语法太麻烦，上面介绍的 AMD 语法仅是最简单通用的语法，API 文档里面还有很多变异的写法，特别是当发生循环引用的时候（a 依赖 b，b 依赖 a），需要使用其他的 语法 解决这个问题。而且 npm 上很多前后端通用的库都是 CommonJS 的语法。后来很多人又开始尝试使用 ES6 模块规范，如何引用 ES6 模块又是一个大问题。 项目的文件结构不合理，因为 grunt/gulp 是按照文件格式批量处理的，所以一般会把 js、html、css、图片分别放在不同的目录下，所以同一个模块的文件会散落在不同的目录下，开发的时候找文件是个麻烦的事情。code review 时想知道一个文件是哪个模块的也很麻烦，解决办法比如又要在 imgs 目录下建立按模块命名的文件夹，里面再放图片。 到了这里，我们的主角 webpack 登场了（2012 年）（此处应有掌声）。 和 webpack 差不多同期登场的还有 Browserify。这里简单介绍一下 Browserify。Browserify 的目的是让前端也能用 CommonJS 的语法 require(&#39;module&#39;) 来加载 js。它会从入口 js 文件开始，把所有的 require() 调用的文件打包合并到一个文件，这样就解决了异步加载的问题。那么 Browserify 有什么不足之处导致我不推荐使用它呢? 主要原因有下面几点： 最主要的一点，Browserify 不支持把代码打包成多个文件，在有需要的时候加载。这就意味着访问任何一个页面都会全量加载所有文件。 Browserify 对其他非 js 文件的加载不够完善，因为它主要解决的是 require() js 模块的问题，其他文件不是它关心的部分。比如 html 文件里的 img 标签，它只能转成 Data URI 的形式，而不能替换为打包后的路径。 因为上面一点 Browserify 对资源文件的加载支持不够完善，导致打包时一般都要配合 gulp 或 grunt 一块使用，无谓地增加了打包的难度。 Browserify 只支持 CommonJS 模块规范，不支持 AMD 和 ES6 模块规范，这意味旧的 AMD 模块和将来的 ES6 模块不能使用。 基于以上几点，Browserify 并不是一个理想的选择。那么 webpack 是否解决了以上的几个问题呢? 废话，不然介绍它干嘛。那么下面章节我们用实战的方式来说明 webpack 是怎么解决上述的问题的。 上手先搞一个简单的 SPA 应用一上来步子太大容易扯到蛋，让我们先弄个最简单的 webpack 配置来热一下身。 安装 Node.jswebpack 是基于我大 Node.js 的打包工具，上来第一件事自然是先安装 Node.js 了，传送门 -&gt;。 初始化一个项目我们先随便找个地方，建一个文件夹叫 simple， 然后在这里面搭项目。完成品在 examples/simple 目录，大家搞的时候可以参照一下。我们先看一下目录结构： 12345678910├── dist 打包输出目录，只需部署这个目录到生产环境├── package.json 项目配置信息├── node_modules npm 安装的依赖包都在这里面├── src 我们的源代码│ ├── components 可以复用的模块放在这里面│ ├── index.html 入口 html│ ├── index.js 入口 js│ ├── shared 公共函数库│ └── views 页面放这里└── webpack.config.js webpack 配置文件 打开命令行窗口，cd 到刚才建的 simple 目录。然后执行这个命令初始化项目： 1npm init 命令行会要你输入一些配置信息，我们这里一路按回车下去，生成一个默认的项目配置文件 package.json。 给项目加上语法报错和代码规范检查我们安装 eslint， 用来检查语法报错，当我们书写 js 时，有错误的地方会出现提示。 1npm install eslint eslint-config-enough babel-eslint eslint-loader --save-dev npm install 可以一条命令同时安装多个包，包之间用空格分隔。包会被安装进 node_modules 目录中。 --save-dev 会把安装的包和版本号记录到 package.json 中的 devDependencies 对象中，还有一个 --save， 会记录到 dependencies 对象中，它们的区别，我们可以先简单的理解为打包工具和测试工具用到的包使用 --save-dev 存到 devDependencies， 比如 eslint、webpack。浏览器中执行的 js 用到的包存到 dependencies， 比如 jQuery 等。那么它们用来干嘛的？ 因为有些 npm 包安装是需要编译的，那么导致 windows / mac /linux 上编译出的可执行文件是不同的，也就是无法通用，因此我们在提交代码到 git 上去的时候，一般都会在 .gitignore 里指定忽略 node_modules 目录和里面的文件，这样其他人从 git 上拉下来的项目是没有 node_modules 目录的，这时我们需要运行 1npm install 它会读取 package.json 中的 devDependencies 和 dependencies 字段，把记录的包的相应版本下载下来。 这里 eslint-config-enough 是配置文件，它规定了代码规范，要使它生效，我们要在 package.json 中添加内容： 123456789&#123; &quot;eslintConfig&quot;: &#123; &quot;extends&quot;: &quot;enough&quot;, &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;node&quot;: true &#125; &#125;&#125; 业界最有名的语法规范是 airbnb 出品的，但它规定的太死板了，比如不允许使用 for-of 和 for-in 等。感兴趣的同学可以参照 这里 安装使用。 babel-eslint 是 eslint-config-enough 依赖的语法解析库，替代 eslint 默认的解析库以支持还未标准化的语法。比如 import()。 eslint-loader 用于在 webpack 编译的时候检查代码，如果有错误，webpack 会报错。 项目里安装了 eslint 还没用，我们的 IDE 和编辑器也得要装 eslint 插件支持它。 Visual Studio Code 需要安装 ESLint 扩展 atom 需要安装 linter 和 linter-eslint 这两个插件，装好后重启生效。 WebStorm 需要在设置中打开 eslint 开关： image 写几个页面我们写一个最简单的 SPA 应用来介绍 SPA 应用的内部工作原理。首先，建立 src/index.html 文件，内容如下： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 它是一个空白页面，注意这里我们不需要自己写 &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;， 因为打包后的文件名和路径可能会变，所以我们用 webpack 插件帮我们自动加上。 src/index.js: 12345// 引入 routerimport router from &apos;./router&apos;// 启动 routerrouter.start() src/router.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243// 引入页面文件import foo from &apos;./views/foo&apos;import bar from &apos;./views/bar&apos;const routes = &#123; &apos;/foo&apos;: foo, &apos;/bar&apos;: bar&#125;// Router 类，用来控制页面根据当前 URL 切换class Router &#123; start() &#123; // 点击浏览器后退 / 前进按钮时会触发 window.onpopstate 事件，我们在这时切换到相应页面 // https://developer.mozilla.org/en-US/docs/Web/Events/popstate window.addEventListener(&apos;popstate&apos;, () =&gt; &#123; this.load(location.pathname) &#125;) // 打开页面时加载当前页面 this.load(location.pathname) &#125; // 前往 path，变更地址栏 URL，并加载相应页面 go(path) &#123; // 变更地址栏 URL history.pushState(&#123;&#125;, &apos;&apos;, path) // 加载页面 this.load(path) &#125; // 加载 path 路径的页面 load(path) &#123; // 首页 if (path === &apos;/&apos;) path = &apos;/foo&apos; // 创建页面实例 const view = new routes[path]() // 调用页面方法，把页面加载到 document.body 中 view.mount(document.body) &#125;&#125;// 导出 router 实例export default new Router() src/views/foo/index.js: 1234567891011121314151617181920// 引入 routerimport router from &apos;../../router&apos;// 引入 html 模板，会被作为字符串引入import template from &apos;./index.html&apos;// 引入 css, 会生成 &lt;style&gt; 块插入到 &lt;head&gt; 头中import &apos;./style.css&apos;// 导出类export default class &#123; mount(container) &#123; document.title = &apos;foo&apos; container.innerHTML = template container.querySelector(&apos;.foo__gobar&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123; // 调用 router.go 方法加载 /bar 页面 router.go(&apos;/bar&apos;) &#125;) &#125;&#125; src/views/bar/index.js: 1234567891011121314151617181920// 引入 routerimport router from &apos;../../router&apos;// 引入 html 模板，会被作为字符串引入import template from &apos;./index.html&apos;// 引入 css, 会生成 &lt;style&gt; 块插入到 &lt;head&gt; 头中import &apos;./style.css&apos;// 导出类export default class &#123; mount(container) &#123; document.title = &apos;bar&apos; container.innerHTML = template container.querySelector(&apos;.bar__gofoo&apos;).addEventListener(&apos;click&apos;, () =&gt; &#123; // 调用 router.go 方法加载 /foo 页面 router.go(&apos;/foo&apos;) &#125;) &#125;&#125; 借助 webpack 插件，我们可以 import html, css 等其他格式的文件，文本类的文件会被储存为变量打包进 js 文件，其他二进制类的文件，比如图片，可以自己配置，小图片作为 Data URI 打包进 js 文件，大文件打包为单独文件，我们稍后再讲这块。 其他的 src 目录下的文件大家自己浏览，拷贝一份到自己的工作目录，等会打包时会用到。 页面代码这样就差不多搞定了，接下来我们进入 webpack 的安装和配置阶段。现在我们还没有讲 webpack 配置所以页面还无法访问，等会弄好 webpack 配置后再看页面实际效果。 安装 webpack 和 Babel我们把 webpack 和它的插件安装到项目： 1npm install webpack webpack-cli webpack-serve html-webpack-plugin html-loader css-loader style-loader file-loader url-loader --save-dev webpack 即 webpack 核心库。它提供了很多 API, 通过 Node.js 脚本中 require(&#39;webpack&#39;) 的方式来使用 webpack。 webpack-cli 是 webpack 的命令行工具。让我们可以不用写打包脚本，只需配置打包配置文件，然后在命令行输入 webpack-cli --config webpack.config.js 来使用 webpack, 简单很多。webpack 4 之前命令行工具是集成在 webpack 包中的，4.0 开始 webpack 包本身不再集成 cli。 webpack-serve 是 webpack 提供的用来开发调试的服务器，让你可以用 http://127.0.0.1:8080/ 这样的 url 打开页面来调试，有了它就不用配置 nginx 了，方便很多。 html-webpack-plugin, html-loader, css-loader, style-loader 等看名字就知道是打包 html 文件，css 文件的插件，大家在这里可能会有疑问，html-webpack-plugin 和 html-loader 有什么区别，css-loader 和 style-loader 有什么区别，我们等会看配置文件的时候再讲。 file-loader 和 url-loader 是打包二进制文件的插件，具体也在配置文件章节讲解。 接下来，为了能让不支持 ES6 的浏览器 （比如 IE) 也能照常运行，我们需要安装 babel, 它会把我们写的 ES6 源代码转化成 ES5，这样我们源代码写 ES6，打包时生成 ES5。 1npm install babel-core babel-preset-env babel-loader --save-dev 这里 babel-core 顾名思义是 babel 的核心编译器。babel-preset-env 是一个配置文件，我们可以使用这个配置文件转换 ES2015/ES2016/ES2017 到 ES5，是的，不只 ES6 哦。babel 还有 其他配置文件。 光安装了 babel-preset-env，在打包时是不会生效的，需要在 package.json 加入 babel 配置： 12345&#123; &quot;babel&quot;: &#123; &quot;presets&quot;: [&quot;env&quot;] &#125;&#125; 打包时 babel 会读取 package.json 中 babel 字段的内容，然后执行相应的转换。 babel-loader 是 webpack 的插件，我们下面章节再说。 配置 webpack包都装好了，接下来总算可以进入正题了。我们来创建 webpack 配置文件 webpack.config.js，注意这个文件是在 node.js 中运行的，因此不支持 ES6 的 import 语法。我们来看文件内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179const &#123; resolve &#125; = require(&apos;path&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)const history = require(&apos;connect-history-api-fallback&apos;)const convert = require(&apos;koa-connect&apos;)// 使用 WEBPACK_SERVE 环境变量检测当前是否是在 webpack-server 启动的开发环境中const dev = Boolean(process.env.WEBPACK_SERVE)module.exports = &#123; /* webpack 执行模式 development：开发环境，它会在配置文件中插入调试相关的选项，比如 moduleId 使用文件路径方便调试 production：生产环境，webpack 会将代码做压缩等优化 */ mode: dev ? &apos;development&apos; : &apos;production&apos;, /* 配置 source map 开发模式下使用 cheap-module-eval-source-map, 生成的 source map 能和源码每行对应，方便打断点调试 生产模式下使用 hidden-source-map, 生成独立的 source map 文件，并且不在 js 文件中插入 source map 路径，用于在 error report 工具中查看 （比如 Sentry) */ devtool: dev ? &apos;cheap-module-eval-source-map&apos; : &apos;hidden-source-map&apos;, // 配置页面入口 js 文件 entry: &apos;./src/index.js&apos;, // 配置打包输出相关 output: &#123; // 打包输出目录 path: resolve(__dirname, &apos;dist&apos;), // 入口 js 的打包输出文件名 filename: &apos;index.js&apos; &#125;, module: &#123; /* 配置各种类型文件的加载器，称之为 loader webpack 当遇到 import ... 时，会调用这里配置的 loader 对引用的文件进行编译 */ rules: [ &#123; /* 使用 babel 编译 ES6 / ES7 / ES8 为 ES5 代码 使用正则表达式匹配后缀名为 .js 的文件 */ test: /\\.js$/, // 排除 node_modules 目录下的文件，npm 安装的包不需要编译 exclude: /node_modules/, /* use 指定该文件的 loader, 值可以是字符串或者数组。 这里先使用 eslint-loader 处理，返回的结果交给 babel-loader 处理。loader 的处理顺序是从最后一个到第一个。 eslint-loader 用来检查代码，如果有错误，编译的时候会报错。 babel-loader 用来编译 js 文件。 */ use: [&apos;babel-loader&apos;, &apos;eslint-loader&apos;] &#125;, &#123; // 匹配 html 文件 test: /\\.html$/, /* 使用 html-loader, 将 html 内容存为 js 字符串，比如当遇到 import htmlString from &apos;./template.html&apos;; template.html 的文件内容会被转成一个 js 字符串，合并到 js 文件里。 */ use: &apos;html-loader&apos; &#125;, &#123; // 匹配 css 文件 test: /\\.css$/, /* 先使用 css-loader 处理，返回的结果交给 style-loader 处理。 css-loader 将 css 内容存为 js 字符串，并且会把 background, @font-face 等引用的图片， 字体文件交给指定的 loader 打包，类似上面的 html-loader, 用什么 loader 同样在 loaders 对象中定义，等会下面就会看到。 */ use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;, &#123; /* 匹配各种格式的图片和字体文件 上面 html-loader 会把 html 中 &lt;img&gt; 标签的图片解析出来，文件名匹配到这里的 test 的正则表达式， css-loader 引用的图片和字体同样会匹配到这里的 test 条件 */ test: /\\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\\?.+)?$/, /* 使用 url-loader, 它接受一个 limit 参数，单位为字节(byte) 当文件体积小于 limit 时，url-loader 把文件转为 Data URI 的格式内联到引用的地方 当文件大于 limit 时，url-loader 会调用 file-loader, 把文件储存到输出目录，并把引用的文件路径改写成输出后的路径 比如 views/foo/index.html 中 &lt;img src=&quot;smallpic.png&quot;&gt; 会被编译成 &lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAA...&quot;&gt; 而 &lt;img src=&quot;largepic.png&quot;&gt; 会被编译成 &lt;img src=&quot;/f78661bef717cf2cc2c2e5158f196384.png&quot;&gt; */ use: [ &#123; loader: &apos;url-loader&apos;, options: &#123; limit: 10000 &#125; &#125; ] &#125; ] &#125;, /* 配置 webpack 插件 plugin 和 loader 的区别是，loader 是在 import 时根据不同的文件名，匹配不同的 loader 对这个文件做处理， 而 plugin, 关注的不是文件的格式，而是在编译的各个阶段，会触发不同的事件，让你可以干预每个编译阶段。 */ plugins: [ /* html-webpack-plugin 用来打包入口 html 文件 entry 配置的入口是 js 文件，webpack 以 js 文件为入口，遇到 import, 用配置的 loader 加载引入文件 但作为浏览器打开的入口 html, 是引用入口 js 的文件，它在整个编译过程的外面， 所以，我们需要 html-webpack-plugin 来打包作为入口的 html 文件 */ new HtmlWebpackPlugin(&#123; /* template 参数指定入口 html 文件路径，插件会把这个文件交给 webpack 去编译， webpack 按照正常流程，找到 loaders 中 test 条件匹配的 loader 来编译，那么这里 html-loader 就是匹配的 loader html-loader 编译后产生的字符串，会由 html-webpack-plugin 储存为 html 文件到输出目录，默认文件名为 index.html 可以通过 filename 参数指定输出的文件名 html-webpack-plugin 也可以不指定 template 参数，它会使用默认的 html 模板。 */ template: &apos;./src/index.html&apos;, /* 因为和 webpack 4 的兼容性问题，chunksSortMode 参数需要设置为 none https://github.com/jantimon/html-webpack-plugin/issues/870 */ chunksSortMode: &apos;none&apos; &#125;) ]&#125;/*配置开发时用的服务器，让你可以用 http://127.0.0.1:8080/ 这样的 url 打开页面来调试并且带有热更新的功能，打代码时保存一下文件，浏览器会自动刷新。比 nginx 方便很多如果是修改 css, 甚至不需要刷新页面，直接生效。这让像弹框这种需要点击交互后才会出来的东西调试起来方便很多。因为 webpack-cli 无法正确识别 serve 选项，使用 webpack-cli 执行打包时会报错。因此我们在这里判断一下，仅当使用 webpack-serve 时插入 serve 选项。issue：https://github.com/webpack-contrib/webpack-serve/issues/19*/if (dev) &#123; module.exports.serve = &#123; // 配置监听端口，默认值 8080 port: 8080, // add: 用来给服务器的 koa 实例注入 middleware 增加功能 add: app =&gt; &#123; /* 配置 SPA 入口 SPA 的入口是一个统一的 html 文件，比如 http://localhost:8080/foo 我们要返回给它 http://localhost:8080/index.html 这个文件 */ app.use(convert(history())) &#125; &#125;&#125; 走一个配置 OK 了，接下来我们就运行一下吧。我们先试一下开发环境用的 webpack-serve: 1./node_modules/.bin/webpack-serve webpack.config.js 执行时需要指定配置文件。 上面的命令适用于 Mac / Linux 等 * nix 系统，也适用于 Windows 上的 PowerShell 和 bash/zsh 环境（Windows Subsystem for Linux, Git Bash、Babun、MSYS2 等）。安利一下 Windows 同学使用 Ubuntu on Windows，可以避免很多跨平台的问题，比如设置环境变量。 如果使用 Windows 的 cmd.exe，请执行： 1node_modules\\.bin\\webpack-serve webpack.config.js npm 会把包的可执行文件安装到 ./node_modules/.bin/ 目录下，所以我们要在这个目录下执行命令。 命令执行后，控制台显示： 1｢wdm｣: Compiled successfully。 这就代表编译成功了，我们可以在浏览器打开 http://localhost:8080/ 看看效果。如果有报错，那可能是什么地方没弄对？请自己仔细检查一下～ 我们可以随意更改一下 src 目录下的源代码，保存后，浏览器里的页面应该很快会有相应变化。 要退出编译，按 ctrl+c。 开发环境编译试过之后，我们试试看编译生产环境的代码，命令是： 1./node_modules/.bin/webpack-cli 不需要指定配置文件，默认读取 webpack.config.js 执行脚本的命令有点麻烦，因此，我们可以利用 npm，把命令写在 package.json 中： 123456&#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-serve webpack.config.js&quot;, &quot;build&quot;: &quot;webpack-cli&quot; &#125;&#125; package.json 中的 scripts 对象，可以用来写一些脚本命令，命令不需要前缀目录 ./node_modules/.bin/，npm 会自动寻找该目录下的命令。我们可以执行： 1npm run dev 来启动开发环境。 执行 1npm run build 来打包生产环境的代码。 进阶配置上面的项目虽然可以跑起来了，但有几个点我们还没有考虑到： 设置静态资源的 url 路径前缀 各个页面分开打包 第三方库和业务代码分开打包 输出的 entry 文件加上 hash 开发环境关闭 performance.hints 配置 favicon 开发环境允许其他电脑访问 打包时自定义部分参数 webpack-serve 处理路径带后缀名的文件的特殊规则 代码中插入环境变量 简化 import 路径 优化 babel 编译后的代码性能 使用 webpack 自带的 ES6 模块处理功能 使用 autoprefixer 自动创建 css 的 vendor prefixes 那么，让我们在上面的配置的基础上继续完善，下面的代码我们只写出改变的部分。代码在 examples/advanced 目录。 设置静态资源的 url 路径前缀现在我们的资源文件的 url 直接在根目录，比如 http://127.0.0.1:8080/index.js， 这样做缓存控制和 CDN 不是很方便，因此我们给资源文件的 url 加一个前缀，比如 http://127.0.0.1:8080/assets/index.js. 我们来修改一下 webpack 配置： 12345&#123; output: &#123; publicPath: &apos;/assets/&apos; &#125;&#125; webpack-serve 也需要修改： 12345678910111213141516171819if (dev) &#123; module.exports.serve = &#123; port: 8080, host: &apos;0.0.0.0&apos;, dev: &#123; /* 指定 webpack-dev-middleware 的 publicpath 一般情况下与 output.publicPath 保持一致（除非 output.publicPath 使用的是相对路径） https://github.com/webpack/webpack-dev-middleware#publicpath */ publicPath: &apos;/assets/&apos; &#125;, add: app =&gt; &#123; app.use(convert(history(&#123; index: &apos;/assets/&apos; // index.html 文件在 /assets/ 路径下 &#125;))) &#125; &#125;&#125; 各个页面分开打包这样浏览器只需加载当前页面所需的代码。 webpack 可以使用异步加载文件的方式引用模块，我们使用 async/ await 和 dynamic import 来实现： src/router.js: 12345678910111213141516171819202122232425262728// 将 async/await 转换成 ES5 代码后需要这个运行时库来支持import &apos;regenerator-runtime/runtime&apos;const routes = &#123; // import() 返回 promise &apos;/foo&apos;: () =&gt; import(&apos;./views/foo&apos;), &apos;/bar.do&apos;: () =&gt; import(&apos;./views/bar.do&apos;)&#125;class Router &#123; // ... // 加载 path 路径的页面 // 使用 async/await 语法 async load(path) &#123; // 首页 if (path === &apos;/&apos;) path = &apos;/foo&apos; // 动态加载页面 const View = (await routes[path]()).default // 创建页面实例 const view = new View() // 调用页面方法，把页面加载到 document.body 中 view.mount(document.body) &#125;&#125; 这样我们就不需要在开头把所有页面文件都 import 进来了。 regenerator-runtime 是 regenerator 的运行时库。Babel 通过插件 transform-regenerator 使用 regenerator 将 generator函数和 async/await 语法转换成 ES5 语法后，需要运行时库才能正确执行。 另外因为 import() 还没有正式进入标准，需要使用 syntax-dynamic-import 来解析此语法。 我们可以安装 babel-preset-stage-2，它包含了 import() 和其他 stage 2 的语法支持。 1npm install regenerator-runtime babel-preset-stage-2 --save-dev package.json 改一下： 12345678&#123; &quot;babel&quot;: &#123; &quot;presets&quot;: [ &quot;env&quot;, &quot;stage-2&quot; ] &#125;&#125; 然后修改 webpack 配置： 123456789101112131415&#123; output: &#123; /* 代码中引用的文件（js、css、图片等）会根据配置合并为一个或多个包，我们称一个包为 chunk。 每个 chunk 包含多个 modules。无论是否是 js，webpack 都将引入的文件视为一个 module。 chunkFilename 用来配置这个 chunk 输出的文件名。 [chunkhash]：这个 chunk 的 hash 值，文件发生变化时该值也会变。使用 [chunkhash] 作为文件名可以防止浏览器读取旧的缓存文件。 还有一个占位符 [id]，编译时每个 chunk 会有一个id。 我们在这里不使用它，因为这个 id 是个递增的数字，增加或减少一个chunk，都可能导致其他 chunk 的 id 发生改变，导致缓存失效。 */ chunkFilename: &apos;[chunkhash].js&apos;, &#125;&#125; 第三方库和业务代码分开打包这样更新业务代码时可以借助浏览器缓存，用户不需要重新下载没有发生变化的第三方库。 Webpack 4 最大的改进便是自动拆分 chunk, 如果同时满足下列条件，chunk 就会被拆分： 新的 chunk 能被复用，或者模块是来自 node_modules 目录 新的 chunk 大于 30Kb(min+gz 压缩前） 按需加载 chunk 的并发请求数量小于等于 5 个 页面初始加载时的并发请求数量小于等于 3 个 一般情况只需配置这几个参数即可： 1234567891011121314151617181920212223242526272829303132333435&#123; plugins: [ // ... /* 使用文件路径的 hash 作为 moduleId。 虽然我们使用 [chunkhash] 作为 chunk 的输出名，但仍然不够。 因为 chunk 内部的每个 module 都有一个 id，webpack 默认使用递增的数字作为 moduleId。 如果引入了一个新文件或删掉一个文件，可能会导致其他文件的 moduleId 也发生改变， 那么受影响的 module 所在的 chunk 的 [chunkhash] 就会发生改变，导致缓存失效。 因此使用文件路径的 hash 作为 moduleId 来避免这个问题。 */ new webpack.HashedModuleIdsPlugin() ], optimization: &#123; /* 上面提到 chunkFilename 指定了 chunk 打包输出的名字，那么文件名存在哪里了呢？ 它就存在引用它的文件中。这意味着一个 chunk 文件名发生改变，会导致引用这个 chunk 文件也发生改变。 runtimeChunk 设置为 true, webpack 就会把 chunk 文件名全部存到一个单独的 chunk 中， 这样更新一个文件只会影响到它所在的 chunk 和 runtimeChunk，避免了引用这个 chunk 的文件也发生改变。 */ runtimeChunk: true, splitChunks: &#123; /* 默认 entry 的 chunk 不会被拆分 因为我们使用了 html-webpack-plugin 来动态插入 &lt;script&gt; 标签，entry 被拆成多个 chunk 也能自动被插入到 html 中， 所以我们可以配置成 all, 把 entry chunk 也拆分了 */ chunks: &apos;all&apos; &#125; &#125;&#125; webpack 4 支持更多的手动优化，详见： https://gist.github.com/sokra/1522d586b8e5c0f5072d7565c2bee693 但正如 webpack 文档中所说，默认配置已经足够优化，在没有测试的情况下不要盲目手动优化。 输出的 entry 文件加上 hash上面我们提到了 chunkFilename 使用 [chunkhash] 防止浏览器读取错误缓存，那么 entry 同样需要加上 hash。 但使用 webpack-serve 启动开发环境时，entry 文件是没有 [chunkhash] 的，用了会报错。 因此我们只在执行 webpack-cli 时使用 [chunkhash]。 12345&#123; output: &#123; filename: dev ? &apos;[name].js&apos; : &apos;[chunkhash].js&apos; &#125;&#125; 这里我们使用了 [name] 占位符。解释它之前我们先了解一下 entry 的完整定义: 12345&#123; entry: &#123; NAME: [FILE1, FILE2, ...] &#125;&#125; 我们可以定义多个 entry 文件，比如你的项目有多个 html 入口文件，每个 html 对应一个或多个 entry 文件。 然后每个 entry 可以定义由多个 module 组成，这些 module 会依次执行。 在 webpack 4 之前，这是很有用的功能，比如之前提到的第三方库和业务代码分开打包，在以前，我们需要这么配置： 123456&#123; entry &#123; main: &apos;./src/index.js&apos;, vendor: [&apos;jquery&apos;, &apos;lodash&apos;] &#125;&#125; entry 引用文件的规则和 import 是一样的，会寻找 node_modules 里的包。然后结合 CommonsChunkPlugin 把 vendor 定义的 module 从业务代码分离出来打包成一个单独的 chunk。 如果 entry 是一个 module，我们可以不使用数组的形式。 在 simple 项目中，我们配置了 entry: &#39;./src/index.js&#39;，这是最简单的形式，转换成完整的写法就是： 12345&#123; entry: &#123; main: [&apos;./src/index.js&apos;] &#125;&#125; webpack 会给这个 entry 指定名字为 main。 看到这应该知道 [name] 的意思了吧？它就是 entry 的名字。 有人可能注意到官网文档中还有一个 [hash] 占位符，这个 hash 是整个编译过程产生的一个总的 hash 值，而不是单个文件的 hash 值，项目中任何一个文件的改动，都会造成这个 hash 值的改变。[hash] 占位符是始终存在的，但我们不希望修改一个文件导致所有输出的文件 hash 都改变，这样就无法利用浏览器缓存了。因此这个 [hash] 意义不大。 开发环境关闭 performance.hints我们注意到运行开发环境是命令行会报一段 warning： 12WARNING in asset size limit: The following asset(s) exceed the recommended size limit (250 kB).This can impact web performance. 这是说建议每个输出的 js 文件的大小不要超过 250k。但开发环境因为包含了 sourcemap 并且代码未压缩所以一般都会超过这个大小，所以我们可以在开发环境把这个 warning 关闭。 webpack 配置中加入： 12345&#123; performance: &#123; hints: dev ? false : &apos;warning&apos; &#125;&#125; 配置 favicon在 src 目录中放一张 favicon.png，然后 src/index.html 的 &lt;head&gt; 中插入： 1&lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;favicon.png&quot;&gt; 修改 webpack 配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#123; module: &#123; rules: [ &#123; test: /\\.html$/, use: [ &#123; loader: &apos;html-loader&apos;, options: &#123; /* html-loader 接受 attrs 参数，表示什么标签的什么属性需要调用 webpack 的 loader 进行打包。 比如 &lt;img&gt; 标签的 src 属性，webpack 会把 &lt;img&gt; 引用的图片打包，然后 src 的属性值替换为打包后的路径。 使用什么 loader 代码，同样是在 module.rules 定义中使用匹配的规则。 如果 html-loader 不指定 attrs 参数，默认值是 img:src, 意味着会默认打包 &lt;img&gt; 标签的图片。 这里我们加上 &lt;link&gt; 标签的 href 属性，用来打包入口 index.html 引入的 favicon.png 文件。 */ attrs: [&apos;img:src&apos;, &apos;link:href&apos;] &#125; &#125; ] &#125;, &#123; /* 匹配 favicon.png 上面的 html-loader 会把入口 index.html 引用的 favicon.png 图标文件解析出来进行打包 打包规则就按照这里指定的 loader 执行 */ test: /favicon\\.png$/, use: [ &#123; // 使用 file-loader loader: &apos;file-loader&apos;, options: &#123; /* name：指定文件输出名 [hash] 为源文件的hash值，[ext] 为后缀。 */ name: &apos;[hash].[ext]&apos; &#125; &#125; ] &#125;, // 图片文件的加载配置增加一个 exclude 参数 &#123; test: /\\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\\?.+)?$/, // 排除 favicon.png, 因为它已经由上面的 loader 处理了。如果不排除掉，它会被这个 loader 再处理一遍 exclude: /favicon\\.png$/, use: [ &#123; loader: &apos;url-loader&apos;, options: &#123; limit: 10000 &#125; &#125; ] &#125; ] &#125;&#125; 其实 html-webpack-plugin 接受一个 favicon 参数，可以指定 favicon 文件路径，会自动打包插入到 html 文件中。但它有个 bug，打包后的文件名路径不带 hash，就算有 hash，它也是 [hash]，而不是 [chunkhash]。导致修改代码也会改变 favicon 打包输出的文件名。issue 中提到的 favicons-webpack-plugin 倒是可以用，但它依赖 PhantomJS, 非常大。 开发环境允许其他电脑访问12345678910111213const internalIp = require(&apos;internal-ip&apos;)module.exports.serve = &#123; host: &apos;0.0.0.0&apos;, hot: &#123; host: &#123; client: internalIp.v4.sync(), server: &apos;0.0.0.0&apos; &#125; &#125;, // ...&#125; 打包时自定义部分参数在多人开发时，每个人可能需要有自己的配置，比如说 webpack-serve 监听的端口号，如果写死在 webpack 配置里，而那个端口号在某个同学的电脑上被其他进程占用了，简单粗暴的修改 webpack.config.js 会导致提交代码后其他同学的端口也被改掉。 还有一点就是开发环境、测试环境、生产环境的部分 webpack 配置是不同的，比如 publicPath 在生产环境可能要配置一个 CDN 地址。 我们在根目录建立一个文件夹 config，里面创建 3 个配置文件： default.js: 生产环境 123module.exports = &#123; publicPath: &apos;http://cdn.example.com/assets/&apos;&#125; dev.js: 默认开发环境 1234567module.exports = &#123; publicPath: &apos;/assets/&apos;, serve: &#123; port: 8090 &#125;&#125; local.js: 个人本地环境，在 dev.js 基础上修改部分参数。 123const config = require(&apos;./dev&apos;)config.serve.port = 8070module.exports = config package.json 修改 scripts: 12345678&#123; &quot;scripts&quot;: &#123; &quot;local&quot;: &quot;npm run webpack-serve --config=local&quot;, &quot;dev&quot;: &quot;npm run webpack-serve --config=dev&quot;, &quot;webpack-serve&quot;: &quot;webpack-serve webpack.config.js&quot;, &quot;build&quot;: &quot;webpack-cli&quot; &#125;&#125; webpack 配置修改： 123456789101112131415161718192021222324252627282930// ...const url = require(&apos;url&apos;)const config = require(&apos;./config/&apos; + (process.env.npm_config_config || &apos;default&apos;))module.exports = &#123; // ... output: &#123; // ... publicPath: config.publicPath &#125; // ...&#125;if (dev) &#123; module.exports.serve = &#123; host: &apos;0.0.0.0&apos;, port: config.serve.port, dev: &#123; publicPath: config.publicPath &#125;, add: app =&gt; &#123; app.use(convert(history(&#123; index: url.parse(config.publicPath).pathname &#125;))) &#125; &#125;&#125; 这里的关键是 npm run 传进来的自定义参数可以通过 process.env.npm_config_* 获得。参数中如果有 - 会被转成 _。 还有一点，我们不需要把自己个人用的配置文件提交到 git，所以我们在 .gitignore 中加入： 123config/*!config/default.js!config/dev.js 把 config 目录排除掉，但是保留生产环境和 dev 默认配置文件。 可能有同学注意到了 webpack-cli 可以通过 –env 的方式从命令行传参给脚本，遗憾的是 webpack-cli 不支持。 webpack-serve 处理带后缀名的文件的特殊规则当处理带后缀名的请求时，比如 http://localhost:8080/bar.do ，connect-history-api-fallback 会认为它应该是一个实际存在的文件，就算找不到该文件，也不会 fallback 到 index.html，而是返回 404。但在 SPA 应用中这不是我们希望的。 幸好有一个配置选项 disableDotRule: true 可以禁用这个规则，使带后缀的文件当不存在时也能 fallback 到 index.html 12345678910module.exports.serve = &#123; // ... add: app =&gt; &#123; app.use(convert(history(&#123; // ... disableDotRule: true, htmlAcceptHeaders: [&apos;text/html&apos;, &apos;application/xhtml+xml&apos;] // 需要配合 disableDotRule 一起使用 &#125;))) &#125;&#125; 代码中插入环境变量在业务代码中，有些变量在开发环境和生产环境是不同的，比如域名、后台 API 地址等。还有开发环境可能需要打印调试信息等。 我们可以使用 DefinePlugin 插件在打包时往代码中插入需要的环境变量。 1234567891011121314// ...const pkgInfo = require(&apos;./package.json&apos;)module.exports = &#123; // ... plugins: [ new webpack.DefinePlugin(&#123; DEBUG: dev, VERSION: JSON.stringify(pkgInfo.version), CONFIG: JSON.stringify(config.runtimeConfig) &#125;), // ... ]&#125; DefinePlugin 插件的原理很简单，如果我们在代码中写： 1console.log(DEBUG) 它会做类似这样的处理： 1&apos;console.log(DEBUG)&apos;.replace(&apos;DEBUG&apos;, true) 最后生成： 1console.log(true) 这里有一点需要注意，像这里的 VERSION， 如果我们不对 pkgInfo.version 做 JSON.stringify()， 1console.log(VERSION) 然后做替换操作： 1&apos;console.log(VERSION)&apos;.replace(&apos;VERSION&apos;, &apos;1.0.0&apos;) 最后生成： 1console.log(1.0.0) 这样语法就错误了。所以，我们需要 JSON.stringify(pkgInfo.version) 转一下变成 &#39;&quot;1.0.0&quot;&#39;，替换的时候才会带引号。 还有一点，webpack 打包压缩的时候，会把代码进行优化，比如： 12345if (DEBUG) &#123; console.log(&apos;debug mode&apos;)&#125; else &#123; console.log(&apos;production mode&apos;)&#125; 会被编译成： 12345if (false) &#123; console.log(&apos;debug mode&apos;)&#125; else &#123; console.log(&apos;production mode&apos;)&#125; 然后压缩优化为： 1console.log(&apos;production mode&apos;) 简化 import 路径文件 a 引入文件 b 时，b 的路径是相对于 a 文件所在目录的。如果 a 和 b 在不同的目录，藏得又深，写起来就会很麻烦： 1import b from &apos;../../../components/b&apos; 为了方便，我们可以定义一个路径别名（alias）： 12345resolve: &#123; alias: &#123; &apos;~&apos;: resolve(__dirname, &apos;src&apos;) &#125;&#125; 这样，我们可以以 src 目录为基础路径来 import 文件： 1import b from &apos;~/components/b&apos; html 中的 &lt;img&gt; 标签没法使用这个别名功能，但 html-loader 有一个 root 参数，可以使 / 开头的文件相对于 root 目录解析。 123456789101112&#123; test: /\\.html$/, use: [ &#123; loader: &apos;html-loader&apos;, options: &#123; root: resolve(__dirname, &apos;src&apos;), attrs: [&apos;img:src&apos;, &apos;link:href&apos;] &#125; &#125; ]&#125; 那么，&lt;img src=&quot;/favicon.png&quot;&gt; 就能顺利指向到 src 目录下的 favicon.png 文件，不需要关心当前文件和目标文件的相对路径。 PS: 在调试 &lt;img&gt; 标签的时候遇到一个坑，html-loader 会解析 &lt;!-- --&gt; 注释中的内容，之前在注释中写的 1234&lt;!--大于 10kb 的图片，图片会被储存到输出目录，src 会被替换为打包后的路径&lt;img src=&quot;/assets/f78661bef717cf2cc2c2e5158f196384.png&quot;&gt;--&gt; 之前因为没有加 root 参数，所以 / 开头的文件名不会被解析，加了 root 导致编译时报错，找不到该文件。大家记住这一点。 优化 babel 编译后的代码性能babel 编译后的代码一般会造成性能损失，babel 提供了一个 loose 选项，使编译后的代码不需要完全遵循 ES6 规定，简化编译后的代码，提高代码执行效率： package.json: 12345678910111213&#123; &quot;babel&quot;: &#123; &quot;presets&quot;: [ [ &quot;env&quot;, &#123; &quot;loose&quot;: true &#125; ], &quot;stage-2&quot; ] &#125;&#125; 但这么做会有兼容性的风险，可能会导致 ES6 源码理应的执行结果和编译后的 ES5 代码的实际结果并不一致。如果代码没有遇到实际的效率瓶颈，官方 不建议 使用 loose 模式。 使用 webpack 自带的 ES6 模块处理功能我们目前的配置，babel 会把 ES6 模块定义转为 CommonJS 定义，但 webpack 自己可以处理 import 和 export， 而且 webpack 处理 import 时会做代码优化，把没用到的部分代码删除掉。因此我们通过 babel 提供的 modules: false 选项把 ES6 模块转为 CommonJS 模块的功能给关闭掉。 package.json: 1234567891011121314&#123; &quot;babel&quot;: &#123; &quot;presets&quot;: [ [ &quot;env&quot;, &#123; &quot;loose&quot;: true, &quot;modules&quot;: false &#125; ], &quot;stage-2&quot; ] &#125;&#125; 使用 autoprefixer 自动创建 css 的 vendor prefixescss 有一个很麻烦的问题就是比较新的 css 属性在各个浏览器里是要加前缀的，我们可以使用 autoprefixer 工具自动创建这些浏览器规则，那么我们的 css 中只需要写： 123:fullscreen a &#123; display: flex&#125; autoprefixer 会编译成： 12345678910111213141516:-webkit-full-screen a &#123; display: -webkit-box; display: flex&#125;:-moz-full-screen a &#123; display: flex&#125;:-ms-fullscreen a &#123; display: -ms-flexbox; display: flex&#125;:fullscreen a &#123; display: -webkit-box; display: -ms-flexbox; display: flex&#125; 首先，我们用 npm 安装它： 1npm install postcss-loader autoprefixer --save-dev autoprefixer 是 postcss 的一个插件，所以我们也要安装 postcss 的 webpack loader。 修改一下 webpack 的 css rule： 1234&#123; test: /\\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;postcss-loader&apos;]&#125; 然后创建文件 postcss.config.js: 12345module.exports = &#123; plugins: [ require(&apos;autoprefixer&apos;)() ]&#125; 使用 webpack 打包多页面应用（Multiple-Page Application）多页面网站同样可以用 webpack 来打包，以便使用 npm 包，import()，code splitting 等好处。 MPA 意味着并没不是一个单一的 html 入口和 js 入口，而是每个页面对应一个 html 和多个 js。那么我们可以把项目结构设计为： 12345678910111213141516171819202122├── dist├── package.json├── node_modules├── src│ ├── components│ ├── shared| ├── favicon.png│ └── pages 页面放这里| ├── foo 编译后生成 http://localhost:8080/foo.html| | ├── index.html| | ├── index.js| | ├── style.css| | └── pic.png| └── bar http://localhost:8080/bar.html| ├── index.html| ├── index.js| ├── style.css| └── baz http://localhost:8080/bar/baz.html| ├── index.html| ├── index.js| └── style.css└── webpack.config.js 这里每个页面的 index.html 是个完整的从 &lt;!DOCTYPE html&gt; 开头到 &lt;/html&gt; 结束的页面，这些文件都要用 html-webpack-plugin 处理。index.js 是每个页面的业务逻辑，作为每个页面的入口 js 配置到 entry 中。这里我们需要用 glob 库来把这些文件都筛选出来批量操作。为了使用 webpack 4 的 optimization.splitChunks 和 optimization.runtimeChunk 功能，我写了 html-webpack-include-sibling-chunks-plugin 插件来配合使用。还要装几个插件把 css 压缩并放到 &lt;head&gt; 中。 1npm install glob html-webpack-include-sibling-chunks-plugin uglifyjs-webpack-plugin mini-css-extract-plugin optimize-css-assets-webpack-plugin --save-dev webpack.config.js 修改的地方： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// ...const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;)const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;)const OptimizeCSSAssetsPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;)const HtmlWebpackIncludeSiblingChunksPlugin = require(&apos;html-webpack-include-sibling-chunks-plugin&apos;)const glob = require(&apos;glob&apos;)const dev = Boolean(process.env.WEBPACK_SERVE)const config = require(&apos;./config/&apos; + (process.env.npm_config_config || &apos;default&apos;))const entries = glob.sync(&apos;./src/**/index.js&apos;)const entry = &#123;&#125;const htmlPlugins = []for (const path of entries) &#123; const template = path.replace(&apos;index.js&apos;, &apos;index.html&apos;) const chunkName = path.slice(&apos;./src/pages/&apos;.length, -&apos;/index.js&apos;.length) entry[chunkName] = dev ? [path, template] : path htmlPlugins.push(new HtmlWebpackPlugin(&#123; template, filename: chunkName + &apos;.html&apos;, chunksSortMode: &apos;none&apos;, chunks: [chunkName] &#125;))&#125;module.exports = &#123; entry, output: &#123; path: resolve(__dirname, &apos;dist&apos;), // 我们不定义 publicPath，否则访问 html 时需要带上 publicPath 前缀 filename: dev ? &apos;[name].js&apos; : &apos;[chunkhash].js&apos;, chunkFilename: &apos;[chunkhash].js&apos; &#125;, optimization: &#123; runtimeChunk: true, splitChunks: &#123; chunks: &apos;all&apos; &#125;, minimizer: dev ? [] : [ new UglifyJsPlugin(&#123; cache: true, parallel: true, sourceMap: true &#125;), new OptimizeCSSAssetsPlugin() ] &#125;, module: &#123; rules: [ // ... &#123; test: /\\.css$/, use: [dev ? &apos;style-loader&apos; : MiniCssExtractPlugin.loader, &apos;css-loader&apos;, &apos;postcss-loader&apos;] &#125;, // ... ] &#125;, plugins: [ // ... /* 这里不使用 [chunkhash] 因为从同一个 chunk 抽离出来的 css 共享同一个 [chunkhash] [contenthash] 你可以简单理解为 moduleId + content 生成的 hash 因此一个 chunk 中的多个 module 有自己的 [contenthash] */ new MiniCssExtractPlugin(&#123; filename: &apos;[contenthash].css&apos;, chunkFilename: &apos;[contenthash].css&apos; &#125;), // 必须放在html-webpack-plugin前面 new HtmlWebpackIncludeSiblingChunksPlugin(), ...htmlPlugins ], // ...&#125; entry 和 htmlPlugins 会通过遍历 pages 目录生成，比如： entry: 12345&#123; &apos;bar/baz&apos;: &apos;./src/pages/bar/baz/index.js&apos;, bar: &apos;./src/pages/bar/index.js&apos;, foo: &apos;./src/pages/foo/index.js&apos;&#125; 在开发环境中，为了能够修改 html 文件后网页能够自动刷新，我们还需要把 html 文件也加入 entry 中，比如： 123&#123; foo: [&apos;./src/pages/foo/index.js&apos;, &apos;./src/pages/foo/index.html&apos;]&#125; 这样，当 foo 页面的 index.js 或 index.html 文件改动时，都会触发浏览器刷新该页面。虽然把 html 加入 entry 很奇怪，但放心，不会导致错误。记得不要在生产环境这么做，不然导致 chunk 文件包含了无用的 html 片段。 htmlPlugins: 12345678910111213141516171819202122[ new HtmlWebpackPlugin(&#123; template: &apos;./src/pages/bar/baz/index.html&apos;, filename: &apos;bar/baz.html&apos;, chunksSortMode: &apos;none&apos;, chunks: [&apos;bar/baz&apos;] &#125;, new HtmlWebpackPlugin(&#123; template: &apos;./src/pages/bar/index.html&apos;, filename: &apos;bar.html&apos;, chunksSortMode: &apos;none&apos;, chunks: [&apos;bar&apos;] &#125;, new HtmlWebpackPlugin(&#123; template: &apos;./src/pages/foo/index.html&apos;, filename: &apos;foo.html&apos;, chunksSortMode: &apos;none&apos;, chunks: [&apos;foo&apos;] &#125;] 代码在 examples/mpa 目录。 总结通过这篇文章，我想大家应该学会了 webpack 的正确打开姿势。虽然我没有提及如何用 webpack 来编译 React 和 vue.js, 但大家可以想到，无非是安装一些 loader 和 plugin 来处理 jsx 和 vue 格式的文件，那时难度就不在于 webpack 了，而是代码架构组织的问题了。具体的大家自己去摸索一下。 文章来源：https://github.com/wallstreetcn/webpack-and-spa-guide作者：wallstreetcn声明：文章著作权归作者所有，如有侵权，请联系小编删除。 关注公众号“web前端导航”，最新的前端教程和学习资料等你来拿！ image","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]},{"title":"JavaScript对象/原型链","slug":"JavaScript对象原型链","date":"2018-07-19T12:45:23.000Z","updated":"2018-09-02T11:42:38.085Z","comments":true,"path":"2018/07/19/JavaScript对象原型链/","link":"","permalink":"http://yoursite.com/2018/07/19/JavaScript对象原型链/","excerpt":"","text":"对象的原型是什么？Object是引用类型，包括：Object 、Array 、Function 、Data等。JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。 当我们用obj.xxx访问一个对象的属性时，JavaScript引擎先在当前（this）对象上查找该属性，如果没有找到，就到其原型对象上找(数组是Array.prototype,function是function。prototype)，如果还没有找到，就一直上溯到Object.prototype对象，最后，如果还没有找到，就只能返回undefined。 比如创建了一个Array对象：1var arr = [1,2,3] 其原型链是：1arr ----&gt; Array.prototype ----&gt; Object.prototype ----&gt; null Array.prototype定义了indexOf()、shift()等方法，因此你可以在所有的Array对象上直接调用这些方法。甚至你都可以在Array.prototype自定义方法，但是没有必要最后不要这样做。 当我们创建一个函数时：123function foo()&#123; return 0;&#125; 函数也是一个对象 ，他的原型链是：1foo ----&gt; Function.prototype ----&gt; Object.prototype ----&gt; null 由于Function.prototype定义了apply()等方法，因此，所有函数都可以调用apply()方法。 用构造函数创建对象用函数来创建对象比直接用var = {…}创建对象要方面的多，它就是构造函数。构造函数的首字母都应该大写首先先创建一个构造函数：123456function Student(name) &#123; this.name = name; this.hello = function () &#123; alert(&apos;Hello, &apos; + this.name + &apos;!&apos;); &#125;&#125; 可以用关键字new来调用这个函数，并返回一个对象：123var xiaoming = new Student(&apos;小明&apos;);xiaoming.name; // &apos;小明&apos;xiaoming.hello(); // Hello, 小明! 注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。 新创建的xiaoming的原型链是：1xiaoming ----&gt; Student.prototype ----&gt; Object.prototype ----&gt; null 也就是说，xiaoming的原型指向函数Student的原型。如果你又创建了xiaohong、xiaojun，那么这些对象的原型与xiaoming是一样的：123xiaoming ↘xiaohong -→ Student.prototype ----&gt; Object.prototype ----&gt; nullxiaojun ↗ 用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身：1console.log(xiaoming.constructor === Student)//true 我们可以用instanceof来检测对象类型；1234console.log(xiaohong instanceof Object);//trueconsole.log(xiaohong instanceof Student);//trueconsole.log(xiaoming instanceof Object);//trueconsole.log(xiaoming instanceof Student);//true 这个例子中所创建的对象即是Object的实例 也是Student的实例，因为所有的对象都继承自Object 参考：js高程第六章参考：廖雪峰的博客","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript中基本数据类型和引用数据类型的区别","slug":"JavaScript中基本数据类型和引用数据类型的区别","date":"2018-07-19T12:45:23.000Z","updated":"2018-09-02T11:42:23.004Z","comments":true,"path":"2018/07/19/JavaScript中基本数据类型和引用数据类型的区别/","link":"","permalink":"http://yoursite.com/2018/07/19/JavaScript中基本数据类型和引用数据类型的区别/","excerpt":"","text":"1、基本数据类型和引用数据类型 ECMAScript包括两个不同类型的值：基本数据类型和引用数据类型。 基本数据类型指的是简单的数据段，引用数据类型指的是有多个值构成的对象。 当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值。 2、常见的基本数据类型： Number、String 、Boolean、Null和Undefined。基本数据类型是按值访问的，因为可以直接操作保存在变量中的实际值。示例： var a = 10; var b = a; b = 20; console.log(a); // 10值 上面，b获取的是a值得一份拷贝，虽然，两个变量的值相等，但是两个变量保存了两个不同的基本数据类型值。 b只是保存了a复制的一个副本。所以，b的改变，对a没有影响。 下图演示了这种基本数据类型赋值的过程： 3、引用类型数据： 也就是对象类型Object type，比如：Object 、Array 、Function 、Data等。 javascript的引用数据类型是保存在堆内存中的对象。 与其他语言的不同是，你不可以直接访问堆内存空间中的位置和操作堆内存空间。只能操作对象在栈内存中的引用地址。 所以，引用类型数据在栈内存中保存的实际上是对象在堆内存中的引用地址。通过这个引用地址可以快速查找到保存中堆内存中的对象。 var obj1 = new Object(); var obj2 = obj1; obj2.name = “我有名字了”; console.log(obj1.name); // 我有名字了 说明这两个引用数据类型指向了同一个堆内存对象。obj1赋值给onj2，实际上这个堆内存对象在栈内存的引用地址复制了一份给了obj2， 但是实际上他们共同指向了同一个堆内存对象。实际上改变的是堆内存对象。 下面我们来演示这个引用数据类型赋值过程： [图片上传失败...(image-3d74f7-1531992451590)] 4、总结区别 a 声明变量时不同的内存分配： 1）原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。 这是因为这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 – 栈中。这样存储便于迅速查寻变量的值。 2）引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存地址。 这是因为：引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。 地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。 b 不同的内存分配机制也带来了不同的访问机制 1）在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时， 首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是传说中的按引用访问。 2）而原始类型的值则是可以直接访问到的。 c 复制变量时的不同 1）原始值：在将一个保存着原始值的变量复制给另一个变量时，会将原始值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的value而已。 2）引用值：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量， 也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。 （这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）。多了一个指针 d 参数传递的不同（把实参复制给形参的过程） 首先我们应该明确一点：ECMAScript中所有函数的参数都是按值来传递的。 但是为什么涉及到原始类型与引用类型的值时仍然有区别呢？还不就是因为内存分配时的差别。 1）原始值：只是把变量里的值传递给参数，之后参数和这个变量互不影响。 2）引用值：对象变量它里面的值是这个对象在堆内存中的内存地址，这一点你要时刻铭记在心！ 因此它传递的值也就是这个内存地址，这也就是为什么函数内部对这个参数的修改会体现在外部的原因了，因为它们都指向同一个对象。 参考：https://www.cnblogs.com/cxying93/p/6106469.html","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Webpack入门","slug":"webpack入门","date":"2018-07-19T12:45:23.000Z","updated":"2018-10-19T09:35:46.578Z","comments":true,"path":"2018/07/19/webpack入门/","link":"","permalink":"http://yoursite.com/2018/07/19/webpack入门/","excerpt":"","text":"为什么使用webpack??一句话 webpack能够提高了我们的开发效率什么是WebpackWebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。 安装新建一个空的练习文件夹 如：webpackText123456//全局安装npm install -g webpack//安装到你的项目目录npm install --save-dev webpack//npm install --save-dev webpack@版本号//可下载对应版本的webpack 正式使用Webpack前的准备 创建package.json文件1npm init 项目名称和作者等信息回车即可 package.json文件已经就绪，我们在本项目中安装Webpack作为依赖包 12// 安装Webpacknpm install --save-dev webpack 创建两个文件夹,app文件夹和public文件夹，app文件夹用来存放原始数据和我们将写的JavaScript模块，public文件夹用来存放之后供浏览器读取的文件（包括使用webpack打包生成的js文件以及一个index.html文件）创建三个文件: index.html –放在public文件夹中; Greeter.js– 放在app文件夹中; main.js– 放在app文件夹中; 此时项目结构如下图所示 项目结构 我们在index.html文件中写入最基础的html代码，它在这里目的在于引入打包后的js文件（这里我们先把之后打包后的js文件命名为bundle.js，之后我们还会详细讲述）。12345678910111213&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Webpack Sample Project&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&apos;root&apos;&gt; &lt;/div&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 我们在Greeter.js中定义一个返回包含问候信息的html元素的函数,并依据CommonJS规范导出这个函数为一个模块：123456// Greeter.jsmodule.exports = function() &#123; var greet = document.createElement(&apos;div&apos;); greet.textContent = &quot;Hi there and greetings!&quot;; return greet;&#125;; main.js文件中我们写入下述代码，用以把Greeter模块返回的节点插入页面。123//main.js const greeter = require(&apos;./Greeter.js&apos;);document.querySelector(&quot;#root&quot;).appendChild(greeter()); 根目录下新建webpack.config.js，1234567module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件 output: &#123;//__dirname 是node.js中的一个全局变量，它指向当前执行脚本所在的目录。 path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方 filename: &quot;bundle.js&quot;//打包后输出文件的文件名 &#125;&#125; 为了更方面的打包，在package.json中对scripts对象进行相关设置即可，设置方法如下。12345678910111213&#123; &quot;name&quot;: &quot;webpack-sample-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Sample webpack project&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot; // 修改的是这里，JSON文件不支持注释，引用时请清除 &#125;, &quot;author&quot;: &quot;zhang&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;3.10.0&quot; &#125;&#125; 命令行中输入npm start试试然后浏览器打开public/index.html WechatIMG2.jpeg 使用webpack构建本地服务器 安装devserver1npm install --save-dev webpack-dev-server 注意：webpack3.x的请下载webpack-dev-server2.9，不然会报错 把这些命令加到webpack的配置文件中，现在的配置文件webpack.config.js如下所示 123456789101112131415module.exports = &#123; devtool: &apos;eval-source-map&apos;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/public&quot;, filename: &quot;bundle.js&quot; &#125;, devServer: &#123; contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录 historyApiFallback: true,//不跳转 inline: true//实时刷新 &#125; &#125; 在package.json中的scripts对象中添加如下命令，用以开启本地服务器： 12345&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;webpack&quot;, &quot;server&quot;: &quot;webpack-dev-server --open&quot; &#125;, 在终端中输入npm run server即可在本地的8080端口查看结果（实时刷新） WechatIMG3.jpeg Loaders鼎鼎大名的Loaders登场了！Loaders是webpack提供的最激动人心的功能之一了。通过使用不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，比如说分析转换scss为css，或者把下一代的JS文件（ES6，ES7)转换为现代浏览器兼容的JS文件，对React的开发而言，合适的Loaders可以把React的中用到的JSX文件转换为JS文件 Loaders需要单独安装并且需要在webpack.config.js中的modules关键字下进行配置，Loaders的配置包括以下几方面： test：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选）BabelBabel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的： 让你能使用最新的JavaScript代码（ES6，ES7…），而不用管新标准是否被当前使用的浏览器完全支持；让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；Babel的安装与配置Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-env-preset包和解析JSX的babel-preset-react包）。 一次性安装这些依赖包12// npm一次性安装多个依赖模块，模块之间用空格隔开npm install --save-dev babel-core babel-loader babel-preset-env babel-preset-react Babel其实可以完全在 webpack.config.js 中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下：123456789101112131415161718192021222324module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件 output: &#123; path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方 filename: &quot;bundle.js&quot;//打包后输出文件的文件名 &#125;, devtool: &apos;eval-source-map&apos;, devServer: &#123; contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录 historyApiFallback: true,//不跳转 inline: true//实时刷新 &#125;, module: &#123; rules: [ &#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: &quot;babel-loader&quot; &#125;, exclude: /node_modules/ &#125; ] &#125;&#125;; 1234//.babelrc&#123; &quot;presets&quot;: [&quot;react&quot;, &quot;env&quot;]&#125; 因为webpack4都出来了 我学的这篇是webpack3.5版本的，但是基础的东西都还是一样的，最后放上这个webpack的配置文件，如果每一项都懂的话，入门应该是没问题了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 一个常见的`webpack`配置文件const webpack = require(&apos;webpack&apos;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;, //已多次提及的唯一入口文件 output: &#123; path: __dirname + &quot;/build&quot;, filename: &quot;bundle-[hash].js&quot; &#125;, devtool: &apos;none&apos;, devServer: &#123; contentBase: &quot;./public&quot;, //本地服务器所加载的页面所在的目录 historyApiFallback: true, //不跳转 inline: true, hot: true &#125;, module: &#123; rules: [&#123; test: /(\\.jsx|\\.js)$/, use: &#123; loader: &quot;babel-loader&quot; &#125;, exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: [&#123; loader: &quot;css-loader&quot;, options: &#123; modules: true, localIdentName: &apos;[name]__[local]--[hash:base64:5]&apos; &#125; &#125;, &#123; loader: &quot;postcss-loader&quot; &#125;], &#125;) &#125; &#125; ] &#125;, plugins: [ new webpack.BannerPlugin(&apos;版权所有，翻版必究&apos;), new HtmlWebpackPlugin(&#123; template: __dirname + &quot;/app/index.tmpl.html&quot; //new 一个这个插件的实例，并传入相关的参数 &#125;), new webpack.optimize.OccurrenceOrderPlugin(), new webpack.optimize.UglifyJsPlugin(), new ExtractTextPlugin(&quot;style.css&quot;) ]&#125;; 参考：https://www.jianshu.com/p/42e11515c10fwebpack中文网：https://www.webpackjs.com/concepts/简要理解CommonJS规范：https://blog.csdn.net/u012443286/article/details/78825917webpack4那点东西：https://juejin.im/post/5abef5e96fb9a028e33b9035","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]},{"title":"JavaScript零散知识整理","slug":"js 零碎","date":"2018-07-02T12:45:23.000Z","updated":"2018-07-02T12:55:06.870Z","comments":true,"path":"2018/07/02/js 零碎/","link":"","permalink":"http://yoursite.com/2018/07/02/js 零碎/","excerpt":"","text":"call() 参考：https://blog.csdn.net/ywl570717586/article/details/52681392/this解读参考：https://juejin.im/post/5b3715def265da59af40a630函数传入值参考：js高程 p113 快速删除尾部数组123var arr=[1,2,3,4,5];arr.length=3;console.log(arr)//[1,2,3] 直接改变数组的length的值 从数组中移除重复元素123var arr = [1,1,2,2,3,3]const removeDuplicateltems = arr =&gt; [...new Set(arr)];console.log(removeDuplicateltems(arr))//[1,2,3] 函数作为值传入1234//把函数作为值传入进去 function callSomeFunction(someFunction,someArgument)&#123; return someFunction(someArgument); &#125; 最终调用的这个函数 他有两个参数， 第一个参数是一个方法 ， 第二个参数是第一个方法的参数。12345function add10(num)&#123; return num + 10;&#125;var result1=callSomeFunction(add10,10); console.log(result1);//20 这个例子稍微一看就明白了吧， 传入的10 最终成了add()的参数, 也就是成了num, 所以结果是2012345function getGreeting(name)&#123; return &quot;holle,&quot; + name;&#125;var result2=callSomeFunction(getGreeting, &quot;Nicholas&quot;);console.log(result2);//holle Nicholas 上面的理解了 这个也就不难了 同理 “ Nicholas” 变成了getGreeting() 的参数 name，所以输出结果是 holle Nicholas call() 解释先看看关于call()的官方解释，“调用一个对象的一个方法，以另一个对象替换当前对象。”，看了这样的解释，或许让你更摸不着头脑了。看例子：123456789var x = &quot;我是全局变量&quot;; //定义全局变量xfunction a()&#123; //定义函数类结构a this.x = &quot;我是在函数类结构a中声明的哦&quot;; &#125;//定义普通函数，弹出当前指针所包含的变量x的值function f()&#123; alert (this.x);&#125;f.call(new a());//返回值为“我是在函数类结构a中声明的哦” 我的理解是，f.call(new a())就是把函数（其实也是对象）f复制到被调用对象“new a()”下面去解析，事实上和下面这段代码的解析结果一样： 12345function a()&#123; this.x = &quot;我是在函数类结构a中声明的哦&quot;; alert(this.x); //我是在函数类结构a中声明的哦&#125;a(); 只不过此时变量X的作用域不同而已，咿…看起来好像有点继承的味道哦，难道不是吗？在上例中,f完全被构造函数a的实力对象继承了，如果说这还不足以说明a.call(b)是一种继承模式，那么再看一个更具有继承味道的用法吧。 123456789101112function f()&#123; this.a =&quot;a&quot;; this.b = function()&#123; alert(&quot;b&quot;); &#125;&#125;function e()&#123; f.call(this); &#125;var c = new e();alert(c.a); //弹出ac.b(); //弹出b 在这个例子中，只要会使用浏览器的朋友，都能看得出来e完全继承了f的属性和方法，否则是无法解释的，因为在e中并没有定义属性a和b，那么按常理推断在e的实例对象c中，并不会出现这两个属性。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"使用Echarts.js绘制图表","slug":"使用Echarts.js绘制图表","date":"2018-06-30T12:45:23.000Z","updated":"2018-10-19T09:59:34.517Z","comments":true,"path":"2018/06/30/使用Echarts.js绘制图表/","link":"","permalink":"http://yoursite.com/2018/06/30/使用Echarts.js绘制图表/","excerpt":"","text":"Echarts.js是基于canvas 图画，可视化数据工具。 Echarts官方案例官网下载Echarts 然后引入官网下载Echarts.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;ECharts 入门示例--柱状图&lt;/title&gt; &lt;script src=&quot;../js/echarts.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById(&apos;main&apos;)); // 指定图表的配置项和数据 var option = &#123; title: &#123; text: &apos;ECharts 入门示例&apos; //标题 &#125;, //工具箱 tooltip: &#123; show: true, feature:&#123; saveAsImage:&#123; show: true &#125; &#125; &#125;, //图例 legend: &#123; data:[&apos;销量&apos;] &#125;, //x轴 xAxis: &#123; data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;] &#125;, //Y轴 yAxis: &#123;&#125;, //数据 series: [&#123; name: &apos;销量&apos;, type: &apos;bar&apos;, data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 如图： 更多的配置可以看官方的配置项手册，每一项都有很详细的说明。 异步读取数据 填充图表正常来说我的图表的数据都是异步加载的 不会都是写死的 按照教程的异步加载 我的浏览器是报一个错误 大概意思就是访问的数据应该是以http:开头的 不然读取不到需要开启一个虚拟的服务器才可以读取本地的json数据 我是用node开启了一个本地服务器。参考：https://www.cnblogs.com/leoxuan/p/6513591.html本地创建了dataj.json 文件 用于储存数据,然后异步请求。因为使用jquery的ajax，所以引入了一个jquery。cnd使用的BootCND 非常好用。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;ECharts ajax加载&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/echarts/4.1.0.rc2/echarts-en.common.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;main&quot; style=&quot;width:600px;height:400px;&quot;&gt; &lt;/div&gt; 若在Chrome浏览器下 想要访问本地的data.json文件必须开起一个本地的虚拟服务器以http开头 &lt;br&gt; &lt;a href=&quot;https://www.cnblogs.com/leoxuan/p/6513591.html&quot;&gt;原文博客地址：https://www.cnblogs.com/leoxuan/p/6513591.html&lt;/a&gt; &lt;script&gt; var myChart = echarts.init(document.getElementById(&apos;main&apos;));// 显示标题，图例和空的坐标轴myChart.setOption(&#123; title: &#123; text: &apos;异步数据加载示例&apos; &#125;, tooltip: &#123;&#125;, legend: &#123; data:[&apos;第一年销量&apos;,&apos;第二年销量&apos;] &#125;, xAxis: &#123; data: [] &#125;, yAxis: &#123;&#125;, series: [&#123; name: &apos;第一年销量&apos;, type: &apos;bar&apos;, data: [] &#125;, &#123; name: &apos;第二年销量&apos;, type: &apos;bar&apos;, data: [] &#125; ]&#125;);// 异步加载数据$.get(&apos;http://localhost:8082/example/data.json&apos;).done(function (data) &#123; // 填入数据 myChart.setOption(&#123; xAxis: &#123; data: data.name &#125;, series: [&#123; // 根据名字对应到相应的系列 name: &apos;第一年销量&apos;, data: data.data1 &#125;,&#123; name: &apos;第二年销量&apos;, data: data.data2 &#125;] &#125;);&#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; data.json1&#123;&quot;name&quot;:[&quot;Android&quot;,&quot;IOS&quot;,&quot;PC&quot;,&quot;Other&quot;],&quot;data1&quot;:[420,200,360,100],&quot;data2&quot;:[460,260,390,200]&#125; 如图：","categories":[],"tags":[{"name":"Echarts.js","slug":"Echarts-js","permalink":"http://yoursite.com/tags/Echarts-js/"}]},{"title":"js高程读书笔记（1章-5章）","slug":"js高程读书笔记（1-5）","date":"2018-06-22T14:45:23.000Z","updated":"2018-10-19T09:07:05.885Z","comments":true,"path":"2018/06/22/js高程读书笔记（1-5）/","link":"","permalink":"http://yoursite.com/2018/06/22/js高程读书笔记（1-5）/","excerpt":"","text":"第一章，JavaScript简介1.JavaScript包含三个部分，ECMAScript，DOM，BOM。ECMAScript是JavaScript的核心，包括语法，类型，语句，关键字，保留字，操作符，对象。 ２.ECMAScript提供核心语言功能。DOM提供访问和操作网页内容的方法和接口。BOM提供与浏览器交互的方法和接口。 ３.DOM包含DOM１、DOM２、DOM３。 DOM１由两个模块构成DOM核心和DOM HTML； DOM２引入了DOM视图、DOM事件、DOM样式、DOM遍历和范围； DOM３新增了验证文档的方式，并引入了已统一的方式加载和保存文档的方法。 第二章，在HTML中使用JavaScript在html中内嵌代码12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;holle world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;放到body的底部&lt;/p&gt; &lt;script&gt; alert(&quot;holle world!&quot;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 外部引用文件1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;holle world!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;放到body的底部&lt;/p&gt; &lt;script src=&quot;xxx.js的路径&quot;&gt;&lt;script&gt; &lt;/body&gt;&lt;/html&gt; 第三章，基本概念1. ECMAScript数据类型1.1 有五种基本的数据类型：Undefined，Null，Boolean，Number，String，还有一种复杂的数据类型：Object。typeof可以确定数据类型。[ES6增加新类型：Symbol] 1.2 使用typeof操作符检测null值时会返回“object”，这是因为从逻辑角度来看null指示一个空对象指针。 1.3 Boolean类型的字面值true和false是区分大小写的。若想让其他类型的值转换为Boolean，可以调用转型函数Boolean()。 1.4 Number。八进制第一位必须是0，然后是八进制数字序列（0~7）。十六进制前两位必须是0x，后跟任何十六进制数字（0~9及A~F）。 1有三个函数可以把非数值转换为数值：Number(),parseInt(),parseFloat(); 转换八进制 转换十六进制 空字符 字符串 Number() 忽略前导0，理解为十进制 转换为相同大小的十进制 转换为0 不全为数字的字符串会转换为NaN parseInt() 转换为相同大小的十进制(在函数第二位加参数8) 转换为相同大小的十进制(在函数第二位加参数16) 转换为NaN 若遇到的第一个字符是数字字符，会一直解析直到遇到第一个非数字字符为止；若遇到的第一个字符为非数字字符，转化为NaN parseFloat() 忽略前导0，理解为十进制 忽略前导0x，理解为十进制,转化为0 同上 同上 1.5 String，字符串一旦创建，它的值就不能改变!!!改变的话也只是销毁之后重新创建。 1.6 将一个值转换为字符串，可以使用toString(),Null和Undefined类型没有这个方法。数值，对象，字符串，布尔值均有这个方法。数值调用toString()方法时，可以加参数2,8,10,16，表示转化为相应进制的字符串。 1.7 Object，Object的每个实例都具有以下的属性和方法。 属性和方法名 说明 hasOwnProperty(propertyName) 用于检查给定属性在当前对象实例（而不是实例的原型中）是否存在。eg：o.hasOwnProperty(“name”) isPrototypeOf(object) 用于检查传入的对象是否是传入对象的原型 propertyIsEnumerable(propertyName) 用于检查给定的属性是否能够使用for-in语句来枚举 2.操作符2.1 任何操作数与NaN进行关系比较，结果都是false。大写字母的字符编码全部小于小写字母的字符编码。 2.2 相等和不相等（== ,!=）,强制转换再比较；全等和不全等（===,!==）,仅比较而不转换。 2.3 由于ECMAScript中不存在块级作用域，因此循环内部定义的变量可以在外部访问到。 2.4 for-in语句可以用来枚举对象的属性。 2.5 break和continue，一般情况下，break语句会立即退出循环，强制执行循环后面的语句，而continue语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。但是遇到与labe标签配合使用，一般发生在循环嵌套的情况下，break会退出到label标签的位置，而continue只是会退出内部循环，执行外部循环。 2.6 可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象来访问参数数组。 2.7 ECMAScript没有重载。 第四章 变量，作用域和内存问题1. 基本类型和引用类型的值1.1 ECMAScript变量可能包含两种不同类型的值：基本类型值和引用类型值，基本类型值指的是一个简单的数据段，五种基本数据类型Undifined,Null,Boolean,String,Number是按值访问的,因为可以操作保存在变量中的实际的值。引用类型的值是保存在内存中的对象，JS不允许直接访问内存中的位置，所以引用类型的值是按引用访问的。只有引用类型值可以动态地添加属性。 1.2 访问变量有按值和按引用两种方式，而参数只能按值传递。 1.3 检测类型，typeof,用于确定一个变量是字符串，数值，布尔值，对象还是Undefined的最佳工具。如果一个变量的值是Null或者是Object，则typeof都会返回“Object”。 1.4 instanceof用于确定一个值是哪种引用类型。若使用instanceof操作符检测基本类型值，则该操作符始终会返回false。 alert(person instanceof Object);alert(person instanceof Array);alert(person instanceof RegExp); 2. 执行环境及作用域2.1 在Web浏览器中，全局执行环境被认为是window对象。 2.2 在try-catch语句的catch块和with语句可以在作用域链的前端临时增加一个变量对象，会延长作用域链。 2.3 JS没有块级作用域，即在if和for语句中声明的变量，在其语句结束后不会销毁，会依旧存在于循环外部的执行环境中。 3. 垃圾收集3.1 JS中内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾收集机制的原理是：找出不再使用的变量，然后释放其占用的内存。具体到浏览器，一般有两种实现方法：标记清除，引用计数。 3.2 JS中最常用的垃圾收集机制是标记清除。当变量进入环境时，就将这个变量标记为“进入环境” 3.3 内存管理，使用具备垃圾收集机制的语言编写程序，开发人员一般不必担心内存管理的问题。但是分配给Web浏览器的可用内存通常要比分配给桌面应用程序的少。 3.4 优化内存的最佳方式是：让执行中的代码只保存必要的数据。一旦数据不再使用，最好将其值设置为null来释放其引用。但是，解除一个值的引用并不意味着自动回收该值所占用的内存，解除引用的真正作用是让其值脱离执行环境，以便垃圾收集器下次运行时将其回收。 第五章 引用类型引用类型与传统面向对象程序设计中的类类似，但实现不同。 1. Object类型Object是一种基础类型，其他所有类型都从Object继承了基本的行为。 2. Arrary类型2.1 Array类型的每一项可以保存任何类型的数据。数组的大小是可以动态调整的。 2.2 数组的length属性有个特点——它不是只读的。 2.3 检验数组 方法一：value instanceof Array方法二：Array.isArray(value) 2.4 转化方法：toString(),valueOf(),前者返回由数组中的每个值的字符串形式拼接而成的一个已逗号分隔的字符串。而后者还是返回的是一个数组。 2.5 栈方法和队列方法见这里。 2.6 重排序方法：reverse()和sort(),前者只是反转数组。后者只是对字符串进行排序。若想比较大下，还得接受一个比较函数作为参数。 2.7 操作方法 2.7.1 concat()方法可以基于当前数组中的所有项创建一个新数组。 12var colors = [&quot;red&quot;,&quot;green&quot;];var colors2 = colors.concat(&quot;yellow&quot;,[&quot;black&quot;,&quot;brown&quot;]); 2.7.2 slice()可以基于当前数组中的一个或多个创建一个新数组。该函数接受一个或者两个参数，即要返回项的起始和结束位置。该方法返回起始和结束位置之间的项，但是不包括结束位置的项。 2.7.3 splice()的功能很强大，可以实现数组中元素的删除,插入,替换。该方法接收两个或者三个参数，起始项的位置，要删除的个数，待插入的元素。 2.8 位置方法：ECMAScript5为数组实例添加两个位置方法：indeOf()和lastIndex(),前者从数组开头开始向后查找，后者从数组的末尾开始向前查找。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。未找到的话返回-1。 2.9 迭代方法 方法名 解释(所有方法均运用于数组的每一项) every() 若该函数对每一项都返回true，则返回true filter() 返回该函数会返回true的项组成的数组 forEach() 无返回值 map() 返回每次函数调用的结果组成的数组 some() 若该函数对某一项返回true，则返回true 2.10 归并方法：reduce()和reduceRight(),这两个函数接收四个参数：前一个值，当前值，项的索引和数组对象。 3. Data类型3.1 var now = new Date();新创建的对象会自动获取当前的日期和时间。 3.2 如果想根据特定的日期和时间创建日期对象，必须传入该日期的毫秒数。Date.parse()和Date.UTC()可以实现。 3.3 Date.now()返回表示调用这个方法时的日期和时间的毫秒数。 3.4 日期格式化方法 方法 说明 toDateString() 以特定实现的格式显示星期几，月，日和年 toTimeString() 以特定于实现的格式显示时，分，秒和时区 toLocaleDateString() 以特定于地区的格式显示星期几，月，日和年 toLocaleTimeString() 以特定于地区的格式显示时，分，秒和时区 4. RegExp类型1var expression = / pattern / flags 4.1 flags 说明 g 即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止 i 匹配时忽略模式与字符串的大小写 m 表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项 4.2 RegExp对象的主要方法是exec(),该方法专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组。返回的数组包含两个额外的属性：index和input。index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。 4.3 RegExp的第二个方法是text(),他接受一个字符串参数，在模式与该参数匹配的情况下返回true，否则返回false。 5.Function类型5.1 函数实际也是对象，每个函数都是Function类型的实例。函数是对象，函数名是指针。 5.2 JavaScript的函数没有重载 5.3 JS中即使声明函数的代码在调用它的代码后面，JS也能把函数声明提升到顶部。 5.4 在函数内部，有两个特殊的对象：arguments和this。arguments的主要用途是保存函数的参数，但是它还有一个属性名叫callee，该属性是一个指针，指向拥有该arguments对象的函数。this引用的是函数据以执行的环境对象 5.5 函数的对象的属性caller这个属性保存着调用当前函数的函数的引用。 1234567function outer()&#123; inner(); &#125;function inner()&#123; alert(inner.caller);//也可以是alert(arguments.callee.caller) &#125;outer();//会弹出outer()函数的源代码 5.6 每个函数都包含两个属性：length和prototype。其中length属性表示函数希望接收的命名参数的个数。prototype是保存函数所有实例方法（toString(),valueOf()）的真正所在。 5.7 每个函数都包含两个非继承而来的方法：apply()和call(),这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this的值，实际上，传递参数并非apply()和call()真正的用武之地，它们真正的强大的地方是能够扩充函数赖以运行的作用域。详细用例请点击这里。 1234567891011window.color = &apos;red&apos;;var o = &#123; colar: &apos;blue&apos; &#125;;function sayColor()&#123; alert(this.color); &#125;sayColor(); //redsayColor.call(this); //redsayColor.call(window); //redsayColor.call(o); //blue 使用call()或者apply()的最大好处是：对象不需要和方法有任何耦合关系。 5.8 ECMAScript还定义了一个方法：bind(),这个方法会创建一个函数实例，其this的值会被绑定到传给bind()函数的参数值。 6. 基本包装类型 为了便于操作基本类型值，ECMAScript还提供了三个特殊引用类型：Boolean，Number和String。引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这就意味着我们不能再运行时为基本类型添加属性和方法。 6.1 使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。 123456var val = &apos;25&apos;;var val1 = Number(val);alert(typeof val1); //numbervar val2 = new Number(val);alert(typeof val2); //object val2中保存的是Number的实例。 6.2 字符串大小写转换方法，toLowerCase(),toLocalLowerCase(),toUpperCase(),toLocalUpperCase(); 2015年8月28号回家，今天9月6号，昨天到学校，刚刚写了好多，但是不小心按了backspace,全删了！！！消失的部分以后有心情再写吧 6.3 indexOf()和lastIndexOf()返回待查找字符在字符串中的位置。 6.4 trim()方法会创建一个字符串副本，删除前置及后缀的所有空格，然后返回结果。 6.5 字符串模式匹配方法 方法名 参数 返回值 备注 match() 一个，正则表达式或者RegExp对象 匹配的结果构成的数组 search() 同上 返回字符串中第一个匹配项的索引 replace() 两个，第一个参数和上面的参数一样（也可以是字符串），第二参数是代替换的字符串（也可以是函数） 返回替换后的字符串 split() 两个，第一个参数可以是字符串，也可以是RegExp对象，是指定的分隔符。第二个参数用于指定数组的大小 通过字符串内包含的指定的分隔符，将字符串分割个多个子字符串，将结果返回在一个数组中 可以想象为将铅笔遮住字符串中所以与第一个参数匹配的字符，剩下没有被遮住的部分分别作为数组的每一项返回（可能包括字符串前后的空格） localeCompare() 一个字符串 1（字符串参数在字母表中排在调用函数的字符串前面）；0（相等）；-1 fromCharCode() 一个或多个字符编码 返回对应的字符或字符串 — 7.单体内置对象7.1 内置对象：不必显示地实例化内置对象，因为他们已经实例化了。例如Object，Arrary，String。 7.2 单体内置对象：Globle，Math。 7.3 Globle对象：从某种意义上作为一个终极的“兜底儿对象”，事实上，没有全局变量和全局对象，所有在全局中定义的属性和方法，都是Globle对象的属性。 URL编码方法 encodeURL()和encodeURLComponent()方法可以对URL进行编码，以便发送给浏览器，有效的URL中不能包含某些字符，例如，空格。这两个方法用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。 两个方法中前者用于整个URL（一般只处理空格），后者用于URL的一段（处理所有非字母数字字符） 两个对应的解码分别为decodeURL()和decodeURLComponent()。 eval()方法 eval()方法就像一个完整的ECMAScript解析器。 ECMAScript没有指出如何访问Globle()对象，但web浏览器都是将这个全局对象作为window对象的一部分加以实现。因此在全局作用域中声明的所有变量和函数，就都成了window对象的属性。 7.4 Math()对象 Math对象的属性大都是数学计算中可能用到一些特殊值，例如：Math.PI min()和max() eg: var max = Math.max(3,14,2,14); eg: var values = [1,2,3,4,5,6,7,8,9]; var max = Math.max.apply(Math, values); //Math作为第一个参数，从而正确的设置this的值 舍入方法 12345678910111213&gt; alert(Math.ceil(25.9));&gt; alert(Math.ceil(25.5));&gt; alert(Math.ceil(25.1));&gt; //以上均输出26&gt; alert(Math.floor(25.9));&gt; alert(Math.floor(25.5));&gt; alert(Math.floor(25.1));&gt; //以上均输出25&gt; alert(Math.round(25.9));&gt; alert(Math.round(25.5));&gt; alert(Math.round(25.1));&gt; //前两项输出26，最后一项输出25，遵循四舍五入&gt; Math.random()方法：返回一个大于0小于1的随机数。 12345&gt; function selectFrom(lowValue, upperValue)&#123;&gt; var choice = upperValue - lowValue + 1;&gt; return Math.floor(Math.random()*choice + lowValue);&gt; &#125;&gt; 以上的这个 selectFrom(lowValue, upperValue)可以生成两个参数之间的任意一个随机整数。也可以用于返回数组中的任意一项。 其他方法eg：Math.abs(num) 返回num的绝对值。 内容出处: https://blog.csdn.net/didiaidada/article/details/48007449 因为最近也在读js高程 看了觉得总结的很好 自己也修改补充了一部分。可以没事的时候多看看。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"}]},{"title":"双向数据绑定的原理","slug":"双向数据绑定的原理","date":"2018-06-09T08:10:33.000Z","updated":"2018-10-19T09:41:36.873Z","comments":true,"path":"2018/06/09/双向数据绑定的原理/","link":"","permalink":"http://yoursite.com/2018/06/09/双向数据绑定的原理/","excerpt":"","text":"双向数据绑定的原理在学习Vue和Angular过程中都有一个双向数据绑定的一个东西，Vue中是v-model ,Angular中是ng-model,那他们是怎么实现的，先说是怎么实现的吧，自己也网上找了一下实现的方法，找到了一个比较简洁的实现方法(可能不是vue或者angular源码的实现方法)，仅自己理解的实现方法。1234&lt;div class=&quot;box&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;model&quot;&gt; &lt;span id=&quot;bind&quot;&gt;&lt;/span&gt;&lt;/div&gt; js代码：12345678910&lt;script&gt; model=document.getElementById(&quot;model&quot;); bind=document.getElementById(&quot;bind&quot;); window.onload=function()&#123; model.oninput=function()&#123; bind.innerHTML=model.value; &#125; &#125;&lt;/script&gt; 定义和用法oninput 事件在用户输入时触发。该事件在 &lt;input&gt;或 &lt;textarea&gt;元素的值发生改变时触发。提示： 该事件类似于 onchange 事件。不同之处在于 oninput 事件在元素值发生变化是立即触发， onchange 在元素失去焦点时触发。另外一点不同是 onchange 事件也可以作用于 &lt;keygen&gt; 和 &lt;select&gt; 元素。 逻辑就是使用oninput事件获取每次输入input的value的值，然后使用innerHTML赋给span","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"},{"name":"AngularJS","slug":"AngularJS","permalink":"http://yoursite.com/tags/AngularJS/"}]},{"title":"在小程序中调用API","slug":"在小程序中调用API","date":"2018-05-21T09:20:14.000Z","updated":"2018-10-19T09:17:06.412Z","comments":true,"path":"2018/05/21/在小程序中调用API/","link":"","permalink":"http://yoursite.com/2018/05/21/在小程序中调用API/","excerpt":"","text":"在小程序中调用一言API某一次在csdn看博客，看到了一个功能，就是可以随机显示一句话，都是特别经典的句子，后来便发挥了厚面皮的精神，就去私信问是怎么做的，二话没说那兄弟发给我一个网站， 一言 这个网站是干什么的？一言网(Hitokoto.cn)创立于2016年，隶属于萌创Team，目前网站主要提供一句话服务。动漫也好、小说也好、网络也好，不论在哪里，我们总会看到有那么一两个句子能穿透你的心。我们把这些句子汇聚起来，形成一言网络，以传递更多的感动。如果可以，我们希望我们没有停止服务的那一天。简单来说，一言指的就是一句话，可以是动漫中的台词，也可以是网络上的各种小段子。或是感动，或是开心，有或是单纯的回忆。来到这里，留下你所喜欢的那一句句话，与大家分享，这就是一言存在的目的。 :本段文本源自hitokoto.us. 在一言网上提供了可调用的API 一言API接口说明按照他给的参数和返回json数据，成功的在网页中调用了出来我的一言deom代码展示:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;一言&lt;/title&gt; &lt;style&gt; div &#123; width: 500px; margin: auto; text-align: center; &#125; #hitokoto&#123; font-size: 27px; &#125; p &#123; font-size: 20px; &#125; #btn &#123; padding: 15px 50px; border: 0; background: #00caeb; color: #fff; font-size: 22px; border-radius: 5px; cursor: pointer; &#125; .cc&#123; display: block; text-align: right; padding-right: 20px; font-size: 25px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;p id=&quot;hitokoto&quot;&gt;&lt;/p&gt; &lt;p class=&quot;cc&quot;&gt;『 &lt;span id=&quot;from&quot;&gt;&lt;/span&gt;』&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;button id=&quot;btn&quot; onclick=&quot;window.location.reload();&quot;&gt; 换一换 &lt;/button&gt; &lt;/div&gt; &lt;!-- 以下写法，选取一种即可 --&gt; &lt;!-- 现代写法，推荐 --&gt; &lt;!-- 兼容低版本浏览器 (包括 IE)，可移除 --&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bluebird@3/js/browser/bluebird.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/whatwg-fetch@2.0.3/fetch.min.js&quot;&gt;&lt;/script&gt; &lt;!--End--&gt; &lt;script&gt; fetch(&apos;https://v1.hitokoto.cn&apos;) .then(function (res) &#123; return res.json(); &#125;) .then(function (data) &#123; var hitokoto = document.getElementById(&apos;hitokoto&apos;); hitokoto.innerText = data.hitokoto; &#125;) .catch(function (err) &#123; console.error(err); &#125;) &lt;/script&gt; &lt;!-- 老式写法，兼容性最忧 --&gt; &lt;script&gt; var xhr = new XMLHttpRequest(); xhr.open(&apos;get&apos;, &apos;https://v1.hitokoto.cn&apos;); xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; var data = JSON.parse(xhr.responseText); var hitokoto = document.getElementById(&apos;hitokoto&apos;); var from = document.getElementById(&apos;from&apos;); hitokoto.innerText = data.hitokoto; from.innerText = data.from; &#125; &#125; xhr.send(); &lt;/script&gt; &lt;!-- 新 API 方法， 十分简洁 --&gt; &lt;script src=&quot;https://v1.hitokoto.cn/?encode=js&amp;select=%23hitokoto&quot; defer&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 正好最近也在开发小程序，就心里痒痒。想试试小程序中可不可以调用这个api，小程序中 url：这个是要请求的接口地址data：一个入参method：请求方式，如果是POST请求必须按上面写，默认是get请求，不用处理。complete：页面请求完成后的方法，通过that.setData将数据传递给WXML页面。success：页面加载成功后的执行方法。 如图：js代码：123456789101112131415161718/** * 生命周期函数--监听页面加载 */ onLoad: function () &#123; var that=this wx.request(&#123; url: &apos;https://v1.hitokoto.cn&apos;, header:&#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;, success: function (res)&#123; console.log(res.data) that.setData(&#123; list: res.data &#125;) &#125; &#125;) &#125;, 看完这个代码，你会想，根据微信小程序的绑定原理，这里边的代码哪里调用了onLoad（）这个函数，不用多想，微信小程序给你省略了这些步骤。直接调用list这个数组就行。","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"},{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"},{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"}]},{"title":"Vue","slug":"Vue知识","date":"2018-05-17T02:04:55.000Z","updated":"2019-02-19T09:12:52.524Z","comments":true,"path":"2018/05/17/Vue知识/","link":"","permalink":"http://yoursite.com/2018/05/17/Vue知识/","excerpt":"","text":"vue","categories":[],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"http://yoursite.com/tags/Vue-js/"}]},{"title":"jQuery.Ajax调用的接口","slug":"jQuery.Ajax调用的接口","date":"2018-05-14T09:20:14.000Z","updated":"2018-10-19T09:16:27.341Z","comments":true,"path":"2018/05/14/jQuery.Ajax调用的接口/","link":"","permalink":"http://yoursite.com/2018/05/14/jQuery.Ajax调用的接口/","excerpt":"","text":"jQuery-json调用接口回顾一次面试经历，有一次面试人家问我会不会使用后端的接口（API）因为当时学的都是写的静态页面 所以自然不知了，虽然那次面试很糟糕，但是收获也是很多的。面试官后来告诉我一个网站就是这个网站：showAPI;上面有很多的免费的API接口可以试着调用 ，很感谢那位面试我的大佬。今天有时间就顺便试了一下，调用了一个API “历史上的今天”使用的jQuery解析的发送的ajax请求，然后他的服务器会返回一个json数据，使用 $.each在循环解析到页面中，虽然很小的一个小练习，但是对前后端数据交互有个更深的理解，可能对于大家来说还是挺lou的 ，但对我自己来说确实很大的进步了。不喜勿喷。 先放预览地址吧：历史上的今天 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546function Jdeta() &#123; //alert(typeof dataNum) $.ajax(&#123; type: &apos;post&apos;, url: &apos;http://route.showapi.com/119-42&apos;, dataType: &apos;json&apos;, data: &#123; &quot;showapi_timestamp&quot;: formatterDateTime(), &quot;showapi_appid&quot;: &apos;61967&apos;, //这里需要改成自己的appid &quot;showapi_sign&quot;: &apos;efc7d95dafb14c9dabf3867072d12b28&apos;, //这里需要改成自己的应用的密钥secret &quot;date&quot;: &quot;&quot; &#125;, error: function (XmlHttpRequest, textStatus, errorThrown) &#123; alert(&quot;操作失败!&quot;); &#125;, success: function (result) &#123; console.log(result) //console变量在ie低版本下不能用 //alert(result.showapi_res_code + &quot;调用成功&quot;) var title = document.getElementById(&quot;title&quot;); title.innerHTML = result.showapi_res_body.list[0].title; var img = document.getElementById(&quot;img&quot;); img.src = result.showapi_res_body.list[0].img; var day = document.getElementById(&quot;day&quot;); day.innerHTML = result.showapi_res_body.list[0].day; var month = document.getElementById(&quot;month&quot;); month.innerHTML = result.showapi_res_body.list[0].month; var year = document.getElementById(&quot;year&quot;); year.innerHTML = result.showapi_res_body.list[0].year; var json = eval(result.showapi_res_body.list); //数组 var result = &quot;&quot;; $.each(json, function (index) &#123; //循环获取数据 var title = json[index].title; var year = json[index].year; var month = json[index].month; var day = json[index].day; var img = json[index].img result += &quot;标题：&quot;+title +&quot;&lt;br/&gt;时间：&quot;+ year + &quot;年-&quot; + month + &quot;月-&quot; + day + &quot;日&lt;br/&gt;&lt;img src=&quot;+img+&quot; alt/&gt;&quot;+&quot;&lt;br&gt;&lt;br&gt;&quot;; &#125;); $(&quot;#list&quot;).html(&apos;&apos;); $(&quot;#list&quot;).html(result); &#125; &#125;); &#125;","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"},{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"}]},{"title":"小程序学习记录二","slug":"小程序学习记录二","date":"2018-04-06T12:20:14.000Z","updated":"2018-10-19T09:27:03.272Z","comments":true,"path":"2018/04/06/小程序学习记录二/","link":"","permalink":"http://yoursite.com/2018/04/06/小程序学习记录二/","excerpt":"","text":"在写小程序的过程中会发现里面的有些使用和vue很相似，有相关基础上手并不是很难，难点主要在于js的逻辑交互， 小程序的启动微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。 紧接着通过 app.json 的 pages 字段就可以知道你当前小程序的所有页面路径:123&#123; &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ]&#125; 这个配置说明在 QuickStart 项目定义了两个页面，分别位于 pages/index/index 和 pages/logs/logs 目录。而写在 pages 字段的第一个页面就是这个小程序的首页(打开小程序看到的第一个页面)。 于是微信客户端就把首页的代码装载进来，通过小程序底层的一些机制，就可以渲染出这个首页。 小程序启动之后，在 app.js 定义的 App 实例的 onLaunch 回调会被执行:1234App(&#123; onLaunch: function () &#123; // 小程序启动之后 触发 &#125;&#125;) 整个小程序只有一个 App 实例，是全部页面共享的，更多的事件回调参考文档 注册程序 App 。 接下来我们简单看看小程序的一个页面是怎么写的。 程序与页面 你可以观察到 pages/logs/logs 下其实是包括了4种文件的，微信客户端会先根据 logs.json 配置生成一个界面，顶部的颜色和文字你都可以在这个 json 文件里边定义好。紧接着客户端就会装载这个页面的 WXML 结构和 WXSS 样式。最后客户端会装载 logs.js，你可以看到 logs.js 的大体内容就是:1234567Page(&#123; data: &#123; // 参与页面渲染的数据 logs: [] &#125;, onLoad: function () &#123; // 页面渲染后 执行 &#125;&#125;) Page 是一个页面构造器，这个构造器就生成了一个页面。在生成页面的时候，小程序框架会把 data 数据和 index.wxml 一起渲染出最终的结构，于是就得到了你看到的小程序的样子。 在渲染完界面之后，页面实例就会收到一个 onLoad 的回调，你可以在这个回调处理你的逻辑。 有关于 Page 构造器更多详细的文档参考 注册页面 Page 。 组件 小程序提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼合成自己的小程序。 就像 HTML 的 div, p 等标签一样，在小程序里边，你只需要在 WXML 写上对应的组件标签名字就可以把该组件显示在界面上，例如，你需要在界面上显示地图，你只需要这样写即可： map&gt;使用组件的时候，还可以通过属性传递值给组件，让组件可以以不同的状态去展现，例如，我们希望地图一开始的中心的经纬度是广州，那么你需要声明地图的 longitude(中心经度) 和 latitude(中心纬度) 两个属性: map&gt;组件的内部行为也会通过事件的形式让开发者可以感知，例如用户点击了地图上的某个标记，你可以在 js 编写 markertap 函数来处理： map&gt;当然你也可以通过 style 或者 class 来控制组件的外层样式，以便适应你的界面宽度高度等等。 需要注意的是：多数 API 的回调都是异步，你需要处理好代码逻辑的异步问题。 更多的 API 能力见 小程序的API 。其实小程序的官网教程讲的也很明白透彻，看官方教程就可以了，而且小程序有丰富的组件，使用时很方便的， 更多的组件可以参考 小程序的组件 。 基础组件为了让开发者可以很方便的调起微信提供的能力，例如获取用户信息、微信支付等等，小程序提供了很多 API 给开发者去使用。 要获取用户的地理位置时，只需要：123456wx.getLocation(&#123; type: &apos;wgs84&apos;, success: (res) =&gt; &#123; var latitude = res.latitude // 经度 var longitude = res.longitude // 纬度 &#125;&#125;) 调用微信扫一扫能力，只需要：1234wx.scanCode(&#123; success: (res) =&gt; &#123; console.log(res) &#125;&#125;) 框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。 什么是组件： 组件是视图层的基本组成单元。组件自带一些功能与微信风格的样式。一个组件通常包括开始标签和结束标签，属性用来修饰这个组件，内容在两个标签之内。123&lt;tagname property=&quot;value&quot;&gt; Content goes here ...&lt;/tagname&gt; 注意：所有组件与属性都是小写，以连字符-连接 属性类型 类型 描述 注解Boolean 布尔值 组件写上该属性，不管该属性等于什么，其值都为true，只有组件上没有写该属性时，属性值才为false。如果属性值为变量，变量的值会被转换为Boolean类型Number 数字 1, 2.5String 字符串 “string”Array 数组 [ 1, “string” ]Object 对象 { key: value }EventHandler 事件处理函数名 “handlerName” 是 Page中定义的事件处理函数名Any 任意属性共同属性类型 所有组件都有的属性： 属性名 类型 描述 注解id String 组件的唯一标示 保持整个页面唯一class String 组件的样式类 在对应的 WXSS 中定义的样式类style String 组件的内联样式 可以动态设置的内联样式hidden Boolean 组件是否显示 所有组件默认显示data- Any 自定义属性 组件上触发的事件时，会发送给事件处理函数bind / catch* EventHandler 组件的事件 详见事件特殊属性 几乎所有组件都有各自定义的属性，可以对该组件的功能或样式进行修饰，请参考各个组件的定义。 视图容器(View Container)：view 视图容器scroll-view 可滚动视图容器 swiper 滑块视图容基础内容(Basic Content)：icon 图标text 文字 progress 进度条表单(Form)：button 按钮form 表单input 输入框checkbox 多项选择器radio 单项选择器picker 列表选择器picker-view 内嵌列表选择器slider 滚动选择器switch 开关选择器 label 标签导航(Navigation)： navigator 应用链接多媒体(Media)：audio 音频image 图片 video 视频地图(Map)： map 地图画布(Canvas)：canvas 画布","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"}]},{"title":"织梦CMS制作简单模板站","slug":"织梦CMS制作简单模板站","date":"2018-04-01T09:20:14.000Z","updated":"2018-12-21T08:21:41.169Z","comments":true,"path":"2018/04/01/织梦CMS制作简单模板站/","link":"","permalink":"http://yoursite.com/2018/04/01/织梦CMS制作简单模板站/","excerpt":"","text":"华强北商城电子商务网站github地址：https://github.com/AnsonZnl/HuaQiangBei模板文件放在织梦cms的theme下，然后导入数据库即可。主要功能有： 搜索， 添加购物车 后天管理商品 js轮播图和css3特效。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"CMS","slug":"CMS","permalink":"http://yoursite.com/tags/CMS/"}]},{"title":"Bootstrap常用的Css类","slug":"Bootrtsp常用的Css类","date":"2018-03-21T09:20:14.000Z","updated":"2018-10-19T09:34:49.300Z","comments":true,"path":"2018/03/21/Bootrtsp常用的Css类/","link":"","permalink":"http://yoursite.com/2018/03/21/Bootrtsp常用的Css类/","excerpt":"","text":"Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷使用它可以快速开发一个适应手机、平板、电脑的网站，比如我的法标珠光卫浴 http://zhangningle.gitee.io/fabiaozhuguangweiyv/手机显示：电脑显示： bootstrap常用类记录：记录一下bootrtsp常用的类，下次使用方便快速查阅！1.起步2.全局css样式 1)按钮相关class .btn 按钮基础样式 .btn-danger 红色按钮 .btn-warming 黄色按钮 .btn-success 绿色按钮 .btn-info 浅蓝色按钮 .btn-primary 深蓝色按钮 .btn-lg 大号按钮 .btn-sm 小号按钮 .btn-xs 超小号按钮 .btn-block 块级按钮 注：用button写按钮时，必须要写type属性 2)图片相关class .img-circle 圆形图片 .img-rounded 圆角图片 .img-thumbnail 缩略图片 .img-responsive 响应式图片 3)文本相关class .text-danger/warming/success/info/primary 文本的5种颜色 .bg-danger/warming/success/info/primary 5种背景颜色 .text-uppercase 转大写 .text-lowercase 转小写 .text-capitalize 转首字母大写 .text-left 文本左对齐 .text-right 文本右对齐 .text-center 文本居中对齐 .text-justify 两端调整对齐 4)辅助类 .caret 三角符号 .close 关闭按钮 .pull-left 左浮动 .pull-right 右浮动 5)表格（小重点） .table 基础表格 .table-borderd 带边框的表格 .table-striped 隔行变色的表格 .table-hover 带鼠标悬停效果的表格 .table-responsive 响应式表格，必须使用在table的父元素div上 注：.table-responsive的正确使用方法。如果想让某一行或某一列变背景，直接在tr或td上加class属性即可 6)栅格布局系统(重点) a.最外层必须是容器类.container或.container-fluid b.容器中必须放置行:.row c.行中必须放置列:.col &lt;div class=&apos;container&apos;&gt; &lt;div class=&apos;row&apos;&gt; &lt;div class=&apos;col-md-3 col-sm-6 col-xs-12&apos;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 针对不同的屏幕有不同的列 .col-lg-* 适用于超大pc屏幕 .col-md-* 适用于中等pc屏幕 .col-sm-* 适用于pad屏幕 .col-xs-* 适用于phone屏幕 .col-md-offset-1/2/3.... pc屏幕中向右偏移多少个 .col-sm-offset-1/2/3.... pad屏幕中向右偏移多少个 .col-xs-offset-1/2/3.... phone屏幕中向右偏移多少个 不同的列在不同屏幕下哟不同的适用性 .col-lg-* 只适用于lg屏幕 .col-md-* 适用于lg/md屏幕 .col-sm-* 适用于lg/md/sm屏幕 .col-xs-* 适用于lg/md/sm/xs屏幕 可以指定某列在特定尺寸的屏幕下隐藏 .hidden-lg 在lg屏幕下隐藏 .hidden-md 在md屏幕下隐藏 .hidden-sm 在sm屏幕下隐藏 .hidden-xs 在xs屏幕下隐藏 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-6&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-xs-6&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 7)表单(难点) a.默认表单 &lt;form&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;用户名&lt;/label&gt; &lt;input class=&quot;form-control&quot;&gt; &lt;span class=&quot;help-block&quot;&gt;用户名可以包含数字，字母和下划线&lt;/span&gt; &lt;/div&gt; &lt;/form&gt; b.行内表单 &lt;form class=&apos;form-inline&apos;&gt; &lt;div class=&apos;form-group&apos;&gt; &lt;label class=&apos;sr-only&apos;&gt;用户名&lt;/label&gt; &lt;input class=&apos;form-control&apos; placeholder=&quot;请输入用户名&quot;&gt; &lt;/div&gt; &lt;/form&gt; 注：.sr-only是 除了屏幕阅读器外，其他设备上隐藏该元素，这个是用于屏幕阅读器的，帮助残障人士更好的访问网站。 c.水平表单(难点) &lt;form class=&apos;form-horizontal&apos;&gt; &lt;div class=&apos;form-group&apos;&gt; &lt;div class=&apos;col-**-**&apos;&gt; &lt;label&gt;用户名&lt;/label&gt; &lt;/div&gt; &lt;div class=&apos;col-**-**&apos;&gt; &lt;input class=&apos;form-control&apos;&gt; &lt;/div&gt; &lt;div class=&apos;col-**-**&apos;&gt; &lt;span class=&quot;help-block&quot;&gt;用户名可以包含数字字母和下划线&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; 3.组件 1.图标字体 使用方法 注：span中不能有任何文本或子标签 2.按钮组 .btn-group .btn-group-justified 占满屏幕的按钮组 .btn-group-lg/sm/xs 不同型号的按钮 .btn-group-vertical 竖直按钮 3.下拉菜单 &lt;div class=&apos;dropdown&apos;&gt; &lt;a data-toggle=&apos;dropdown&apos;&gt;触发元素&lt;/a&gt; &lt;ul class=&apos;dropdown-menu&apos;&gt; &lt;li&gt;小鸡&lt;/li&gt; &lt;li&gt;小鸭&lt;/li&gt; &lt;li&gt;小狗&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 4.导航 a.标签页式导航 &lt;ul class=&apos;nav nav-tabs&apos;&gt; &lt;li class=&apos;active&apos;&gt; &lt;a data-toggle=&apos;tab&apos;&gt;详情信息&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a&gt;评论&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; .nav 去除了li默认的样式 .nav-tabs 浮动，并增加了下边框 .active 显示当前页 .data-toggle 每个li可以来回切换 b.胶囊式导航 &lt;ul class=&apos;nav nav-pills&apos;&gt; &lt;li class=&apos;active&apos;&gt; &lt;a data-toggle=&apos;tab&apos;&gt;详情信息&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a data-toggle=&apos;tab&apos;&gt;评论&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; c.导航条中的导航 &lt;ul class=&apos;nav navbar-nav&apos;&gt; &lt;li class=&apos;active&apos;&gt; &lt;a data-toggle=&apos;tab&apos;&gt;详情信息&lt;/a&gt; &lt;li&gt; &lt;li&gt; &lt;a data-toggle=&apos;tab&apos;&gt;评论&lt;/a&gt; &lt;li&gt; &lt;/ul&gt; 5.警告框 &lt;div class=&apos;alert alert-dismiss alert-danger&apos;&gt; &lt;span class=&apos;close&apos; data-dismiss=&apos;alert&apos;&gt;$times;&lt;/span&gt; &lt;/div&gt; 6.进度条 //普通进度条 &lt;div class=&apos;progress&apos;&gt; &lt;div class=&apos;progress-bar&apos; style=&apos;width:30%&apos;&gt;&lt;/div&gt; &lt;/div&gt; //带条纹的进度条 &lt;div class=&apos;progress&apos;&gt; &lt;div class=&apos;progress-bar progress-bar-striped&apos; style=&apos;width:30%&apos;&gt;&lt;/div&gt; &lt;/div&gt; //带条纹会动的进度条 &lt;div class=&apos;progress&apos;&gt; &lt;div class=&apos;progress-bar progress-bar-striped active&apos; style=&apos;width:30%&apos;&gt;&lt;/div&gt; &lt;/div&gt; 7.路径导航(面包屑) &lt;ul class=&quot;breadcrumb&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;国内新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;泊头新闻&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 8.分页条(pagination) &lt;ul class=&quot;pagination&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;前一页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;当前页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;后一页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 注：li里面必须要有a 9.分页器(pager) &lt;ul class=&quot;pager&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;前一页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;后一页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 10.徽章(badge) &lt;a href=&quot;#&quot; class=&quot;btn btn-warning&quot;&gt; 收件箱 &lt;span class=&quot;badge&quot;&gt;4&lt;/span&gt; &lt;/a&gt; 11.标签(label) &lt;span class=&quot;label label-danger&quot;&gt;danger&lt;/span&gt; &lt;span class=&quot;label label-warning&quot;&gt;warning&lt;/span&gt; &lt;span class=&quot;label label-success&quot;&gt;success&lt;/span&gt; &lt;span class=&quot;label label-info&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;label label-primary&quot;&gt;primary&lt;/span&gt; 12.巨幕 &lt;div class=&quot;jumbotron&quot;&gt; &lt;h1&gt;hello world&lt;/h1&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Modi obcaecati possimus voluptas! Accusantium aperiam, autem dolor dolorem eaque molestiae necessitatibus nihil nobis perspiciatis praesentium quidem reiciendis sapiente soluta sunt voluptas.&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;#&quot; class=&quot;btn btn-warning&quot;&gt;按钮&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; 13.页头 &lt;div class=&quot;page-header&quot;&gt; &lt;h1&gt;hello world hello world&lt;/h1&gt; &lt;/div&gt; 14.水井（well） &lt;div class=&quot;well&quot;&gt; i have a good idea &lt;/div&gt; 15.列表组： 使用ul&gt;li实现列表组 &lt;ul class=&quot;list-group&quot;&gt; &lt;li class=&quot;list-group-item&quot;&gt;首页&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;详情页&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;联系我们&lt;/li&gt; &lt;/ul&gt; 使用div&gt;a实现列表组(有默认的鼠标悬停效果) &lt;div class=&quot;list-group&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;首页&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;详情页&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;list-group-item&quot;&gt;联系我们&lt;/a&gt; &lt;/div&gt; 16.缩略图(缩略图一般配合栅格布局系统使用，实现批量的商品展示) &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;img/1.jpg&quot; alt=&quot;&quot;/&gt; &lt;div class=&quot;caption&quot;&gt; &lt;p&gt;国画&lt;/p&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-warning&quot;&gt;加入购物车&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; 17.媒体对象 &lt;div class=&quot;media&quot;&gt; &lt;div class=&quot;media-left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;media-body&quot;&gt;&lt;/div&gt; &lt;/div&gt; 18.面板和面板组(面板组内容分为三部分:头，主体，尾部)，多个面板组合(称为面板组)可以实现手风琴的效果 &lt;div class=&quot;panel panel-success&quot;&gt; &lt;div class=&quot;panel-heading&quot;&gt;&lt;/div&gt; &lt;div class=&quot;panel-body&quot;&gt;&lt;/div&gt; &lt;div class=&quot;panel-footer&quot;&gt;&lt;/div&gt; &lt;/div&gt; 4.插件 1.折叠效果 Lorem ipsum dolor sit amet, consectetur adipisicing elit. Accusamus deleniti ea expedita fugiat ipsum, natus optio recusandae vitae. Assumenda autem doloremque dolores ipsam ipsum modi molestias perferendis placeat, ut vero! 折叠效果的两个重要扩展 1.手风琴----重点 面板组+折叠效果插件 2.响应式导航条---重点&amp;&amp;难点 “响应式导航条”必须配合折叠效果插件使用。 响应式导航条在PHONE中只显示一个LOGO + 一个汉堡包按钮，其他菜单项全在折叠下拉菜单中；PAD和PC中，下拉菜单要实现绝对对位，定位到LOGO后面去。 “响应式导航条”必须配合折叠效果插件使用。 响应式导航条在PHONE中只显示一个LOGO + 一个汉堡包按钮，其他菜单项全在折叠下拉菜单中；PAD和PC中，下拉菜单要实现绝对对位，定位到LOGO后面去。 Bootstrap中导航条分类： (1)按颜色分： 白底黑字： .navbar-default 黑底白字： .navbar-inverse (2)按定位方式分： 相对定位： 默认 固定定位： .navbar-fixed-* (3)按所在位置分： 固定在顶部： .navbar-fixed-top 固定在底部： .navbar-fixed-bottom &lt;div class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;!--导航条头部 = brand + toggle--&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;/div&gt; &lt;!--导航条折叠部分 = 导航 + 链接 + 表单 + 按钮 ...--&gt; &lt;div id=&quot;my-menu&quot; class=&quot;collapse navbar-collapse&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; Bootstrap中导航条分类： (1)按颜色分： 白底黑字： .navbar-default 黑底白字： .navbar-inverse (2)按定位方式分： 相对定位： 默认 固定定位： .navbar-fixed-* (3)按所在位置分： 固定在顶部： .navbar-fixed-top 固定在底部： .navbar-fixed-bottom &lt;div class=&quot;navbar navbar-default&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;!--导航条头部 = brand + toggle--&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;/div&gt; &lt;!--导航条折叠部分 = 导航 + 链接 + 表单 + 按钮 ...--&gt; &lt;div id=&quot;my-menu&quot; class=&quot;collapse navbar-collapse&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 2.补充：列偏移 vs 列排序 列偏移：控制一列出现的位置，某列偏移后，后续的列都会随之偏移——只能往右偏移 col-lg/md/sm/xs-offset-* 列排序：控制一列出现的位置，某列可以往左拉或往右推——可以往右往左调整——某列排序后，其他列没有任何影响！ col-lg/md/sm/xs-push-* col-lg/md/sm/xs-pull-* 2.Boostrap第四部分：jQuery插件 Bootstrap基于jQuery提供了十几个插件函数，可以有两种调用方法： (1)JS调用方式： $(&apos;a&apos;).dropdown( ); (2)data-*调用方式： &lt;a data-toggle=&quot;dropdown&quot;&gt;&lt;/a&gt; 提示：官方推荐使用方式2！但有两个插件提交特别：需要方式1和2同时使用才能奏效。 3.Boostrap第四部分：jQuery插件——下拉菜单 &lt;div class=&quot;dropdown&quot;&gt; &lt;a data-toggle=&quot;dropdown&quot;&gt;触发元素&lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;/div&gt; 4. Boostrap第四部分：jQuery插件——导航 &lt;ul class=&quot;nav nav-tabs&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;二十元套餐&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a data-toggle=&quot;tab&quot; href=&quot;#&quot;&gt;二十元套餐&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 5. Boostrap第四部分：jQuery插件——警告框 &lt;div class=&quot;alert&quot;&gt; &lt;span class=&quot;close&quot; data-dismiss=&quot;alert&quot;&gt;&amp;times;&lt;/span&gt; &lt;/div&gt; 6. Boostrap第四部分：jQuery插件——折叠 &lt;a data-toggle=&quot;collapse&quot; href=&quot;#box&quot;&gt;展开收起&lt;/a&gt; &lt;div id=&quot;box&quot; class=&quot;collapse&quot;&gt;&lt;/div&gt; 7. Boostrap第四部分：jQuery插件——工具提示 对HTML元素的title属性的呈现效果加以改观。 &lt;ANY title=&quot;工具提示的内容&quot; data-toggle=&quot;tooltip&quot;&gt; &lt;script&gt; $(&apos;[data-toggle=&quot;tooltip&quot;]&apos;).tooltip(); &lt;/script&gt; 注意：此插件必须同时声明data-*和js调用！还有一些可选参数，参考手册即可。 8. Boostrap第四部分：jQuery插件——弹出框 &lt;ANY title=&quot;弹出框的标题&quot; data-content=&quot;弹出框的内容&quot; data-toggle=&quot;popover&quot;&gt; &lt;script&gt; $(&apos;[data-toggle=&quot;popover&quot;]&apos;).popover(); &lt;/script&gt; 注意：此插件必须同时声明data-*和js调用！还有一些可选参数，参考手册即可。 Module：模块 Model：模型 Modal：模态对话框 9.Boostrap第四部分：jQuery插件—— 模态框 —— 重点 Modal：模态对话框——在父窗口中弹出的子窗口，只要不关闭，则父窗口无法再获得输入焦点。 &lt;a data-toggle=&quot;modal&quot; href=&quot;#mid&quot;&gt;打开模态框&lt;/a&gt; &lt;button data-toggle=&quot;modal&quot; data-target=&quot;#mid&quot;&gt;打开模态框&lt;/button&gt; 模态框必需的HTML结构： &lt;div id=&quot;mid&quot; class=&quot;modal&quot;&gt; 半透明遮罩层 &lt;div class=&quot;modal-dialog&quot;&gt; 尺寸位置 &lt;div class=&quot;modal-content&quot;&gt; 背景/边框/倒角/阴影 &lt;div class=&quot;modal-header&quot;&gt; &lt;span data-dismiss=&quot;modal&quot; class=&quot;close&quot;&gt;&amp;times;&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;modal-body&quot;&gt;&lt;/div&gt; &lt;div class=&quot;modal-footer&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 10. jQuery插件——轮播广告 —— 重点 提示：轮播广告的结构比较复杂！只要记得根元素 div.carousel（旋转木马），剩余的全靠Bootlint的错误提示。 &lt;div class=&quot;carousel&quot; data-ride=&quot;carousel&quot;&gt; &lt;div class=&quot;carousel-inner&quot;&gt; &lt;div class=&quot;item active&quot;&gt; &lt;img&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 练习： (1)为每个广告添加说明文字 (2)添加“上一条”、“下一条”按钮 (3)添加序号指示器","categories":[],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"},{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"}]},{"title":"CSS3动画","slug":"CSS3动画","date":"2018-03-17T09:20:14.000Z","updated":"2018-10-19T08:37:33.047Z","comments":true,"path":"2018/03/17/CSS3动画/","link":"","permalink":"http://yoursite.com/2018/03/17/CSS3动画/","excerpt":"","text":"最近一直在做H5的微场景，用到很多css3的特效，在这里把常用的总结一下吧， border-radius创建圆角边框 box-shadow 添加阴影 background-size 属性规定背景图片的尺寸。 123transform: rotateX(120deg);-webkit-transform: rotateX(120deg); /* Safari 和 Chrome */-moz-transform: rotateX(120deg); 3d转换 transition css3过渡CSS3 过渡是元素从一种样式逐渐改变为另一种的效果。要实现这一点，必须规定两项内容：规定把效果添加到哪个 CSS 属性上规定效果的时长 1234 CSS3 @keyframes 规则如需在 CSS3 中创建动画，您需要学习 @keyframes 规则。@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。 创建css3动画，可代替一些js效果，","categories":[],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}]},{"title":"初试织梦CMS","slug":"初试织梦CMS","date":"2018-03-11T09:20:14.000Z","updated":"2018-10-19T09:03:39.580Z","comments":true,"path":"2018/03/11/初试织梦CMS/","link":"","permalink":"http://yoursite.com/2018/03/11/初试织梦CMS/","excerpt":"","text":"织梦CMS这些天学习了织梦cms内容管理系统， 织梦内容管理系统(DedeCms) 以简单、实用、开源而闻名，是国内最知名的PHP开源网站管理系统，也是使用用户最多的PHP类CMS系统，在经历多年的发展，目前的版本无论在功能，还是在易用性方面，都有了长足的发展和进步，DedeCms免费版的主要目标用户锁定在个人站长，功能更专注于个人网站或中小型门户的构建，当然也不乏有企业用户和学校等在使用该系统。 安装好phpstudy(phpStudy是一个PHP调试环境的程序集成包。该程序包集成最新的Apache+PHP+MySQL+phpMyAdmin+ZendOptimizer,一次性安装，无须配置即可使用，是非常方便、好用的PHP调试环境) 去织梦官网下载最新的织梦后台模板， 下完把梦后台放在phpstudy的后台的www目录下，并配置站点域名。打开运行 phpstudy下载：http://www.phpstudy.net/织梦cms下载：http://www.dedecms.com/products/dedecms/downloads/HostsEditor 编辑hosts文件（配置域名）：https://pan.baidu.com/s/1o79DCAu 简单熟悉织梦的后台操作后，开始自己学着做模板，首先先熟悉织梦的标签生成器的使用：学会后可以很方便的构造自己喜欢的网站 常用的的织梦标签有：都是常用的一些标签，大家可以用ctrl+F实现搜索。 网站名称：{dede:global.cfg_webname/} 网站根网址：{dede:global.cfg_basehost/} 网站根目录：{dede:global.cfg_cmsurl/} 网页主页链接：{dede:global.cfg_indexurl/} 网站描述：{dede:global.cfg_description/} 网站关键字：{dede:global.cfg_keywords/} 模板路径：{dede:global.cfg_templets_skin/} 调用页面：{dede:include filename=”head.htm”/} 网站编码：{dede:global.cfg_soft_lang/}调用时间：[field:pubdate function=MyDate(‘y-m-d’,@me)/] 调用缩略图：{dede:arclist row=10 orderby=pubdate type=’image.’ imgwidth=’定义图片宽度’ imgheight=’高度’}[field:image/]{/dede:arclist} 调用缩略图原图：[field:litpic runphp=’yes’]$youjoys = array(“-lp”, “_lit”);@me = str_replace ($youjoys, “”, @me);[/field:litpic] 调用单个栏目：12&#123;dede:type&#125;&lt;a href=&quot;[field:typelink /]&quot;&gt;[field:typename /]&lt;/a&gt; {/dede:type}文章标题：{dede:field.title/} 文章描述：{dede:field.description function=’html2text(@me)’/} 文章关键词：{dede:field.keywords/} 当前位置：{dede:field name=’position’/} 文章时间：{dede:field.pubdate function=”MyDate(‘Y-m-d H:i’,@me)”/} 文章来源：{dede:field.source/} 文章作者：{dede:field.writer/} 文章内容：{dede:field.body/} 上一篇：{dede:prenext get=’pre’/} 下一篇：{dede:prenext get=’next’/} 点击量：channel|频道标签： 标签名称：channel标记简介：织梦常用标记，通常用于网站顶部以获取站点栏目信息，方便网站会员分类浏览整站信息功能说明：用于获取栏目列表适用范围：全局使用 基本语法：123&#123;dede:channel type=&apos;top&apos; row=&apos;8&apos; currentstyle=&quot;&lt;li&gt;&lt;a href=&apos;~typelink~&apos; class=&apos;thisclass&apos;&gt;~typename~&lt;/a&gt; &lt;/li&gt;&quot;&#125; &lt;li&gt;&lt;a href=&apos;[field:typelink/]&apos;&gt;[field:typename/]&lt;/a&gt; &lt;/li&gt;&#123;/dede:channel&#125; 参数说明：typeid = ‘0’ 栏目IDreid = ‘0’ 上级栏目IDrow = ‘100’ 调用栏目数col = ‘1’ 分多少列显示（默认为单列）type = ‘son | sun’ son表示下级栏目,self表示同级栏目,top顶级栏目currentstyle = ‘’ 应用样式 底层模板字段：ID(同 id),typeid, typelink, typename, typeurl,typedir(仅表示栏目的网址) [field:id/][field:typeid/][field:typelink/] 调用栏目名称，点击直接跳转该栏目列表[field:typename/] 调用栏目名称，无链接[field:typeurl/][field:typedir/] 例：123&#123;dede:channel type=&apos;top&apos;&#125;&lt;a href=&apos;[field:typelink /]&apos;&gt;[field:typename/]&lt;/a&gt; &#123;/dede:channel&#125; 注：在没有指定typeid的情况下，type标记与模板的环境有关，如，模板生成到栏目一，那么type=’son’就表示栏目一的所有子类arclist|文档列表： 标签名称：arclist标记简介：织梦常用标记，也称为自由列表标记，其中imglist、imginfolist、specart、coolart、autolist都是由该标记所定义的不同属性延伸出来的别名标记。功能说明：获取指定文档列表适用范围：全局使用 基本语法：123&#123;dede:arclist flag=&apos;h&apos; typeid=&apos;&apos; row=&apos;&apos; col=&apos;&apos; titlelen=&apos;&apos; infolen=&apos;&apos; imgwidth=&apos;&apos; imgheight=&apos;&apos; listtype=&apos;&apos; orderby=&apos;&apos; keyword=&apos;&apos; limit=&apos;0,1&apos;&#125;&lt;a href=&apos;[field:arcurl/]&apos;&gt;[field:title/]&lt;/a&gt;&#123;/dede:arclist&#125; 参数说明：col=’’ 分多少列显示（默认为单列），5.3版中本属性可以通过多种方式进行多行显示如果col=’1’要多列显示的可用div+css实现以下为通过div+css实现多列的示例：123456&lt;style type=text/css&gt;div&#123;width:400px;float:left;&#125;&lt;/style&gt;&#123;dede:arclist row=&apos;10&apos; titlelen=&apos;24&apos; orderby=&apos;pubdate&apos; idlist=&apos;&apos; col=&apos;2&apos;&#125;?[field:textlink/]([field:pubdate function=MyDate(&apos;m-d&apos;,@me)/])&lt;br/&gt;&#123;/dede:arclist&#125; 当col&gt;1将使用原来的table多列方式显示row=’10’ 返回文档列表总数typeid=’’ 栏目ID,在列表模板和档案模板中一般不需要指定，在首页模板中允许用”,”分开表示多个栏目；getall=’1’ 在没有指定这属性的情况下,在栏目页、文章页模板,不会获取以”,”分开的多个栏目的下级子类titlelen = ‘30’ 标题长度 等同于titlelengthinfolen=’160’ 表示内容简介长度 等同于infolengthimgwidth=’120’ 缩略图宽度imgheight=’90’ 缩略图高度listtype=’all’ 栏目类型 image含有缩略图 commend推荐orderby=’sortrank’ 文档排序方式§ orderby=’hot’ 或 orderby=’click’ 表示按点击数排列§ orderby=’sortrank’ 或 orderby=’pubdate’ 按出版时间排列§ orderby=’near’§ orderby==’lastpost’ 按最后评论时间§ orderby==’scores’ 按得分排序§ orderby=’id’ 按文章ID排序§ orderby=’rand’ 随机获得指定条件的文档列表keyword=’’ 含有指定关键字的文档列表，多个关键字用”,”分innertext = ‘’ 单条记录样式aid=’’ 指定文档IDidlist =’’ 提取特定文档（文档ID）channelid 频道IDlimit=’起始ID,记录数’ （起始ID从0开始）表示限定的记录范围（如：limit=’1,2’ 表示从ID为1的记录开始，取2条记录）flag = ‘h’ 自定义属性值：头条[h]推荐[c]图片[p]幻灯[f]滚动[s]跳转[j]图文[a]加粗[b]noflag = ‘’ 同flag，但这里是表示不包含这些属性orderway=’desc’ 值为 desc 或 asc ，指定排序方式是降序还是顺向排序，默认为降序subday=’天数’ 表示在多少天以内的文档 用arclist调用于附加表字段的方法： 要获取附加表内容，必须符合两个条件1、指定 channelid 属性2、指定要获得的字段 addfields=’字段1,字段’如：{dede:arclist addfields=’filetype,language,softtype’ row=’8’ channelid=’3’}[field:textlink /] - [field:softtype /]{/dede:arclist} 底层模板字段：ID(同 id),typeid,sortrank,flag,ismake,channel,arcrank,click,money,title,shorttitle,color,writer,source,litpic(同picname),pubdate,senddate,mid, lastpost,scores,goodpost,badpost,notpost,description(同infos),filename, image, imglink, fulltitle, textlink, typelink,plusurl, memberurl, templeturl,stime(pubdate 的”0000-00-00”格式)其中：12345textlink = &lt;a href=&apos;arcurl&apos;&gt;title&lt;/a&gt;typelink = &lt;a href=&apos;typeurl&apos;&gt;typename&lt;/a&gt;imglink = &lt;a href=&apos;arcurl&apos;&gt;&lt;img src=&apos;picname&apos; border=&apos;0&apos; width=&apos;imgwidth&apos; height=&apos;imgheight&apos;&gt;&lt;/a&gt;image = &lt;img src=&apos;picname&apos; border=&apos;0&apos; width=&apos;imgwidth&apos; height=&apos;imgheight&apos; alt=’titile’&gt;字段调用方法：[field:varname/] 如：{dede:arclist infolen=’100’}[field:textlink/][field:infos/]{/dede:arclist}注：底层模板里的Field实现也是织梦标记的一种形式，因此支持使用PHP语法，Function扩展等功能。如： 给当天发布的内容加上 (new) 标志[field:senddate runphp=’yes’]$ntime = time();$oneday = 3600 * 24;if(($ntime - @me)&lt;$oneday) @me = “(new)“;else @me = “”;[/field:senddate]","categories":[],"tags":[{"name":"CMS","slug":"CMS","permalink":"http://yoursite.com/tags/CMS/"}]},{"title":"火锅鸡网项目总结","slug":"火锅鸡网项目总结","date":"2018-03-11T09:20:14.000Z","updated":"2018-10-19T10:10:25.440Z","comments":true,"path":"2018/03/11/火锅鸡网项目总结/","link":"","permalink":"http://yoursite.com/2018/03/11/火锅鸡网项目总结/","excerpt":"","text":"项目定位终于做完了!我做的是移动端，晓哥做的pc端，做的时候感觉移动端坑也好多，经理吩咐的细节部分老是忘记改，还好我从哥记忆力好，哈哈，这两天改了N次，又和设计稿对了无数遍，终于算是过了自己这关了，总结一下自己的这次的项目心得， 没听清楚需求一开始讲需求的时候没认真听，所以做完以后修改的时候比做的时间都多，所以下次一定要注意，用户需求才是项目的方向主导，了解了用户需求，清楚了项目的层级结构，才能高效的快速的完成工作，不要觉得前期规划很慢，其实前期吧项目规划的越清楚，后期做的时候就会越迅速， 一个页面两个Swiper的执行顺序问题又是swiper 没办法 一做移动端就想到了他，谁让他是移动端最好的轮播呢（00）这个问题主要出在我没搞清楚swiper 的函数就修改人家的代码，导致一个轮播浪费了很多的时间，最后还是自己写出的… JavaScript 基础中间用到一个返回的功能，想到了BOM，可是就是实现不了 ，果然百度是强大的，&lt;a class=&quot;fl clearfix&quot; href=&quot;javascript:history.back(-1)&quot;&gt;js调用浏览器的历史记录 无刷新返回 就是类似的浏览器历史记录 缺点是不能刷新 优点是 速度快 做了这么多项目后觉得自己的JavaScript有所提高了， 分享功能由于客户喜欢的分享功能比较奇葩，别人都是分享网页或网址，他想让分享APP，着急上火的我去找了百度、segmentfault、博客园、csdn，最终在我的大知乎上找到了一个，这是一个github的开源项目，感觉超级良心 ，技术点主要是JavaScript（又是我强大的js）调用手机系统的分享功能;自我觉得对于div+css越发越熟练，JavaScript也熟练了好多！！ 加油张宁乐！ 项目上线现在大家也可以点击火锅鸡网访问了！","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"生活感悟","slug":"生活感悟","permalink":"http://yoursite.com/tags/生活感悟/"}]},{"title":"小程序学习记录一","slug":"小程序学习记录一","date":"2018-02-22T06:20:14.000Z","updated":"2018-10-19T09:25:48.776Z","comments":true,"path":"2018/02/22/小程序学习记录一/","link":"","permalink":"http://yoursite.com/2018/02/22/小程序学习记录一/","excerpt":"","text":"最近很热门的小程序，一直想学着做一个，刚好前天在segmentfault看到了用个人做个校园的小程序，我就想自己也组偶一个试试，说动就动， 第一步先去微信公众平台注册成为开发者，期间需要自己的身份证号什么的要注意，提前准备好， 注册完之后需要填写小程序的的名字和介绍说明， 接下来需要在下载微信小程序开发者工具下载安装“微信web开发者工具”，他可以编写小程序代码，也可以进行微信公众号的排版和发布，使用是非常方便的，里面的调试功能和Chrome浏览器基本一样，学习过程中也一边查看的是微信小程序官方文档，一边试着打打代码，只要有点html+css基础的都能很快的学习小程序，小程序的整体构架安装好开发工具后，输入小程序ID即自动新建一个小程序demo文件，它自动创建的小程序文件就类似一个模板一样，可以省去很多初始化的东西，直接上手代码，每个小程序文件的结构都是由两个主要部分构成：主体部分 + 各个页面。类似于许多框架，主体部分主要用于核心的配置，各个页面在独自配置逻辑和样式。1.1，主体部分主要由3个文件构成1）app.js：小程序逻辑，2）app.json ：小程序配置，比如导航、窗口、页面http请求跳转等3）app.wxss：公共样式配置 小程序的开发也是遵守了MVC结构进行构建的 MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 1.2，页面由4个文件构成1）js：页面逻辑，相当于控制层（C）；也包括部分的数据（M）2）wxml：页面结构展示，相当于视图层（V）3）wxss：页面样式表，纯前端，用于辅助wxml展示4）json：页面配置，配置一些页面展示的数据，充当部分的模型（M）简单理解为.js后缀的文件是脚本文件，页面的交互等代码在这里实现；.json后缀的文件是配置文件，主要是json数据格式存放，用于设置程序的配置效果；.wxss后缀的是样式表文件，类似于前端中的css,用于对界面进行美化；.wxml后缀的文件是页面结构文件，用于构建页面，在页面上增加控件。最后放上一张结构图：","categories":[],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"}]},{"title":"移动端开发时遇到的一些坑","slug":"移动端开发时遇到的一些坑","date":"2018-02-19T00:32:07.000Z","updated":"2018-10-19T09:14:18.604Z","comments":true,"path":"2018/02/19/移动端开发时遇到的一些坑/","link":"","permalink":"http://yoursite.com/2018/02/19/移动端开发时遇到的一些坑/","excerpt":"","text":"起点中文网demo_移动端 做时遇到的bug一、移动端轮播1.touchstart 手指触摸 == mousedown2.touchend 手指抬起 == mouseup3.touchmove 手指抬起 == mousmovetouch事件 在 chrome的模拟器下，部分版本 通过on的方式来添加事件无效所以在移动端一般都使用如下方式addEventListener(“事件名”,函数,冒泡或捕获);12345678910111213document.addEventListener(&apos;touchstart&apos;,function(ev)&#123; ev.preventDefault();&#125;);var box=document.getElementById(&quot;box&quot;);box.addEventListener(&apos;touchstart&apos;,function()&#123; this.innerHTML=&apos;手指按下了&apos;;&#125;);box.addEventListener(&apos;touchmove&apos;,function()&#123; this.innerHTML=&apos;手指移动了&apos;;&#125;);box.addEventListener(&apos;touchend&apos;,function()&#123; this.innerHTML=&apos;手指离开了&apos;;&#125;); 参考前端网移动端事件demo http://ansonznl.coding.me/Mobile-demo/%E7%A7%BB%E5%8A%A8%E4%BA%8B%E4%BB%B601.html 二、滚动条scrollTop为滚动条在Y轴上的滚动距离。clientHeight为内容可视区域的高度。scrollHeight为内容可视区域的高度加上溢出（滚动）的距离。从这个三个属性的介绍就可以看出来，滚动条到底部的条件即为scrollTop + clientHeight == scrollHeight。废话不多少说，赶紧上代码（兼容不同的浏览器）。123456789101112131415161718192021222324252627282930313233343536373839//滚动条在Y轴上的滚动距离function getScrollTop()&#123; var scrollTop = 0, bodyScrollTop = 0, documentScrollTop = 0; if(document.body)&#123; bodyScrollTop = document.body.scrollTop; &#125; if(document.documentElement)&#123; documentScrollTop = document.documentElement.scrollTop; &#125; scrollTop = (bodyScrollTop - documentScrollTop &gt; 0) ? bodyScrollTop : documentScrollTop; return scrollTop;&#125;//文档的总高度function getScrollHeight()&#123; var scrollHeight = 0, bodyScrollHeight = 0, documentScrollHeight = 0; if(document.body)&#123; bodyScrollHeight = document.body.scrollHeight; &#125; if(document.documentElement)&#123; documentScrollHeight = document.documentElement.scrollHeight; &#125; scrollHeight = (bodyScrollHeight - documentScrollHeight &gt; 0) ? bodyScrollHeight : documentScrollHeight; return scrollHeight;&#125;//浏览器视口的高度function getWindowHeight()&#123; var windowHeight = 0; if(document.compatMode == &quot;CSS1Compat&quot;)&#123; windowHeight = document.documentElement.clientHeight; &#125;else&#123; windowHeight = document.body.clientHeight; &#125; return windowHeight;&#125;window.onscroll = function()&#123; if(getScrollTop() + getWindowHeight() == getScrollHeight())&#123; alert(&quot;you are in the bottom!&quot;); &#125;&#125;; 三、修改input 中placeholder字体颜色以前都不知道能修改，百度一下才知道是可以的123456789101112::-webkit-input-placeholder &#123; /* WebKit browsers */ color:#999; &#125; :-moz-placeholder &#123; /* Mozilla Firefox 4 to 18 */ color:#999; &#125; ::-moz-placeholder &#123; /* Mozilla Firefox 19+ */ color:#999; &#125; :-ms-input-placeholder &#123; /* Internet Explorer 10+ */ color:#999; &#125; 四、清除a、button的默认跳转比如说登录时，账号和密码不填时不能点登录，节省js判断，或者有时候不想让a标签跳转可以用到1234&lt;button disabled=&quot;disabled&quot; id=&quot;btn&quot;&gt;登录&lt;/button&gt;/* 添加disabled属性后不会提交数据 */&lt;a href=&quot;javascript:&quot; class=&quot;borlenone phb_nav&quot;&gt;风云榜&lt;/a&gt;/* 在a的href添加javascript:;属性后不会跳转 */ 做完了起点中文网的移动端后对移动网页的制作有加深一些，对于js的运用也熟练了许多，自己也封装了一个选项卡方法，，对于html、css的一些属性更了解了，总而言之收获恒很大。现在移动端浏览器兼容还是有点问题。加油，最后放上起点中文网demo 后续加：写大连罗森（移动端）的时候居然发现过了个年回来很多代码都生疏了，在写的过程中发现一些问题，在此记录下来以防在犯。 做的时候主要使用rem布局，rem用熟练了以后确实方便很多，做的时候也遇到过一些问题，在此记录一下。 一个页面插入多个swiper写的首页的时候，首页需要加两个轮播图，并且结构上不一样，我就引入了一个swiper。问题：在写首页的时候遇到了一个问题，就是点击一个轮播图的按钮时候，另一个也跟着动，思考：我就想，这肯定不行啊，然后晚上回去就开始研究，发现它其实就是class一样，所以调用的function一样，从而导致的2个轮播一起轮播，解决方案：给第一个轮播的按钮重新命名一个新的class，并且调用同一个function，完美解决！ img加宽高这个写完后台测试时才发现的问题，导致前期给后台大哥填了很多麻烦，还是给img标签加上高和宽比较好。这样的话，图片显示出来就会按照设定好的尺寸，不会出现意外情况。但如果没有设定，很有可能会出现图片上边有白条，或者没有按照想要的效果显示，网站更新是换图片会出现问题。我碰到的就是没有加宽高，造成了图片下沉，上面出现白条。网页中的img最好使用div包起来，或者把img的display属性设为block，可以消除img的默认边距记忆比较深刻的就是这么两个问题，最后放上演示地址（建议手机浏览）：http://zhangningle.gitee.io/m.luosen/","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"}]},{"title":"使用Gulp和学习Sass语法","slug":"使用Gulp和学习Sass语法","date":"2018-01-24T04:42:44.000Z","updated":"2018-12-21T08:23:05.672Z","comments":true,"path":"2018/01/24/使用Gulp和学习Sass语法/","link":"","permalink":"http://yoursite.com/2018/01/24/使用Gulp和学习Sass语法/","excerpt":"","text":"前要系统：win7、win10终端工具：cmd（或使用系统终端：win+R -&gt; 输入cmd -&gt; 回车）gulp官网地址：http://www.gulpjs.com.cn/gulp中文文档：http://www.gulpjs.com.cn/docs/gulp插件地址：http://gulpjs.com/pluginsgulpAPI地址：http://www.gulpjs.com.cn/docs/api/ 一、安装nodewindow下，下载node安装即可。node下载地址：http://nodejs.cn/download/安装比较简单，基本一直下一步即可，安装路径随意。为了确保Node已经正确安装，我们执行几个简单的命令。node -v回车（Enter），如果正确安装的话，你会看到所安装的Node的版本号，接下来看看npm。npm -v这同样能得到npm的版本号。如果这两行命令没有得到返回，可能node就没有安装正确，尝试重启下命令行工具，如果还不行的话，只能进行重装。 推荐使用cnpm 由于国外的网速不稳定 cnpm 比较好用注：cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm。后面的演示均使用cnpm安装cnpm执行npm install cnpm -g --registry=https://registry.npm.taobao.org2. 检测cnpm是否安装成功 输入cnpm -v返回版本号即成功 三、全局安装gulp全局安装gulp在cmd命令行中执行cnpm install gulp -g下载之后查看是否安装正确ulp -v 四、项目文件根目录新建package.json示例：进入 D:/WWW/test 项目文件夹中 执行命令cnpm init 查看项目文件根目录，是否新建package.json，且内容是否和你终端中输入的一致。 package.json内容如下:12345678910 &quot;name&quot;: &quot;test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;我是描述&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 五、本地安装gulp插件注：全局安装gulp是为了执行gulp任务，本地安装gulp则是为了调用gulp插件的功能进入你的项目文件路径中后，执行install gulp --save-dev ```123456789101112131415161718192021222324![](http://p0bnwspy9.bkt.clouddn.com/sass5a.jpg)## 六、新建gulpfile.jsgulpfile.js是gulp的配置文件，放于项目目录中。``` //gulpfile.js 示例文件//导入你所需要用的工具包 require(&apos;node_modules里对应模块&apos;)var gulp = require(&apos;gulp&apos;), sass = require(&apos;gulp-sass&apos;);// scss 任务gulp.task(&apos;sass&apos;,function()&#123; return gulp.src(&apos;src/css/test.scss&apos;) //获取该任务需要的文件 .pipe( sass() ) //该任务调用的模块 .pipe( gulp.dest(&apos;src/css&apos;) ); //将在 src/css 文件夹中生产test.css&#125;);// 默认任务gulp.task(&apos;default&apos;,[&apos;sass&apos;,&apos;watch1&apos;]);//监听文件gulp.task(&apos;watch1&apos;,function()&#123; return gulp.watch(&apos;src/css/test.scss&apos;,[&apos;sass&apos;]); //监听 src/css/test.scss 文件，修改时自动执行 sass 任务。&#125;); 七、运行gulp中的sass 执行gulp 调用default中的所有任务 如图：开启监听事件，当 src/css/test.scss 发生修改时，会自动执行sass任务。 sass的编译（gulp-sass）less编译 （gulp-less）重命名（gulp-rename）图片转换为base64-encoded （gulp-img64）自动添加css前缀（gulp-autoprefixer）压缩css（gulp-clean-css）js代码校验（gulp-jshint）合并js文件（gulp-concat）压缩js代码（gulp-uglify）压缩图片（gulp-imagemin）自动刷新页面（gulp-livereload，谷歌浏览器亲测，谷歌浏览器需安装livereload插件）图片缓存，只有图片替换了才压缩（gulp-cache）更改提醒（gulp-notify）阻止 gulp 插件发生错误导致进程退出并输出错误日志(gulp-plumber) 八、参考文件本文参考借鉴多篇文章 在 加上自己的实际测试后，写了这篇文章。如有不妥之处和疑问的地方，请留言赐教，谢谢。关于gulp的介绍，可参考官网：gulp官网地址：http://www.gulpjs.com.cn/gulp中文文档：http://www.gulpjs.com.cn/docs/gulp插件地址：http://gulpjs.com/pluginsgulpAPI地址：http://www.gulpjs.com.cn/docs/api/本文还参考了文章：http://www.cnblogs.com/2050/p/4198792.htmlhttp://www.ydcss.com/archives/18http://blog.csdn.net/qq_23215957/article/details/51050460等等…如侵权请联系删除。","categories":[],"tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"http://yoursite.com/tags/NodeJS/"},{"name":"Sass","slug":"Sass","permalink":"http://yoursite.com/tags/Sass/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Gulp","slug":"Gulp","permalink":"http://yoursite.com/tags/Gulp/"}]},{"title":"phpGD验证码二","slug":"phpGD验证码二","date":"2018-01-09T07:18:07.000Z","updated":"2018-06-10T08:40:30.478Z","comments":true,"path":"2018/01/09/phpGD验证码二/","link":"","permalink":"http://yoursite.com/2018/01/09/phpGD验证码二/","excerpt":"","text":"php做的验证码二把验证码添加到登录页面中，因为学了ajax，所以我直接用ajax做的登录验证码的刷新1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;登录验证&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;action.php&quot; method=&quot;post&quot;&gt; 用户名：&lt;input name=&quot;username&quot; id=&quot;username&quot;&gt;&lt;br&gt; 密&amp;nbsp;码：&lt;input name=&quot;password&quot; id=&quot;password&quot;&gt;&lt;br&gt; &lt;img id=&quot;ImgSrc&quot; src=&quot;VerificationCode.php&quot; alt=&quot;&quot;&gt; &lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;getCode()&quot;&gt;看不清&lt;/a&gt; &lt;br&gt; 验证码：&lt;input name=&quot;code&quot; id=&quot;code&quot; onkeyup=&quot;checkCode()&quot;&gt; &lt;br&gt; &lt;div id=&quot;codeSpan&quot;&gt;&lt;/div&gt; &lt;br&gt; &lt;button type=&quot;button&quot; onclick=&quot;checkForm()&quot;&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;script&gt; //验证用户密码 function checkForm() &#123; //判断用户名密码是否为空 判断是否符合验证 var username=document.querySelector(&quot;#username&quot;); var password=document.querySelector(&quot;#password&quot;); var form=document.querySelector(&quot;form&quot;); if(username.value!==&quot;&quot;&amp;&amp;password.value!==&quot;&quot;)&#123; form.submit(); return true; &#125;else &#123; alert(&quot;用户名为空&quot;); return false &#125; &#125; //切换验证码 function getCode() &#123; imgSrc=document.getElementById(&quot;ImgSrc&quot;); imgSrc.src=&quot;VerificationCode.php&quot;; var codeSpan=document.getElementById(&quot;codeSpan&quot;); var code=document.getElementById(&quot;code&quot;); code.value=&apos;&apos;; codeSpan.innerHTML=&apos;&apos;; &#125; //验证验证码 function checkCode() &#123; var code=document.querySelector(&quot;#code&quot;); var xmlhttp; if (window.XMLHttpRequest)&#123; xmlhttp=new XMLHttpRequest(); &#125;else&#123; xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; xmlhttp.onreadystatechange=function () &#123; if (xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200)&#123; var codeSpan=document.querySelector(&quot;#codeSpan&quot;); codeSpan.innerHTML = xmlhttp.responseText; &#125; &#125;; xmlhttp.open(&quot;POST&quot;,&quot;action.php&quot;,true); // xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;appliction/x-www-form-urlencoded&quot;); xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&quot;code=&quot;+code.value); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 最后输出的是： 输出后如图： 封装验证码把自己的写的一个验证码封装起来，下次方便重复的利用，也顺便复习一下面向对象的思维12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485header(&quot;Content-Type: text/html;charset=utf-8&quot;);class VerificarionCode&#123; public $width; public $height; public $image; function __construct($widths,$heights) &#123; //新建画布 $this-&gt;image=imagecreatetruecolor($widths,$heights); &#125; function imageColor($widths,$heights,$red,$green,$blue)&#123; //新建矩形白色 $color=imagecolorallocate($this-&gt;image,$red,$green,$blue); //填充一下 imagefilledrectangle($this-&gt;image,0,0,$widths,$heights,$color); &#125; function getRandColor($image)&#123; //随机颜色 return imagecolorallocate($image,mt_rand(0,255),mt_rand(0,255),mt_rand(0,255)); &#125; function str($widths,$heights,$lengths)&#123; //快速创建字符串 $string=&apos;asadf132&apos; array_merge 合并成一个数组 join字符串链接数组中的值 赋给string $string=join(&apos;&apos;,array_merge(range(0,9),range(&apos;a&apos;,&apos;z&apos;),range(&apos;A&apos;,&apos;Z&apos;))); //echo $string; //得到字体宽度 $textWidth=imagefontwidth(28); //得到字体高度 $textHeight=imagefontheight(28); $length=$lengths; $strZ=&apos;&apos;; for($i=0;$i&lt;$length;$i++)&#123; //随机每一位颜色 // $randColor=imagecolorallocate($image,mt_rand(0,255),mt_rand(0,255),mt_rand(0,255)); $randColor=imagecolorallocate($this-&gt;image,mt_rand(0,255),mt_rand(0,255),mt_rand(0,255)); $size=mt_rand(19,22); $angle=mt_rand(-15,15); // $x=20+40*$i; // $y=30; $x=($widths/$length)*$i+$textWidth; $y=mt_rand($heights/2,$heights-$textHeight); $fontFile=&apos;font/FZLTCXHJW.TTF&apos;; //打乱string这个字符串 然后随机取第一个字符串[0] $text=str_shuffle($string)[0]; $strZ=$strZ.$text; imagettftext($this-&gt;image,$size,$angle,$x,$y,$randColor,$fontFile,$text); &#125; &#125; function Etpixel($widths,$heights,$EtpNum)&#123; //添加点，像素做干扰元素 for($i=1;$i&lt;=$EtpNum;$i++)&#123; //绘制像素 $randColor=imagecolorallocate($this-&gt;image,mt_rand(0,255),mt_rand(0,255),mt_rand(0,255)); imagesetpixel($this-&gt;image,mt_rand(0,$widths),mt_rand(0,$heights),$randColor); &#125; &#125; function line($widths,$heights,$LineNum)&#123; //添加线段干扰 for($i=1;$i&lt;=$LineNum;$i++)&#123; //绘制线段 imageline($this-&gt;image,mt_rand(0,$widths),mt_rand(0,$heights),mt_rand(0,$widths),mt_rand(0,$heights), $randColor=imagecolorallocate($this-&gt;image,mt_rand(0,255),mt_rand(0,255),mt_rand(0,255)));// 起始位置 结束位置 &#125; &#125; function imagepng()&#123; //告诉浏览器以图像形式显示png header(&apos;content-type:image/png&apos;); //输出图像 imagepng($this-&gt;image); //销毁资源 imagedestroy($this-&gt;image); &#125;&#125;$demo1 =new VerificarionCode(180,60);//画布$demo1-&gt;imageColor(180,60,255,255,255);//图像的数字$demo1-&gt;str(180,60,4);//干扰点$demo1-&gt;Etpixel(180,60,60);//干扰线段$demo1-&gt;line(180,60,3);//png输出$demo1-&gt;imagepng();","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"phpGD验证码","slug":"phpGD验证码一","date":"2018-01-09T06:32:07.000Z","updated":"2018-10-19T08:36:04.300Z","comments":true,"path":"2018/01/09/phpGD验证码一/","link":"","permalink":"http://yoursite.com/2018/01/09/phpGD验证码一/","excerpt":"","text":"php做的验证码php的GD函数php的GD函数可以使文字字符串转换成图片输出在网页上，话不多说直接放码，1234567891011121314151617181920&lt;?php$width=300;$height=80;$images=imagecreatetruecolor($width,$height);//创建一个画布$red=imagecolorallocate($images,255,0,0);$blue=imagecolorallocate($images,0,0,255);$white=imagecolorallocate($images,255,255,255);//创建颜色imagestring($images,5,70,30,&quot;hello world&quot;,$red);//绘制字符header(&quot;content-type:image/jpeg&quot;);//告诉浏览器怎么输出imagejpeg($images);//保存图像imagejpeg($images,&quot;images/1.jpg&quot;);//输出图像imagedestroy($images);//销毁资源?&gt; 最后输出的是： 为验证码增加识别难度（干扰元素）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 * 制作6位的数字+字母的验证码 * *///创建宽高$width=200;$height=40;//新建画布$image=imagecreatetruecolor($width,$height);//新建矩形白色$white=imagecolorallocate($image,255,255,255);//填充一下imagefilledrectangle($image,0,0,$width,$height,$white);//封装颜色function getRandColor($image)&#123;//随机颜色 return imagecolorallocate($image,mt_rand(0,255),mt_rand(0,255),mt_rand(0,255));&#125;//快速创建字符串 $string=&apos;asadf132&apos; array_merge 合并成一个数组 join字符串链接数组中的值 赋给string$string=join(&apos;&apos;,array_merge(range(0,9),range(&apos;a&apos;,&apos;z&apos;),range(&apos;A&apos;,&apos;Z&apos;)));//echo $string;//得到字体宽度$textWidth=imagefontwidth(28);//得到字体高度$textHeight=imagefontheight(28);$length=4;$strZ=&apos;&apos;;for($i=0;$i&lt;$length;$i++)&#123; //随机每一位颜色// $randColor=imagecolorallocate($image,mt_rand(0,255),mt_rand(0,255),mt_rand(0,255)); $randColor=getRandColor($image); $size=mt_rand(15,22); $angle=mt_rand(-15,15);// $x=20+40*$i;// $y=30; $x=($width/$length)*$i+$textWidth; $y=mt_rand($height/2,$height-$textHeight); $fontFile=&apos;font/FZLTCXHJW.TTF&apos;; //打乱string这个字符串 然后随机取第一个字符串[0] $text=str_shuffle($string)[0]; $strZ=$strZ.$text; imagettftext($image,$size,$angle,$x,$y,$randColor,$fontFile,$text);&#125;//session_start();$_SESSION[&quot;code&quot;]=$strZ;//添加干扰元素//添加点，像素做干扰元素for($i=1;$i&lt;=50;$i++)&#123; //绘制像素 imagesetpixel($image,mt_rand(0,$width),mt_rand(0,$height),getRandColor($image));&#125;//添加线段干扰for($i=1;$i&lt;=2;$i++)&#123; //绘制线段 imageline($image,mt_rand(0,$width),mt_rand(0,$height),mt_rand(0,$width),mt_rand(0,$height),getRandColor($image));// 起始位置 结束位置&#125;//绘制圆弧干扰for($i=1;$i&lt;=1;$i++)&#123; //绘制圆弧 imagearc($image,mt_rand(0,$width),mt_rand(0,$height),mt_rand(0,$width/2),mt_rand(0,$height/2),mt_rand(0,360),mt_rand(0,360),getRandColor($image));&#125;//告诉浏览器以图像形式显示header(&apos;content-type:image/png&apos;);//输出图像imagepng($image);//销毁资源imagedestroy($image); 输出后如图： 绘制像素 imagesetpixel(); 绘制线段 imageline() 绘制圆弧 imagearc() 取得字体宽度 imagefontwidth() 取得字体高度 imagefontheight()","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"添加账户SSH （免密码上传）","slug":"设置账户SSH","date":"2018-01-06T02:09:45.000Z","updated":"2018-10-19T09:04:58.119Z","comments":true,"path":"2018/01/06/设置账户SSH/","link":"","permalink":"http://yoursite.com/2018/01/06/设置账户SSH/","excerpt":"","text":"SSH以前没有添加SSH时，每次上传博文都要输入一次账户和密码，异常麻烦，这次我吧博客部署了三个git托管的主流平台（Guthub/Coding/码云）那可是要输三次账户名和密码的，为了方便节省时间就在网上找了找关于ssh教程，奈何都不是很全面，遇见不少坑，今天自己爬完坑自己记录一下，下次万一用到还可以翻出来看看， 参考 配置SHH配置shh key是让本地git项目与远程的github建立联系 检查是否已经有SSH Key，打开Git Bash，输入&lt;code class=&quot;hljs bash&quot;&gt;cd ~/.ssh&lt;/code&gt;如果没有.ssh这个目录，则生成一个新的SSH，输入&lt;code class=&quot;hljs lasso&quot;&gt;ssh-keygen -t rsa -C &quot;your e-mail&quot;&lt;/code&gt;注意1: 此处的邮箱地址，你可以输入自己的邮箱地址；注意2: 此处的「-C」的是大写的「C」 接下来几步都直接按回车键,然后系统会要你输入密码&lt;code class=&quot;hljs ruby&quot;&gt;Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt;&lt;/code&gt;这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。注意：输入密码的时候没有*字样的，你直接输入就可以了。 最后看到这样的界面，就成功设置ssh key了 kl 添加 SSH Key 到 GitHub和Coding打开Git Bash，然后输入cd ~/.ssh进入到.shh文件夹中再输入ls，查看是否有id_rsa.pub文件 输入cat命令，打开id_rsa.pub文件cat id_rsa.pub 再鼠标全选中右击复制 再配置到GitHub和Coding的SSH中进入Github官网，点击+旁边的头像，再按settings进入设置 在点击New SSH key创建 title输入邮箱，key里面粘贴刚才右击复制的内容,再点Add SSH key","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"移动端页面开发关键—尺寸和布局","slug":"移动端页面开发关键—尺寸和布局","date":"2017-12-29T11:06:01.000Z","updated":"2018-10-19T09:59:50.993Z","comments":true,"path":"2017/12/29/移动端页面开发关键—尺寸和布局/","link":"","permalink":"http://yoursite.com/2017/12/29/移动端页面开发关键—尺寸和布局/","excerpt":"","text":"尺寸在移动端页面，我用到的尺寸单位有em、rem、vw、px基本不用，但我会设置Dom根元素html字体大小为14px，一来方便em和rem的尺寸计算，二来14px是最常用的字体大小。 常规浏览器默认字体大小为16px，最小字体为12px。 em首先你要有这样一个基础的认知： 假如一个元素没有重设字体大小，那么它的字体大小会继承父级元素，如果父级也没有设置大小，那么依次类推一直追溯到body、html。 em是相对于当前元素字体大小计算像素值的，计算方法是em值 * 字体大小。 举例：一个元素设置了高度为2em，那么实际像素值为2 * 14px = 28px，而一旦这个元素重设了字体大小为2em，那么该元素高度值为2 * 28px = 56px。另外，其后的子元素的计算基数都会改变。 使用em时一旦有设置字体大小的样式出现就需要注意重新计算一些属性值大小了。 rem与 em 相比，这货看起来多了一个字母，显然是属于升级版本。rem是始终相对与 Dom 根元素html来计算像素值的。不管当前元素字体如何设置，计算时字体大小仍然以html的字体设置为基准。 vwvw指的的当前屏幕宽度，与之对应的还有 vh，表示屏幕高度。如果屏幕宽为 360px，那么 100vw = 360px。 是否感觉并没有什么卵用？别着急，下面说一下我的一次适用经历。12345678910111213141516171819202122html：&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;div class=&quot;cont cont-1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;cont cont-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;cont cont-3&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;div&gt;css：.box &#123; width: 100%; overflow: hidden;&#125;.inner &#123; width: 300%;&#125;.cont &#123; float: left; width: 100%;&#125; 以上代码用以实现三屏的左右切换效果，外层容器.box和三个内容块宽度为屏幕宽度，三个内容块设置了左浮动样式。此时，内层容器.inner需要有3倍的屏幕宽度以承载三个内容块。但是由于宽度继承的关系，在内层容器.inner宽度改变后，内容块的宽度计算基数也改变了。此时设置的100%是等于父级元素宽度的，也就是三倍屏宽。 使用js是很容易解决这个问题的，不过vw显然是可以适用这个场景的。只需要如下设置便可解决问题。 .cont { width: 100vw; }该属性在兼容性为android 4.4+，谨慎使用。 devicePixelRatio在一个图表页中，我用canvas画了个饼图。发现在手机屏幕中区块颜色显得模糊。于是搜索资料就找到了这个属性，window.devicePixelRatio。目前我对这个属性的理解还不深，基本的理解为：屏幕缩放比。传送门：张鑫旭：设备像素比devicePixelRatio简单介绍 我们通过写的css中像素仅为逻辑像素，就是你看到的宽度，而实际上手机屏幕单个点是可能存在多个像素的。 如果是常规页面元素是用不到这个属性的，而canvas的真实宽度和css宽度是不一致的。计算方法为：canvas.width = canvas.style.width * devicePixelRatio。 需要注意：一旦重设了canvas的真实宽度，那么canvas之上的一切元素都需要乘以devicePixelRatio进行缩放。 布局在PC上为了兼容可恶的IE不得不使用大量的浮动来进行块级元素的并行排行。而在移动端我们有了更好的选择，但不是inline-block，而是flex。 使用flex可以轻易的实现等宽、散列、垂直居中、多行排列、底部对齐等等各种布局。 定义一个flex容器123.flex-row &#123; display: flex;&#125; 通过设置容器属性，可以呈现不同的排列对齐方式。 flex-wrap定义容器换行方式，默认不换行。可设置换行和反向换行。 flex-direction排列方向，默认子元素从左到右顺序排列。通过设置该值可以实现反向排列或垂直方向的上下排列。 justify-content主轴（水平方向）对齐方式，默认左对齐。可以实现居中、右对齐、等宽间隔等排列。 align-items侧轴（垂直）对齐方式。可实现垂直居中、底部对齐、基线对齐等。 align-content多轴垂直对齐方式。 最后附上Demo：flex常用布局:https://imys.net/demo/flex.html 参考： 大漠：Flexbox——快速布局神器阮一峰：Flex 布局教程：语法篇阮一峰：Flex 布局教程：实例篇","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"js判断浏览设备","slug":"js判断pc端和移动端","date":"2017-12-26T11:02:25.000Z","updated":"2018-10-19T09:06:13.208Z","comments":true,"path":"2017/12/26/js判断pc端和移动端/","link":"","permalink":"http://yoursite.com/2017/12/26/js判断pc端和移动端/","excerpt":"","text":"js判断浏览设备在移动端火热的web界，估计现在开发网站都会开发pc端和移动端吧？可是用户访问网站时怎么确定是访问网站刚刚好就是用户使用设备所匹配网站呢？我最近就打算做一个网站pc端+移动端的。刚好遇见这个问题就此记下来：很简单！还是使用万能的js来解决这个问题,一段代码搞定！12345&lt;script&gt;if(navigator.userAgent.match(/(iPhone|iPod|Android|ios)/i))&#123; window.location.href=&apos;移动端网址&apos;;&#125;&lt;/script&gt; 当然网上流传的方法不止一种，适合自己的才是最好的。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"使用Ajax请求数据","slug":"使用Ajax请求数据","date":"2017-12-26T01:04:54.000Z","updated":"2018-10-19T08:40:26.479Z","comments":true,"path":"2017/12/26/使用Ajax请求数据/","link":"","permalink":"http://yoursite.com/2017/12/26/使用Ajax请求数据/","excerpt":"","text":"ajax的简单使用接触php和Mysql后就一直想学ajax,今天终于开始尝试了写一个小的ajax实现页面的局部刷新了。 什么是ajax？ AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。AJAX = 异步 JavaScript 和 XML。AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等。ajax 是异步更新，使用太多比较频繁的请求会增加服务器的负担，ajax的无刷新技术，无需用户等待即可更新局部页面，增加用户体验。 实现思路因为ajax是与后台数据进行数据传输交互等等，所以需要启动服务器构建php+mysql环境。在服务器可访问到的文件夹下新建一个ajax文件。文件一：index.html用户浏览的页面文件二：action.php保存数据的的页面，（只是一个简单的ajax案例，暂时不连接数据库）首先在页面写一个按钮：index.html中的内容是：1234&lt;button onclick=&quot;getData()&quot;&gt;我漂亮吗？&lt;/button&gt;//一个简单的按钮 点击触发‘getData()’事件&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;//点击在‘box中按钮出来的文字， index.html中要添加js代码：12345678910111213141516171819202122232425function getData() &#123; var xmlhttp; if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); //兼容最新浏览器IE7+, Firefox, Chrome, Opera, Safari &#125; else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); //兼容老版本的 &#125; xmlhttp.open(&quot;GET&quot;,&quot;action.php&quot;,true); // 传参方式 发送的文件 是否异步true（异步）或 false（同步） xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(&quot;flag=select&amp;name=zhang&quot;); // 发送 传递参数 xmlhttp.onreadystatechange=function () &#123; if(xmlhttp.readyState==4&amp;&amp;xmlhttp.status==200)&#123; console.log(xmlhttp.responseText); document.getElementById(&quot;box&quot;).innerHTML=xmlhttp.responseText; // var data1=JSON. &#125; &#125; &#125; 在action.php中写点击后要返回的数据：123if(isset($_POST[&quot;flag&quot;]))&#123; echo &quot;漂亮&quot;;&#125; 好啦！这样在后台打开就可以直接出来了，点击按钮‘我漂亮吗？’，下方就会立即出来”漂亮”，是不是特别棒呢！可以增加用户体验呢。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"},{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"Mysql常用命令","slug":"Mysql笔记一","date":"2017-12-19T12:10:20.000Z","updated":"2018-10-19T09:31:48.694Z","comments":true,"path":"2017/12/19/Mysql笔记一/","link":"","permalink":"http://yoursite.com/2017/12/19/Mysql笔记一/","excerpt":"","text":"创建一个mysql表输入命令 连接mysql 数据库winpty mysql -uroot -p 建数据库语句create database name//创建 数据库 数据库名字 使用数据库use name//使用数据库 名字 创建表语句create table name (id int auto_increment,name varchar(15),age int,sex char(2),primary key(id))// 名称 id 类型 自增 名字 可变的最多15 主键数据唯一标示 删除表drop table name 修改表增加列alter table name add place varchar(20)删除列alter table name drop place 向数据表中插入数据insert into name(name,age,sex) values(&quot;zhang&quot;,&quot;10&quot;,&quot;male&quot;) 删除数据表中的数据delete from name where name=&quot;zhang&quot; 修改表中的数据update name set name=&quot;www&quot; where name=&quot;zhang&quot; 查询数据表中的数据select * from name","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"php笔记之oop笔记一","slug":"php笔记之oop笔记一","date":"2017-12-18T11:42:02.000Z","updated":"2017-12-18T11:37:51.184Z","comments":true,"path":"2017/12/18/php笔记之oop笔记一/","link":"","permalink":"http://yoursite.com/2017/12/18/php笔记之oop笔记一/","excerpt":"","text":"php-oop(面向对象编程)oop的特点 php面向对象编程的特点：封装性、继承性、多态性 面向对象编程的优势：代码功能更加清晰，数据处理，用户登陆，内容呈现等各写成一个类，在页面中只需包含这些类、实例化对象，然后再用简洁的语句应用对象就行 类与对象关系：类就像一个人类的群体 我们从类中实例化一个对象 就像是制定一个人。面向对象程序的单位就是对象，但对象又是通过类的实例化出来的，所以我们首先要做的就是如何来声明类， 做出来一个类很容易。类是一个抽象的概念,具有相同属性（特征）和方法（行为）的一系列个体的集合.类的格式：class 类名 { }类可以理解为一个人的群体，如果我们要把这个人介绍给别人 那么 首先， 你会介绍这个人姓名、性别、年龄、身高、体重、电话、家庭住址等等。 然后，你要介绍这个人能做什么， 可以开车， 会说英语， 可以使用电脑等等。 从定义的角度可以分为： 1.静态的描述 如：人的姓名、性别、年龄、身高、体重、电话、家庭住址等等 我们将静态的描述称为成员属性 2.动态描述 如：这个人可以开车， 会说英语， 可以使用电脑等等 我们将动态的描述称为成员方法 12345 class 人&#123; 成员属性：姓名、性别、年龄、身高、体重、电话、家庭住址 成员方法：可以开车， 会说英语， 可以使用电脑&#125; 一个类的基本构成包括属性和方法，比如我们创建一个Animal类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Animal&#123; public $name; // 全局 protected $money; //受保护的 private $count; //私有的 static $num=10; //静态属性 直接用类名调用静态属性 静态属性和静态方法属于类 普通方法也能用静态属性 static function asyNum()&#123; //静态方法静 态方法中只能用静态属性 echo &quot;&lt;br&gt;调用静态方法中的num是&quot;.self::$num; // 静态方法中只能用静态属性 self 引用静态属性$num &#125; function __construct($name1) // 在构造函数里传参数 &#123; $this-&gt;name=$name1;// 初始值 &#125; function sayName()&#123; echo &quot;&lt;br&gt;他的名字是&quot;.$this-&gt;name;// 当前函数的 &#125;// 析构函数 是当对象执行完毕后会销毁对象然后执行析构函数， 析构函数销毁的是new 后的对象 然不是类 function __destruct() &#123; // TODO: Implement __destruct() method. echo &quot;&lt;br&gt;对象执行完毕.对象已销毁。只销毁对象不销毁class&quot;; &#125;&#125;$lis=new Animal(&quot;小白&quot;);/// 传参$lis-&gt;sayName();echo &quot;&lt;br&gt;静态属性&quot;.Animal::$num;echo Animal::asyNum();class Cat extends Animal&#123;// 继承非私有的属性和方法// 方法重写function sayName()&#123; parent::sayName(); //调用父类的方法 方法重写 echo &quot;&lt;br&gt;子类的方法&quot;; echo &quot;&lt;br&gt;调用父类的静态&quot;.parent::$num;&#125;&#125;$cat=new Cat(&quot;123&quot;);$cat-&gt;sayName(); public 表示全局，类内部外部子类都可以访问；private表示私有的，只有本类内部可以使用；protected表示受保护的，只有本类或子类或父类中可以访问；12345678910111213141516171819202122232425262728293031323334&lt;? //父类 class father&#123; public function a()&#123; echo &quot;function a&quot;; &#125; private function b()&#123; echo &quot;function b&quot;; &#125; protected function c()&#123; echo &quot;function c&quot;; &#125; &#125; //子类 class child extends father&#123; function d()&#123; parent::a();//调用父类的a方法 &#125; function e()&#123; parent::c(); //调用父类的c方法 &#125; function f()&#123; parent::b(); //调用父类的b方法 &#125; &#125; $father=new father(); $father-&gt;a(); $father-&gt;b(); //显示错误 外部无法调用私有的方法 Call to protected method father::b() $father-&gt;c(); //显示错误 外部无法调用受保护的方法Call to private method father::c() $chlid=new child(); $chlid-&gt;d(); $chlid-&gt;e(); $chlid-&gt;f();//显示错误 无法调用父类private的方法 Call to private method father::b() ?&gt; 静态属性的 用法：子类调用父类的静态属性 加parent：：在自己内部的静态方法中调用自己的的静态属性 加self：：","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"Swiper笔记一","slug":"Swiper笔记一","date":"2017-12-18T01:55:20.000Z","updated":"2017-12-18T12:11:31.392Z","comments":true,"path":"2017/12/18/Swiper笔记一/","link":"","permalink":"http://yoursite.com/2017/12/18/Swiper笔记一/","excerpt":"","text":"Swiper常用于移动端动画Swiper是纯javascript打造的滑动特效插件，面向手机、平板电脑等移动终端。 Swiper能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。Swiper开源、免费、稳定、使用简单、功能强大，是架构移动终端网站的重要选择！Swiper个人理解为是封装很好的css3动画的库，有这非常强大简单易用的API任何一个web开发者都简单上手的一个移动端动画库，我也使用它两天内做了一个小小的demo；项目地址邀请函(建议手机模式下观看)完全自己动手码的，仿的是兔展上一个一模一样的，那个卖39软妹币呢，嘻嘻。。我免费做哦，","categories":[],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"},{"name":"Swiper","slug":"Swiper","permalink":"http://yoursite.com/tags/Swiper/"}]},{"title":"php笔记三","slug":"PHP笔记三","date":"2017-12-13T11:01:20.000Z","updated":"2017-12-17T08:39:26.788Z","comments":true,"path":"2017/12/13/PHP笔记三/","link":"","permalink":"http://yoursite.com/2017/12/13/PHP笔记三/","excerpt":"","text":"cookie和session 的关系和用法具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。 cookiecookie 常用于识别用户。cookie 是服务器留在用户计算机中的小文件。每当相同的计算机通过浏览器请求页面时，它同时会发送 cookie。通过 PHP，您能够创建并取回 cookie 的值。新建一个cookie：12setcookie(name, value, expire, path, domain);// 名字 键值 过期时间 路径 域名 PHP 的 $_COOKIE 变量用于取回 cookie 的值。在下面的例子中，我们取回了名为 “user” 的 cookie 的值，并把它显示在了页面上：1234567&lt;?php// Print a cookieecho $_COOKIE[&quot;user&quot;];// A way to view all cookiesprint_r($_COOKIE);?&gt; 在下面的例子中，我们使用 isset() 函数来确认是否已设置了 cookie：123456789101112&lt;html&gt;&lt;body&gt;&lt;?phpif (isset($_COOKIE[&quot;user&quot;])) echo &quot;Welcome &quot; . $_COOKIE[&quot;user&quot;] . &quot;!&lt;br /&gt;&quot;;else echo &quot;Welcome guest!&lt;br /&gt;&quot;;?&gt;&lt;/body&gt;&lt;/html&gt; cookie中键值只能为字符串 序列化serialize($); 成字符串 反序列化unserialize($); 成数组 如何删除 cookie？当删除 cookie 时，您应当使过期日期变更为过去的时间点。删除的例子：1234&lt;?php // set the expiration date to one hour agosetcookie(&quot;user&quot;, &quot;&quot;, time()-3600);?&gt; sessionPHP session 变量用于存储有关用户会话的信息，或更改用户会话的设置。Session 变量保存的信息是单一用户的，并且可供应用程序中的所有页面使用。PHP Session 变量当您运行一个应用程序时，您会打开它，做些更改，然后关闭它。这很像一次会话。计算机清楚你是谁。它知道你何时启动应用程序，并在何时终止。但是在因特网上，存在一个问题：服务器不知道你是谁以及你做什么，这是由于 HTTP 地址不能维持状态。通过在服务器上存储用户信息以便随后使用，PHP session 解决了这个问题（比如用户名称、购买商品等）。不过，会话信息是临时的，在用户离开网站后将被删除。如果您需要永久储存信息，可以把数据存储在数据库中。Session 的工作机制是：为每个访问者创建一个唯一的 id (UID)，并基于这个 UID 来存储变量。UID 存储在 cookie 中，亦或通过 URL 进行传导。开始使用session前，首先要开启session：在页面最开始时加上session_start();存储 Session 变量存储和取回 session 变量的正确方法是使用 PHP $_SESSION 变量：12345678910111213141516&lt;?phpsession_start();// store session data$_SESSION[&apos;views&apos;]=1;?&gt;&lt;html&gt;&lt;body&gt;&lt;?php//retrieve session dataecho &quot;Pageviews=&quot;. $_SESSION[&apos;views&apos;];?&gt;//输出 Pageviews=1&lt;/body&gt;&lt;/html&gt; session的垃圾回收机制找到服务器里的配置文件php-ini1234567//修改 session.auto 0（手动启动）1（自动启动）修改后保存重启服务器查看session的保存地址 session.savesession.gc_probability=1session.gc_divisor=1000//他有1/1000分支以的被回收session。gc_maxlifetime=1400//最大过期时间 不同浏览器访问一个网站 会产生不同的session文件 如果有则找到session文件 没有则创建一个新的session文件","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"php笔记二","slug":"PHP笔记二","date":"2017-12-08T00:34:03.000Z","updated":"2017-12-17T08:39:21.490Z","comments":true,"path":"2017/12/08/PHP笔记二/","link":"","permalink":"http://yoursite.com/2017/12/08/PHP笔记二/","excerpt":"","text":"PHP 全局变量 - 超全局变量PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。在函数或方法中无需执行 global $variable; 就可以访问它们。 超全局变量：123456789$GLOBALS$_SERVER$_REQUEST$_POST$_GET$_FILES$_ENV$_COOKIE$_SESSION $GLOBALS[‘var’] ：$GLOBALS[‘var’] 是外部的全局变量$var本身。123456$v=500;function g()&#123; $GLOBALS[&quot;c&quot;]=$GLOBALS[&quot;v&quot;]+$GLOBALS[&quot;v&quot;]; echo $GLOBALS[&quot;c&quot;];&#125;g();//1000 $_SERVER: $_SERVER超级全局变量包含由web服务器创建的信息，它提供了服务器和客户配置及当前请求环境的有关信息。根据服务器不同，$_SERVER中的变量值和变量个数会有差别， 不过一般都可以找到CGI1.1规范中定义的变量以下结果默认在1http://localhost/aaa/index.php?p=222&amp;q=333 下执行结果：12345678910$_SERVER[&apos;QUERY_STRING&apos;] = &quot;p=222&amp;q=333&quot;;$_SERVER[&apos;REQUEST_URI&apos;] = &quot;/aaa/index.php?p=222&amp;q=333&quot;;$_SERVER[&apos;SCRIPT_NAME&apos;] = &quot;/aaa/index.php&quot;;$_SERVER[&apos;PHP_SELF&apos;] = &quot;/aaa/index.php&quot;;由实例可知：$_SERVER[&quot;QUERY_STRING&quot;] 获取查询 语句，实例中可知，获取的是?后面的值$_SERVER[&quot;REQUEST_URI&quot;] 获取 http://localhost 后面的值，包括/$_SERVER[&quot;SCRIPT_NAME&quot;] 获取当前脚本的路径，如：index.php$_SERVER[&quot;PHP_SELF&quot;] 当前正在执行脚本的文件名 //http://www.runoob.com/php/php-post.html 参考界面 $_GET:预定义的 $_GET 变量用于收集来自 method=”get” 的表单中的值。从带有 GET 方法的表单发送的信息，对任何人都是可见的（会显示在浏览器的地址栏），并且对发送信息的量也有限制。form.html 文件代码如下：123456789101112131415&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;welcome.php&quot; method=&quot;get&quot;&gt;名字: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;年龄: &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 当用户点击 “Submit” 按钮时，发送到服务器的 URL 如下所示：1http://www.runoob.com/welcome.php?fname=Runoob&amp;amp;age=3 “welcome.php” 文件现在可以通过 $_GET 变量来收集表单数据了（请注意，表单域的名称会自动成为 $_GET 数组中的键）：12欢迎 &lt;?php echo $_GET[&quot;fname&quot;]; ?&gt;!&lt;br&gt;你的年龄是 &lt;?php echo $_GET[&quot;age&quot;]; ?&gt; 岁。 如图： 何时使用 method=”get”？ 在 HTML 表单中使用 method=”get” 时，所有的变量名和值都会显示在 URL 中。 注释：所以在发送密码或其他敏感信息时，不应该使用这个方法！ 然而，正因为变量显示在 URL 中，因此可以在收藏夹中收藏该页面。在某些情况下，这是很有用的。 注释：HTTP GET 方法不适合大型的变量值。它的值是不能超过 2000 个字符的。 $_POST ：预定义的 $_POST 变量用于收集来自 method=”post” 的表单中的值。从带有 POST 方法的表单发送的信息，对任何人都是不可见的（不会显示在浏览器的地址栏），并且对发送信息的量也没有限制。注释：然而，默认情况下，POST 方法的发送信息的量最大值为 8 MB（可通过设置 php.ini 文件中的 post_max_size 进行更改）。form.html 文件代码如下：123456789101112131415&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;welcome.php&quot; method=&quot;post&quot;&gt;名字: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;年龄: &lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 当用户点击 “提交” 按钮时，URL 类似如下所示：1http://www.runoob.com/welcome.php “welcome.php” 文件现在可以通过 $_POST 变量来收集表单数据了（请注意，表单域的名称会自动成为 $_POST 数组中的键）：12欢迎 &lt;?php echo $_POST[&quot;fname&quot;]; ?&gt;!&lt;br&gt;你的年龄是 &lt;?php echo $_POST[&quot;age&quot;]; ?&gt; 岁。 如图： 何时使用 method=”post”？ 从带有 POST 方法的表单发送的信息，对任何人都是不可见的，并且对发送信息的量也没有限制。 然而，由于变量不显示在 URL 中，所以无法把页面加入书签。 PHP $_REQUEST 变量 预定义的 $_REQUEST 变量包含了 $_GET、$_POST 和 $_COOKIE 的内容。 $_REQUEST 变量可用来收集通过 GET 和 POST 方法发送的表单数据。 你可以将 “welcome.php” 文件修改为如下代码，它可以接受 $_GET、$_POST等数据。12欢迎 &lt;?php echo $_REQUEST[&quot;fname&quot;]; ?&gt;!&lt;br&gt;你的年龄是 &lt;?php echo $_REQUEST[&quot;age&quot;]; ?&gt; 岁。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"php笔记一","slug":"PHP笔记一","date":"2017-12-05T12:23:20.000Z","updated":"2017-12-17T08:39:31.854Z","comments":true,"path":"2017/12/05/PHP笔记一/","link":"","permalink":"http://yoursite.com/2017/12/05/PHP笔记一/","excerpt":"","text":"为什么学PHP？ 学web前端也有一年多了，真是一入前端深四海，不入坑不知道坑有多深。这一年来从html、css 到javascript、后来又学了jQuery、Bootstrap、Vue.js几个js框架。经过在老师的建议下学了php，而且自己想对这方面有更多的了解。 一、php是什么？ PHP（外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一种通用开源脚本语言。语法吸收了C语言、Java和Perl的特点，利于学习，使用广泛，主要适用于Web开发领域。PHP 独特的语法混合了C、Java、Perl以及PHP自创的语法。它可以比CGI或者Perl更快速地执行动态网页。用PHP做出的动态页面与其他的编程语言相比，PHP是将程序嵌入到HTML（标准通用标记语言下的一个应用）文档中去执行，执行效率比完全生成HTML标记的CGI要高许多；PHP还可以执行编译后代码，编译可以达到加密和优化代码运行，使代码运行更快。 载自百度知道 二、php能干什么？ PHP 能做任何事。PHP 主要是用于服务端的脚本程序，因此您可以用 PHP 来完成任何其它的 CGI 程序能够完成的工作，例如收集表单数据，生成动态网页，或者发送/接收 Cookies。但 PHP 的功能远不局限于此。PHP 脚本主要用于以下三个领域。 服务端脚本。这是 PHP 最传统，也是最主要的目标领域。开展这项工作您需要具备以下三点：PHP 解析器（CGI 或者服务器模块）、WEB 服务器和 WEB 浏览器。您需要在运行 WEB 服务器时，安装并配置 PHP，然后，可以用 WEB 浏览器来访问 PHP 程序的输出，即浏览服务端的 PHP 页面。请查阅“安装”一章以获取更多信息。命令行脚本。您可以编写一段 PHP 脚本，并且不需要任何服务器或者浏览器来运行它。通过这种方式，您仅仅只需要 PHP 解析器来执行。这种用法对于依赖 cron（Unix 或者 Linux 环境）或者 Task Scheduler（Windows 环境）的日常运行的脚本来说是理想的选择。这些脚本也可以用来处理简单的文本。请参阅“PHP 的命令行模式”以获取更多信息。编写客户端的 GUI 应用程序。对于基于窗口式的应用程序来说，PHP 或许不是一种最好的语言，但是如果您非常精通 PHP，并且希望在您的客户端应用程序中使用 PHP 的一些高级特性，您可以利用 PHP-GTK 来编写这些程序。用这种方法，您还可以编写跨平台的应用程序。PHP-GTK 是 PHP 的一个扩展，在通常发布的 PHP 包中并不包含它。如果您对 PHP-GTK 感兴趣，请访问其网站以获取更多信息。 载自百度知道.三、php笔记一解决中文乱码一 在开头写：http-equiv1PHP代码应该写在```&lt;?php?&gt; 解决中文乱码二：text/html; charset12```echo```是输出的意思：```echo &quot;您好&quot;; 定义变量使用1234如```$y=10;echo var_dump($z);# 查看数据类型 数据类型:boolean （布尔型）integer （整型）float （浮点型, 也称作 double)string （字符串）两种复合类型：array （数组）object （对象）最后是两种特殊类型：resource （资源）NULL （NULL） 不用传址:1234567echo &quot;&lt;br&gt;&quot;;function fun2($qq1)&#123; $qq1=20; echo &quot;qq2这个值是&quot;.$qq1;&#125;$qq2=20;fun2($qq2); 用传址:1234567891011echo &quot;&lt;br&gt;&quot;;$qq2=30;function fun3(&amp;$qq1)&#123; $qq1=24; echo &quot;qq2 改变为传址这个值是&quot;.$qq1;&#125;;fun3($qq2);//qq1=qq2 都是30 然后 qq1改为24 qq2也是24 因为加了&amp;qq1echo &quot;&lt;br&gt;&quot;;echo &quot;传址之后qq2的值是&quot;.$qq2;//qq1=qq2 都是30 全局变量:12345678910$m=50;function fun4()&#123; global $m;#局部改变使用全局变量 $m=20;&#125;echo &quot;&lt;br&gt;&quot;;fun4();echo &quot;&lt;br&gt;&quot;;echo &quot;$m&quot;;echo &quot;&lt;br&gt;&quot;; 局部变量:1234567$h=10;function fun5()&#123; $h=40; return $h;&#125;$h=fun5();# 把局部转为全局echo &quot;$h&quot;; 静态变量: 用static 定义 静态变量只存在于函数作用域内，也就是说，静态变量只存活在栈中。一般的函数内变量在函数结束后会释放，比如局部变量，但是静态变量却不会。就是说，下次再调用这个函数的时候，该变量的值会保留下来。12345678function fun6()&#123; static $k=0; $k++; echo &quot;$k&lt;br&gt;&quot;;&#125;fun6();fun6();fun6(); 字符串:ucfirst 首字母大写:123$str1=&quot;hello World&quot;;$str2=ucfirst($str1);echo $str2;//Hello World strtolower 全部转换小写:123echo &quot;&lt;br&gt;&quot;;$str3=strtolower($str2);echo $str3;//hello world strtoupper() 全部转换大写:123echo &quot;&lt;br&gt;&quot;;$str4=strtoupper($str3);echo $str4;//HELLO WORLD strrev 翻转字符串123echo &quot;&lt;br&gt;&quot;;$str5=strrev($str4);echo $str5;//DLROW OLLEH strlen 字符串长度：12345echo &quot;&lt;br&gt;&quot;;$len=strlen($str3);for($i=0;$i&lt;$len;$i++)&#123; echo &quot;&lt;br&gt;&quot;.$str3[$i];&#125; // 字符串重复输出str_repeat(变量名字，重复次数):123$str6=str_repeat($str1,3);echo &quot;&lt;br&gt;&quot;;echo $str6; //补充字符串:1234567// str_pad(变量,&quot;补充的长度&quot;,&quot;补充的内容&quot;,什么方式补充&quot;)// STR_PAD_BOTH 字符串两边补充// STR_PAD_LEFT 字符串左边补充// STR_PAD_RIGHT 字符串右边补充$str7=str_pad($str1,&quot;20&quot;,&quot;*&quot;,STR_PAD_BOTH);echo &quot;&lt;br&gt;&quot;;echo $str7; trim($)去除字符串的空白:1234567//trim($) 去除字符串两边的空白//Ltrim($) 去掉左边的空白//Rtrim($) 去掉右边的空白$str8=&quot; hello tald &quot;;$str9=trim($str8);echo &quot;&lt;br&gt;&quot;;echo $str9; 替换字符串中的字符:1234//str_replace(&quot;把字符串中的...&quot;,&quot;替换成...&quot;,替换那个变量$..);$str10 = str_replace(&quot;l&quot;,&quot;a&quot;,$str8);echo &quot;&lt;br&gt;&quot;;echo $str10; 回车替换换成 nl2br($…):12345678$str11=&quot;111222333&quot;;$str12=nl2br($str11);echo &quot;&lt;br&gt;&quot;;echo $str12; html原样输出 htmlspecialchars:1234$str13=&quot;&lt;h1&gt;你好，世界！&lt;h1&gt;&quot;;$str14=htmlspecialchars($str13);echo &quot;&lt;br&gt;&quot;;echo $str14; 数组:12345678910$arr1=array(&quot;kete&quot;,&quot;lucy&quot;,&quot;Tom&quot;);echo $arr1[0];for ($i=0;$i&lt;count($arr1);$i++)&#123; echo $arr1[$i].&quot;&lt;br&gt;&quot;; //lucy Tom kate&#125;;foreach 只用于数组 遍历数组foreach($arr1 as $value)&#123; echo $value.&quot;&lt;br&gt;&quot;;&#125; 关联数组:1234567$arr2=array(&quot;0&quot;=&gt;&quot;kate&quot;,&quot;4&quot;=&gt;&quot;lucy&quot;,&quot;2&quot;=&gt;&quot;Tom&quot;);foreach($arr2 as $k=&gt;$value)&#123; echo $k.&quot;对应的是&quot;.$value.&quot;&lt;br&gt;&quot;; //0对应的是kate //4对应的是lucy //2对应的是Tom&#125; 二维数组:123456789$arr=array($arr1,$arr2);echo count($arr,1);//count 长度 不是1的话就是当前的长度 如果是1的话就递归的对数组计数 COUNT_RECURSIVE//根据键名进行排序 ksort 升序 krsort 降序krsort($arr2); //j降序echo &quot;&lt;br&gt;&quot;; //print_r($arr2);//输出方式1foreach ($arr2 as $k=&gt;$v)&#123; echo $k.&quot;对应的是&quot;.$v.&quot;&lt;br&gt;&quot;;&#125;//输出方式2 根据键值进行排序 asort升序 arsort 降序:1234arsort($arr2);//降序foreach($arr2 as $k=&gt;$v)&#123; echo $k.&quot;对应&quot;.$v.&quot;&lt;br&gt;&quot;;//降序&#125; range 键数组 ascii码排序:12345// range(low,high,step)//范围函数 （ 数组最低值 ，数组最高值 ，元素之间的步进制 默认1）$arr3=range(&quot;a&quot;,&quot;e&quot;);print_r($arr3);//Array ( [0] =&gt; a [1] =&gt; b [2] =&gt; c [3] =&gt; d [4] =&gt; e ) 把数组链接成字符串：1234$arr5=implode($arr1,&quot;0&quot;);// 用什么链接echo &quot;&lt;br&gt;&quot;;echo $arr5; //把字符串打散成数组:1234567$arr6=explode(&quot; &quot;,&quot;hello&quot;);// 用什么分隔开 用什么echo &quot;&lt;br&gt;&quot;;foreach($arr6 as $k=&gt;$v)&#123; echo $v.&quot;&lt;br&gt;&quot;; //a c e g&#125; 数组里开头增加元素 (会改变原数组):1234567//array_unshift($..,&quot;添加..&quot;)//在数组开头添加一个元素 会改变原数组array_unshift($arr1,&quot;we&quot;);foreach($arr1 as $k=&gt;$v)&#123; echo &quot;&lt;br&gt;&quot;; echo $v.&quot;在数组开头添加一个元素&quot;;&#125; 数组里结尾增加元素(会改变原数组) :12345678910//网数组里增加元素 array_push($..,&quot;添加..&quot;) 添加到数组最后一个元素//在数组结尾添加一个元素 会改变原数组array_push($arr1,&quot;123&quot;);print_r($arr1);//Array ( [0] =&gt; we [1] =&gt; kete [2] =&gt; lucy [3] =&gt; Tom [4] =&gt; 123 )foreach($arr1 as $k=&gt;$v)&#123; echo &quot;&lt;br&gt;&quot;; echo $v.&quot;&lt;br&gt;&quot;;&#125;//we kete lucy Tom 123 删除数组中的元素(会改变原数组)：123456//array_pop($..) 删除最后一个元素array_pop($arr1);foreach ($arr1 as $k=&gt;$v)&#123; echo $v.&quot;&lt;br&gt;&quot;;&#125;// we kete lucy Tom array_shift() 删除数组头部的元素(会改变原数组):123456array_shift($arr1);foreach ($arr1 as $k=&gt;$v)&#123; echo &quot;&lt;br&gt;&quot;; echo $v;&#125;//kete lucy om 删除数组头部的元素 array_unique() 不允许有重复的元素出现 会自动删除重复元素 (不会改变原始数组)：12345678$arr4=array(&quot;1&quot;,&quot;2&quot;,&quot;1&quot;);$arr5=array_unique($arr4);echo &quot;&lt;br&gt;&quot;;foreach($arr5 as $k=&gt;$v)&#123; echo &quot;&lt;br&gt;&quot;.$v.&quot;删除数组中重复的元素&quot;;&#125;//1删除数组中重复的元素//2删除数组中重复的元素 自学php推荐慕课在线练习，边练边学，并且很多免费视频.","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"Hexo常用命令","slug":"hexo常用技能一","date":"2017-12-05T11:00:03.000Z","updated":"2018-10-19T09:05:28.059Z","comments":true,"path":"2017/12/05/hexo常用技能一/","link":"","permalink":"http://yoursite.com/2017/12/05/hexo常用技能一/","excerpt":"","text":"hexo常用技能自从使用hexo搭建了自己的博客后，常常因为hexo 的各种命令苦恼，因此更新第一篇博文，首先把自己常用的hexo的命令记录下。 一、新建一个菜单：建博客是为的什么？当然是记录自己的学习、生活了，因此先从​ 1.自己的blog目录下打开命令行 $ hexo new page \"新建的菜单名字\"12 INFO Created: ~/blog/source/github/新建的菜单名字.md 这个指令会在source目录创建一个“新建的菜单名字”的文件夹,并在文件夹中创建一个新建的index.md的文件修改index.md 1234561 $ vim source/github/index.md 2 ----4 title: github3 date: 2016-08-25 18:27:595 ----6 # 我的第一个标签页 修改主题的配置文件,增加一个标签页菜单 12345678910111213menu: home: / || home about: /about/ || user tags: /tags/ || tags #categories: /categories/ || th #archives: /archives/ || archive 日程表: /日程表/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 书影音: /书影音/ || book 图库: /图库/ || image 留言板: /留言板/ || edit 作品展示: /作品展示/ || file-code-o 如果你对标签页的小图标不满意,也可以自己定义,这个图标其实是一种字体,在fontawesome.io 这个网站可以找到你满意的图标。修改方法就是将||后面的内容替换掉 然后执行hexo claen 在执行hexo s，本地查看无误后 执行hexo d 发布到博客即可 二、写文章在blog目录下执行创建文章指令12$ hexo new &quot;blog1&quot;INFO Created: ~/blog/source/_posts/blog1.md 然后修改source/_posts/blog1.md文件 12345678$ vim source/_posts/blog1.md 1 --- 2 title: blog1 3 date: 2016-08-25 18:50:03 4 tags: 5 --- 6 7 我的第一篇文章！ 清理后启动,就可以看到博客中新增加的文章了。 121 $ hexo clean2 $ hexo s --debug 三、创建分类新建一篇文章: 12$ hexo new &quot;new Types&quot; INFO Created: ~/blog/source/_posts/new-Types.md 修改文章的类型 : categories 12345678$ vim source/_posts/new-Types.md --- title: new Types date: 2016-08-25 20:23:37 categories: type1 description: 这里是内容简介 --- 我的分类是type1 清理后启动,就可以看到分类下面多了一个type1类型了 12$ hexo clean$ hexo s --debug 文章分类是自动的,不需要用户自己创建,只需要自己定义就可以了。 四、创建标签新建一篇文章: 12$ hexo new &quot;new tags&quot; INFO Created: ~/blog/source/_posts/new-tags.md 修改文章的标签 : tags 12345678$ vim source/_posts/new-tags.md --- title: new Types date: 2016-08-25 20:23:37 tags: tags1 description: 这里是内容简介 --- 我的标签是tags1 清理后启动,就可以看到标签下面多了一个type1标签了 12$ hexo clean$ hexo s --debug 文章标签是自动的,不需要用户自己创建,只需要自己定义就可以了。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-11-03T12:11:00.000Z","updated":"2018-06-10T08:39:09.390Z","comments":true,"path":"2017/11/03/hello-world/","link":"","permalink":"http://yoursite.com/2017/11/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}